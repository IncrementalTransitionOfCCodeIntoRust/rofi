/* automatically generated by rust-bindgen 0.54.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const G_ANALYZER_ANALYZING: u32 = 0;
pub const FALSE: u32 = 0;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const G_GINT16_MODIFIER: &'static [u8; 2usize] = b"h\0";
pub const G_GINT16_FORMAT: &'static [u8; 3usize] = b"hi\0";
pub const G_GUINT16_FORMAT: &'static [u8; 3usize] = b"hu\0";
pub const G_GINT32_MODIFIER: &'static [u8; 1usize] = b"\0";
pub const G_GINT32_FORMAT: &'static [u8; 2usize] = b"i\0";
pub const G_GUINT32_FORMAT: &'static [u8; 2usize] = b"u\0";
pub const G_HAVE_GINT64: u32 = 1;
pub const G_GINT64_MODIFIER: &'static [u8; 2usize] = b"l\0";
pub const G_GINT64_FORMAT: &'static [u8; 3usize] = b"li\0";
pub const G_GUINT64_FORMAT: &'static [u8; 3usize] = b"lu\0";
pub const GLIB_SIZEOF_VOID_P: u32 = 8;
pub const GLIB_SIZEOF_LONG: u32 = 8;
pub const GLIB_SIZEOF_SIZE_T: u32 = 8;
pub const GLIB_SIZEOF_SSIZE_T: u32 = 8;
pub const G_GSIZE_MODIFIER: &'static [u8; 2usize] = b"l\0";
pub const G_GSSIZE_MODIFIER: &'static [u8; 2usize] = b"l\0";
pub const G_GSIZE_FORMAT: &'static [u8; 3usize] = b"lu\0";
pub const G_GSSIZE_FORMAT: &'static [u8; 3usize] = b"li\0";
pub const G_GOFFSET_MODIFIER: &'static [u8; 2usize] = b"l\0";
pub const G_GOFFSET_FORMAT: &'static [u8; 3usize] = b"li\0";
pub const G_POLLFD_FORMAT: &'static [u8; 3usize] = b"%d\0";
pub const G_GINTPTR_MODIFIER: &'static [u8; 2usize] = b"l\0";
pub const G_GINTPTR_FORMAT: &'static [u8; 3usize] = b"li\0";
pub const G_GUINTPTR_FORMAT: &'static [u8; 3usize] = b"lu\0";
pub const GLIB_MAJOR_VERSION: u32 = 2;
pub const GLIB_MINOR_VERSION: u32 = 64;
pub const GLIB_MICRO_VERSION: u32 = 4;
pub const G_VA_COPY_AS_ARRAY: u32 = 1;
pub const G_HAVE_ISO_VARARGS: u32 = 1;
pub const G_HAVE_GROWING_STACK: u32 = 0;
pub const G_HAVE_GNUC_VISIBILITY: u32 = 1;
pub const G_HAVE_GNUC_VARARGS: u32 = 1;
pub const G_MODULE_SUFFIX: &'static [u8; 3usize] = b"so\0";
pub const G_PID_FORMAT: &'static [u8; 2usize] = b"i\0";
pub const GLIB_SYSDEF_AF_UNIX: u32 = 1;
pub const GLIB_SYSDEF_AF_INET: u32 = 2;
pub const GLIB_SYSDEF_AF_INET6: u32 = 10;
pub const GLIB_SYSDEF_MSG_OOB: u32 = 1;
pub const GLIB_SYSDEF_MSG_PEEK: u32 = 2;
pub const GLIB_SYSDEF_MSG_DONTROUTE: u32 = 4;
pub const G_DIR_SEPARATOR: u8 = 47u8;
pub const G_DIR_SEPARATOR_S: &'static [u8; 2usize] = b"/\0";
pub const G_SEARCHPATH_SEPARATOR: u8 = 58u8;
pub const G_SEARCHPATH_SEPARATOR_S: &'static [u8; 2usize] = b":\0";
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const __clockid_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const G_E: f64 = 2.718281828459045;
pub const G_LN2: f64 = 0.6931471805599453;
pub const G_LN10: f64 = 2.302585092994046;
pub const G_PI: f64 = 3.141592653589793;
pub const G_PI_2: f64 = 1.5707963267948966;
pub const G_PI_4: f64 = 0.7853981633974483;
pub const G_SQRT2: f64 = 1.4142135623730951;
pub const G_LITTLE_ENDIAN: u32 = 1234;
pub const G_BIG_ENDIAN: u32 = 4321;
pub const G_PDP_ENDIAN: u32 = 3412;
pub const G_IEEE754_FLOAT_BIAS: u32 = 127;
pub const G_IEEE754_DOUBLE_BIAS: u32 = 1023;
pub const G_LOG_2_BASE_10: f64 = 0.3010299956639812;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\0";
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const _BITS_SIGNUM_H: u32 = 1;
pub const _BITS_SIGNUM_GENERIC_H: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGILL: u32 = 4;
pub const SIGABRT: u32 = 6;
pub const SIGFPE: u32 = 8;
pub const SIGSEGV: u32 = 11;
pub const SIGTERM: u32 = 15;
pub const SIGHUP: u32 = 1;
pub const SIGQUIT: u32 = 3;
pub const SIGTRAP: u32 = 5;
pub const SIGKILL: u32 = 9;
pub const SIGBUS: u32 = 10;
pub const SIGSYS: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGURG: u32 = 16;
pub const SIGSTOP: u32 = 17;
pub const SIGTSTP: u32 = 18;
pub const SIGCONT: u32 = 19;
pub const SIGCHLD: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGPOLL: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGUSR1: u32 = 30;
pub const SIGUSR2: u32 = 31;
pub const SIGWINCH: u32 = 28;
pub const SIGIO: u32 = 23;
pub const SIGIOT: u32 = 6;
pub const SIGCLD: u32 = 20;
pub const __SIGRTMIN: u32 = 32;
pub const __SIGRTMAX: u32 = 32;
pub const _NSIG: u32 = 33;
pub const SIGSTKFLT: u32 = 16;
pub const SIGPWR: u32 = 30;
pub const __sig_atomic_t_defined: u32 = 1;
pub const __siginfo_t_defined: u32 = 1;
pub const __SI_MAX_SIZE: u32 = 128;
pub const _BITS_SIGINFO_ARCH_H: u32 = 1;
pub const __SI_ERRNO_THEN_CODE: u32 = 1;
pub const __SI_HAVE_SIGSYS: u32 = 1;
pub const _BITS_SIGINFO_CONSTS_H: u32 = 1;
pub const __SI_ASYNCIO_AFTER_SIGIO: u32 = 1;
pub const __sigevent_t_defined: u32 = 1;
pub const __SIGEV_MAX_SIZE: u32 = 64;
pub const _BITS_SIGEVENT_CONSTS_H: u32 = 1;
pub const NSIG: u32 = 33;
pub const _BITS_SIGACTION_H: u32 = 1;
pub const SA_NOCLDSTOP: u32 = 1;
pub const SA_NOCLDWAIT: u32 = 2;
pub const SA_SIGINFO: u32 = 4;
pub const SA_ONSTACK: u32 = 134217728;
pub const SA_RESTART: u32 = 268435456;
pub const SA_NODEFER: u32 = 1073741824;
pub const SA_RESETHAND: u32 = 2147483648;
pub const SA_INTERRUPT: u32 = 536870912;
pub const SA_NOMASK: u32 = 1073741824;
pub const SA_ONESHOT: u32 = 2147483648;
pub const SA_STACK: u32 = 134217728;
pub const SIG_BLOCK: u32 = 0;
pub const SIG_UNBLOCK: u32 = 1;
pub const SIG_SETMASK: u32 = 2;
pub const _BITS_SIGCONTEXT_H: u32 = 1;
pub const FP_XSTATE_MAGIC1: u32 = 1179670611;
pub const FP_XSTATE_MAGIC2: u32 = 1179670597;
pub const __stack_t_defined: u32 = 1;
pub const _SYS_UCONTEXT_H: u32 = 1;
pub const __NGREG: u32 = 23;
pub const NGREG: u32 = 23;
pub const _BITS_SIGSTACK_H: u32 = 1;
pub const MINSIGSTKSZ: u32 = 2048;
pub const SIGSTKSZ: u32 = 8192;
pub const _BITS_SS_FLAGS_H: u32 = 1;
pub const __sigstack_defined: u32 = 1;
pub const _BITS_SIGTHREAD_H: u32 = 1;
pub const G_DATALIST_FLAGS_MASK: u32 = 3;
pub const G_DATE_BAD_JULIAN: u32 = 0;
pub const G_DATE_BAD_DAY: u32 = 0;
pub const G_DATE_BAD_YEAR: u32 = 0;
pub const _DIRENT_H: u32 = 1;
pub const _DIRENT_MATCHES_DIRENT64: u32 = 1;
pub const MAXNAMLEN: u32 = 255;
pub const G_MEM_ALIGN: u32 = 8;
pub const G_HOOK_FLAG_USER_SHIFT: u32 = 4;
pub const G_PRIORITY_HIGH: i32 = -100;
pub const G_PRIORITY_DEFAULT: u32 = 0;
pub const G_PRIORITY_HIGH_IDLE: u32 = 100;
pub const G_PRIORITY_DEFAULT_IDLE: u32 = 200;
pub const G_PRIORITY_LOW: u32 = 300;
pub const G_SOURCE_REMOVE: u32 = 0;
pub const G_UNICHAR_MAX_DECOMPOSITION_LENGTH: u32 = 18;
pub const G_KEY_FILE_DESKTOP_GROUP: &'static [u8; 14usize] = b"Desktop Entry\0";
pub const G_KEY_FILE_DESKTOP_KEY_TYPE: &'static [u8; 5usize] = b"Type\0";
pub const G_KEY_FILE_DESKTOP_KEY_VERSION: &'static [u8; 8usize] = b"Version\0";
pub const G_KEY_FILE_DESKTOP_KEY_NAME: &'static [u8; 5usize] = b"Name\0";
pub const G_KEY_FILE_DESKTOP_KEY_GENERIC_NAME: &'static [u8; 12usize] = b"GenericName\0";
pub const G_KEY_FILE_DESKTOP_KEY_NO_DISPLAY: &'static [u8; 10usize] = b"NoDisplay\0";
pub const G_KEY_FILE_DESKTOP_KEY_COMMENT: &'static [u8; 8usize] = b"Comment\0";
pub const G_KEY_FILE_DESKTOP_KEY_ICON: &'static [u8; 5usize] = b"Icon\0";
pub const G_KEY_FILE_DESKTOP_KEY_HIDDEN: &'static [u8; 7usize] = b"Hidden\0";
pub const G_KEY_FILE_DESKTOP_KEY_ONLY_SHOW_IN: &'static [u8; 11usize] = b"OnlyShowIn\0";
pub const G_KEY_FILE_DESKTOP_KEY_NOT_SHOW_IN: &'static [u8; 10usize] = b"NotShowIn\0";
pub const G_KEY_FILE_DESKTOP_KEY_TRY_EXEC: &'static [u8; 8usize] = b"TryExec\0";
pub const G_KEY_FILE_DESKTOP_KEY_EXEC: &'static [u8; 5usize] = b"Exec\0";
pub const G_KEY_FILE_DESKTOP_KEY_PATH: &'static [u8; 5usize] = b"Path\0";
pub const G_KEY_FILE_DESKTOP_KEY_TERMINAL: &'static [u8; 9usize] = b"Terminal\0";
pub const G_KEY_FILE_DESKTOP_KEY_MIME_TYPE: &'static [u8; 9usize] = b"MimeType\0";
pub const G_KEY_FILE_DESKTOP_KEY_CATEGORIES: &'static [u8; 11usize] = b"Categories\0";
pub const G_KEY_FILE_DESKTOP_KEY_STARTUP_NOTIFY: &'static [u8; 14usize] = b"StartupNotify\0";
pub const G_KEY_FILE_DESKTOP_KEY_STARTUP_WM_CLASS: &'static [u8; 15usize] = b"StartupWMClass\0";
pub const G_KEY_FILE_DESKTOP_KEY_URL: &'static [u8; 4usize] = b"URL\0";
pub const G_KEY_FILE_DESKTOP_KEY_DBUS_ACTIVATABLE: &'static [u8; 16usize] = b"DBusActivatable\0";
pub const G_KEY_FILE_DESKTOP_KEY_ACTIONS: &'static [u8; 8usize] = b"Actions\0";
pub const G_KEY_FILE_DESKTOP_TYPE_APPLICATION: &'static [u8; 12usize] = b"Application\0";
pub const G_KEY_FILE_DESKTOP_TYPE_LINK: &'static [u8; 5usize] = b"Link\0";
pub const G_KEY_FILE_DESKTOP_TYPE_DIRECTORY: &'static [u8; 10usize] = b"Directory\0";
pub const G_LOG_LEVEL_USER_SHIFT: u32 = 8;
pub const G_OPTION_REMAINING: &'static [u8; 1usize] = b"\0";
pub const G_CSET_A_2_Z: &'static [u8; 27usize] = b"ABCDEFGHIJKLMNOPQRSTUVWXYZ\0";
pub const G_CSET_a_2_z: &'static [u8; 27usize] = b"abcdefghijklmnopqrstuvwxyz\0";
pub const G_CSET_DIGITS: &'static [u8; 11usize] = b"0123456789\0";
pub const G_CSET_LATINC: [u8; 31usize] = [
    192u8, 193u8, 194u8, 195u8, 196u8, 197u8, 198u8, 199u8, 200u8, 201u8, 202u8, 203u8, 204u8,
    205u8, 206u8, 207u8, 208u8, 209u8, 210u8, 211u8, 212u8, 213u8, 214u8, 216u8, 217u8, 218u8,
    219u8, 220u8, 221u8, 222u8, 0u8,
];
pub const G_CSET_LATINS: [u8; 33usize] = [
    223u8, 224u8, 225u8, 226u8, 227u8, 228u8, 229u8, 230u8, 231u8, 232u8, 233u8, 234u8, 235u8,
    236u8, 237u8, 238u8, 239u8, 240u8, 241u8, 242u8, 243u8, 244u8, 245u8, 246u8, 248u8, 249u8,
    250u8, 251u8, 252u8, 253u8, 254u8, 255u8, 0u8,
];
pub const G_STR_DELIMITERS: &'static [u8; 8usize] = b"_-|> <.\0";
pub const G_ASCII_DTOSTR_BUF_SIZE: u32 = 39;
pub const _STRING_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const G_TEST_OPTION_ISOLATE_DIRS: &'static [u8; 13usize] = b"isolate_dirs\0";
pub const G_USEC_PER_SEC: u32 = 1000000;
pub const G_URI_RESERVED_CHARS_GENERIC_DELIMITERS: &'static [u8; 8usize] = b":/?#[]@\0";
pub const G_URI_RESERVED_CHARS_SUBCOMPONENT_DELIMITERS: &'static [u8; 12usize] = b"!$&'()*+,;=\0";
pub const G_URI_RESERVED_CHARS_ALLOWED_IN_PATH_ELEMENT: &'static [u8; 14usize] = b"!$&'()*+,;=:@\0";
pub const G_URI_RESERVED_CHARS_ALLOWED_IN_PATH: &'static [u8; 15usize] = b"!$&'()*+,;=:@/\0";
pub const G_URI_RESERVED_CHARS_ALLOWED_IN_USERINFO: &'static [u8; 13usize] = b"!$&'()*+,;=:\0";
pub const G_ALLOC_ONLY: u32 = 1;
pub const G_ALLOC_AND_FREE: u32 = 2;
pub const G_ALLOCATOR_LIST: u32 = 1;
pub const G_ALLOCATOR_SLIST: u32 = 2;
pub const G_ALLOCATOR_NODE: u32 = 3;
pub const _PTHREAD_H: u32 = 1;
pub const _SCHED_H: u32 = 1;
pub const _BITS_SCHED_H: u32 = 1;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const _BITS_TYPES_STRUCT_SCHED_PARAM: u32 = 1;
pub const _BITS_CPU_SET_H: u32 = 1;
pub const __CPU_SETSIZE: u32 = 1024;
pub const _BITS_SETJMP_H: u32 = 1;
pub const PTHREAD_ONCE_INIT: u32 = 0;
pub const PTHREAD_BARRIER_SERIAL_THREAD: i32 = -1;
pub const CAIRO_VERSION_MAJOR: u32 = 1;
pub const CAIRO_VERSION_MINOR: u32 = 17;
pub const CAIRO_VERSION_MICRO: u32 = 3;
pub const CAIRO_HAS_FC_FONT: u32 = 1;
pub const CAIRO_HAS_FT_FONT: u32 = 1;
pub const CAIRO_HAS_GOBJECT_FUNCTIONS: u32 = 1;
pub const CAIRO_HAS_IMAGE_SURFACE: u32 = 1;
pub const CAIRO_HAS_MIME_SURFACE: u32 = 1;
pub const CAIRO_HAS_OBSERVER_SURFACE: u32 = 1;
pub const CAIRO_HAS_PDF_SURFACE: u32 = 1;
pub const CAIRO_HAS_PNG_FUNCTIONS: u32 = 1;
pub const CAIRO_HAS_PS_SURFACE: u32 = 1;
pub const CAIRO_HAS_RECORDING_SURFACE: u32 = 1;
pub const CAIRO_HAS_SCRIPT_SURFACE: u32 = 1;
pub const CAIRO_HAS_SVG_SURFACE: u32 = 1;
pub const CAIRO_HAS_TEE_SURFACE: u32 = 1;
pub const CAIRO_HAS_USER_FONT: u32 = 1;
pub const CAIRO_HAS_XCB_SHM_FUNCTIONS: u32 = 1;
pub const CAIRO_HAS_XCB_SURFACE: u32 = 1;
pub const CAIRO_HAS_XLIB_SURFACE: u32 = 1;
pub const CAIRO_HAS_XLIB_XRENDER_SURFACE: u32 = 1;
pub const CAIRO_TAG_DEST: &'static [u8; 11usize] = b"cairo.dest\0";
pub const CAIRO_TAG_LINK: &'static [u8; 5usize] = b"Link\0";
pub const CAIRO_MIME_TYPE_JPEG: &'static [u8; 11usize] = b"image/jpeg\0";
pub const CAIRO_MIME_TYPE_PNG: &'static [u8; 10usize] = b"image/png\0";
pub const CAIRO_MIME_TYPE_JP2: &'static [u8; 10usize] = b"image/jp2\0";
pub const CAIRO_MIME_TYPE_URI: &'static [u8; 11usize] = b"text/x-uri\0";
pub const CAIRO_MIME_TYPE_UNIQUE_ID: &'static [u8; 25usize] = b"application/x-cairo.uuid\0";
pub const CAIRO_MIME_TYPE_JBIG2: &'static [u8; 26usize] = b"application/x-cairo.jbig2\0";
pub const CAIRO_MIME_TYPE_JBIG2_GLOBAL: &'static [u8; 33usize] =
    b"application/x-cairo.jbig2-global\0";
pub const CAIRO_MIME_TYPE_JBIG2_GLOBAL_ID: &'static [u8; 36usize] =
    b"application/x-cairo.jbig2-global-id\0";
pub const CAIRO_MIME_TYPE_CCITT_FAX: &'static [u8; 12usize] = b"image/g3fax\0";
pub const CAIRO_MIME_TYPE_CCITT_FAX_PARAMS: &'static [u8; 33usize] =
    b"application/x-cairo.ccitt.params\0";
pub const CAIRO_MIME_TYPE_EPS: &'static [u8; 23usize] = b"application/postscript\0";
pub const CAIRO_MIME_TYPE_EPS_PARAMS: &'static [u8; 31usize] = b"application/x-cairo.eps.params\0";
pub const _STDINT_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _SYS_UIO_H: u32 = 1;
pub const __iovec_defined: u32 = 1;
pub const _BITS_UIO_LIM_H: u32 = 1;
pub const __IOV_MAX: u32 = 1024;
pub const UIO_MAXIOV: u32 = 1024;
pub const X_PROTOCOL: u32 = 11;
pub const X_PROTOCOL_REVISION: u32 = 0;
pub const X_TCP_PORT: u32 = 6000;
pub const XCB_CONN_ERROR: u32 = 1;
pub const XCB_CONN_CLOSED_EXT_NOTSUPPORTED: u32 = 2;
pub const XCB_CONN_CLOSED_MEM_INSUFFICIENT: u32 = 3;
pub const XCB_CONN_CLOSED_REQ_LEN_EXCEED: u32 = 4;
pub const XCB_CONN_CLOSED_PARSE_ERR: u32 = 5;
pub const XCB_CONN_CLOSED_INVALID_SCREEN: u32 = 6;
pub const XCB_CONN_CLOSED_FDPASSING_FAILED: u32 = 7;
pub const XCB_KEY_PRESS: u32 = 2;
pub const XCB_KEY_RELEASE: u32 = 3;
pub const XCB_BUTTON_PRESS: u32 = 4;
pub const XCB_BUTTON_RELEASE: u32 = 5;
pub const XCB_MOTION_NOTIFY: u32 = 6;
pub const XCB_ENTER_NOTIFY: u32 = 7;
pub const XCB_LEAVE_NOTIFY: u32 = 8;
pub const XCB_FOCUS_IN: u32 = 9;
pub const XCB_FOCUS_OUT: u32 = 10;
pub const XCB_KEYMAP_NOTIFY: u32 = 11;
pub const XCB_EXPOSE: u32 = 12;
pub const XCB_GRAPHICS_EXPOSURE: u32 = 13;
pub const XCB_NO_EXPOSURE: u32 = 14;
pub const XCB_VISIBILITY_NOTIFY: u32 = 15;
pub const XCB_CREATE_NOTIFY: u32 = 16;
pub const XCB_DESTROY_NOTIFY: u32 = 17;
pub const XCB_UNMAP_NOTIFY: u32 = 18;
pub const XCB_MAP_NOTIFY: u32 = 19;
pub const XCB_MAP_REQUEST: u32 = 20;
pub const XCB_REPARENT_NOTIFY: u32 = 21;
pub const XCB_CONFIGURE_NOTIFY: u32 = 22;
pub const XCB_CONFIGURE_REQUEST: u32 = 23;
pub const XCB_GRAVITY_NOTIFY: u32 = 24;
pub const XCB_RESIZE_REQUEST: u32 = 25;
pub const XCB_CIRCULATE_NOTIFY: u32 = 26;
pub const XCB_CIRCULATE_REQUEST: u32 = 27;
pub const XCB_PROPERTY_NOTIFY: u32 = 28;
pub const XCB_SELECTION_CLEAR: u32 = 29;
pub const XCB_SELECTION_REQUEST: u32 = 30;
pub const XCB_SELECTION_NOTIFY: u32 = 31;
pub const XCB_COLORMAP_NOTIFY: u32 = 32;
pub const XCB_CLIENT_MESSAGE: u32 = 33;
pub const XCB_MAPPING_NOTIFY: u32 = 34;
pub const XCB_GE_GENERIC: u32 = 35;
pub const XCB_REQUEST: u32 = 1;
pub const XCB_VALUE: u32 = 2;
pub const XCB_WINDOW: u32 = 3;
pub const XCB_PIXMAP: u32 = 4;
pub const XCB_ATOM: u32 = 5;
pub const XCB_CURSOR: u32 = 6;
pub const XCB_FONT: u32 = 7;
pub const XCB_MATCH: u32 = 8;
pub const XCB_DRAWABLE: u32 = 9;
pub const XCB_ACCESS: u32 = 10;
pub const XCB_ALLOC: u32 = 11;
pub const XCB_COLORMAP: u32 = 12;
pub const XCB_G_CONTEXT: u32 = 13;
pub const XCB_ID_CHOICE: u32 = 14;
pub const XCB_NAME: u32 = 15;
pub const XCB_LENGTH: u32 = 16;
pub const XCB_IMPLEMENTATION: u32 = 17;
pub const XCB_CREATE_WINDOW: u32 = 1;
pub const XCB_CHANGE_WINDOW_ATTRIBUTES: u32 = 2;
pub const XCB_GET_WINDOW_ATTRIBUTES: u32 = 3;
pub const XCB_DESTROY_WINDOW: u32 = 4;
pub const XCB_DESTROY_SUBWINDOWS: u32 = 5;
pub const XCB_CHANGE_SAVE_SET: u32 = 6;
pub const XCB_REPARENT_WINDOW: u32 = 7;
pub const XCB_MAP_WINDOW: u32 = 8;
pub const XCB_MAP_SUBWINDOWS: u32 = 9;
pub const XCB_UNMAP_WINDOW: u32 = 10;
pub const XCB_UNMAP_SUBWINDOWS: u32 = 11;
pub const XCB_CONFIGURE_WINDOW: u32 = 12;
pub const XCB_CIRCULATE_WINDOW: u32 = 13;
pub const XCB_GET_GEOMETRY: u32 = 14;
pub const XCB_QUERY_TREE: u32 = 15;
pub const XCB_INTERN_ATOM: u32 = 16;
pub const XCB_GET_ATOM_NAME: u32 = 17;
pub const XCB_CHANGE_PROPERTY: u32 = 18;
pub const XCB_DELETE_PROPERTY: u32 = 19;
pub const XCB_GET_PROPERTY: u32 = 20;
pub const XCB_LIST_PROPERTIES: u32 = 21;
pub const XCB_SET_SELECTION_OWNER: u32 = 22;
pub const XCB_GET_SELECTION_OWNER: u32 = 23;
pub const XCB_CONVERT_SELECTION: u32 = 24;
pub const XCB_SEND_EVENT: u32 = 25;
pub const XCB_GRAB_POINTER: u32 = 26;
pub const XCB_UNGRAB_POINTER: u32 = 27;
pub const XCB_GRAB_BUTTON: u32 = 28;
pub const XCB_UNGRAB_BUTTON: u32 = 29;
pub const XCB_CHANGE_ACTIVE_POINTER_GRAB: u32 = 30;
pub const XCB_GRAB_KEYBOARD: u32 = 31;
pub const XCB_UNGRAB_KEYBOARD: u32 = 32;
pub const XCB_GRAB_KEY: u32 = 33;
pub const XCB_UNGRAB_KEY: u32 = 34;
pub const XCB_ALLOW_EVENTS: u32 = 35;
pub const XCB_GRAB_SERVER: u32 = 36;
pub const XCB_UNGRAB_SERVER: u32 = 37;
pub const XCB_QUERY_POINTER: u32 = 38;
pub const XCB_GET_MOTION_EVENTS: u32 = 39;
pub const XCB_TRANSLATE_COORDINATES: u32 = 40;
pub const XCB_WARP_POINTER: u32 = 41;
pub const XCB_SET_INPUT_FOCUS: u32 = 42;
pub const XCB_GET_INPUT_FOCUS: u32 = 43;
pub const XCB_QUERY_KEYMAP: u32 = 44;
pub const XCB_OPEN_FONT: u32 = 45;
pub const XCB_CLOSE_FONT: u32 = 46;
pub const XCB_QUERY_FONT: u32 = 47;
pub const XCB_QUERY_TEXT_EXTENTS: u32 = 48;
pub const XCB_LIST_FONTS: u32 = 49;
pub const XCB_LIST_FONTS_WITH_INFO: u32 = 50;
pub const XCB_SET_FONT_PATH: u32 = 51;
pub const XCB_GET_FONT_PATH: u32 = 52;
pub const XCB_CREATE_PIXMAP: u32 = 53;
pub const XCB_FREE_PIXMAP: u32 = 54;
pub const XCB_CREATE_GC: u32 = 55;
pub const XCB_CHANGE_GC: u32 = 56;
pub const XCB_COPY_GC: u32 = 57;
pub const XCB_SET_DASHES: u32 = 58;
pub const XCB_SET_CLIP_RECTANGLES: u32 = 59;
pub const XCB_FREE_GC: u32 = 60;
pub const XCB_CLEAR_AREA: u32 = 61;
pub const XCB_COPY_AREA: u32 = 62;
pub const XCB_COPY_PLANE: u32 = 63;
pub const XCB_POLY_POINT: u32 = 64;
pub const XCB_POLY_LINE: u32 = 65;
pub const XCB_POLY_SEGMENT: u32 = 66;
pub const XCB_POLY_RECTANGLE: u32 = 67;
pub const XCB_POLY_ARC: u32 = 68;
pub const XCB_FILL_POLY: u32 = 69;
pub const XCB_POLY_FILL_RECTANGLE: u32 = 70;
pub const XCB_POLY_FILL_ARC: u32 = 71;
pub const XCB_PUT_IMAGE: u32 = 72;
pub const XCB_GET_IMAGE: u32 = 73;
pub const XCB_POLY_TEXT_8: u32 = 74;
pub const XCB_POLY_TEXT_16: u32 = 75;
pub const XCB_IMAGE_TEXT_8: u32 = 76;
pub const XCB_IMAGE_TEXT_16: u32 = 77;
pub const XCB_CREATE_COLORMAP: u32 = 78;
pub const XCB_FREE_COLORMAP: u32 = 79;
pub const XCB_COPY_COLORMAP_AND_FREE: u32 = 80;
pub const XCB_INSTALL_COLORMAP: u32 = 81;
pub const XCB_UNINSTALL_COLORMAP: u32 = 82;
pub const XCB_LIST_INSTALLED_COLORMAPS: u32 = 83;
pub const XCB_ALLOC_COLOR: u32 = 84;
pub const XCB_ALLOC_NAMED_COLOR: u32 = 85;
pub const XCB_ALLOC_COLOR_CELLS: u32 = 86;
pub const XCB_ALLOC_COLOR_PLANES: u32 = 87;
pub const XCB_FREE_COLORS: u32 = 88;
pub const XCB_STORE_COLORS: u32 = 89;
pub const XCB_STORE_NAMED_COLOR: u32 = 90;
pub const XCB_QUERY_COLORS: u32 = 91;
pub const XCB_LOOKUP_COLOR: u32 = 92;
pub const XCB_CREATE_CURSOR: u32 = 93;
pub const XCB_CREATE_GLYPH_CURSOR: u32 = 94;
pub const XCB_FREE_CURSOR: u32 = 95;
pub const XCB_RECOLOR_CURSOR: u32 = 96;
pub const XCB_QUERY_BEST_SIZE: u32 = 97;
pub const XCB_QUERY_EXTENSION: u32 = 98;
pub const XCB_LIST_EXTENSIONS: u32 = 99;
pub const XCB_CHANGE_KEYBOARD_MAPPING: u32 = 100;
pub const XCB_GET_KEYBOARD_MAPPING: u32 = 101;
pub const XCB_CHANGE_KEYBOARD_CONTROL: u32 = 102;
pub const XCB_GET_KEYBOARD_CONTROL: u32 = 103;
pub const XCB_BELL: u32 = 104;
pub const XCB_CHANGE_POINTER_CONTROL: u32 = 105;
pub const XCB_GET_POINTER_CONTROL: u32 = 106;
pub const XCB_SET_SCREEN_SAVER: u32 = 107;
pub const XCB_GET_SCREEN_SAVER: u32 = 108;
pub const XCB_CHANGE_HOSTS: u32 = 109;
pub const XCB_LIST_HOSTS: u32 = 110;
pub const XCB_SET_ACCESS_CONTROL: u32 = 111;
pub const XCB_SET_CLOSE_DOWN_MODE: u32 = 112;
pub const XCB_KILL_CLIENT: u32 = 113;
pub const XCB_ROTATE_PROPERTIES: u32 = 114;
pub const XCB_FORCE_SCREEN_SAVER: u32 = 115;
pub const XCB_SET_POINTER_MAPPING: u32 = 116;
pub const XCB_GET_POINTER_MAPPING: u32 = 117;
pub const XCB_SET_MODIFIER_MAPPING: u32 = 118;
pub const XCB_GET_MODIFIER_MAPPING: u32 = 119;
pub const XCB_NO_OPERATION: u32 = 127;
pub const XCB_NONE: u32 = 0;
pub const XCB_COPY_FROM_PARENT: u32 = 0;
pub const XCB_CURRENT_TIME: u32 = 0;
pub const XCB_NO_SYMBOL: u32 = 0;
pub const _STDIO_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const XKB_MOD_NAME_SHIFT: &'static [u8; 6usize] = b"Shift\0";
pub const XKB_MOD_NAME_CAPS: &'static [u8; 5usize] = b"Lock\0";
pub const XKB_MOD_NAME_CTRL: &'static [u8; 8usize] = b"Control\0";
pub const XKB_MOD_NAME_ALT: &'static [u8; 5usize] = b"Mod1\0";
pub const XKB_MOD_NAME_NUM: &'static [u8; 5usize] = b"Mod2\0";
pub const XKB_MOD_NAME_LOGO: &'static [u8; 5usize] = b"Mod4\0";
pub const XKB_LED_NAME_CAPS: &'static [u8; 10usize] = b"Caps Lock\0";
pub const XKB_LED_NAME_NUM: &'static [u8; 9usize] = b"Num Lock\0";
pub const XKB_LED_NAME_SCROLL: &'static [u8; 12usize] = b"Scroll Lock\0";
pub const XKB_KEY_NoSymbol: u32 = 0;
pub const XKB_KEY_VoidSymbol: u32 = 16777215;
pub const XKB_KEY_BackSpace: u32 = 65288;
pub const XKB_KEY_Tab: u32 = 65289;
pub const XKB_KEY_Linefeed: u32 = 65290;
pub const XKB_KEY_Clear: u32 = 65291;
pub const XKB_KEY_Return: u32 = 65293;
pub const XKB_KEY_Pause: u32 = 65299;
pub const XKB_KEY_Scroll_Lock: u32 = 65300;
pub const XKB_KEY_Sys_Req: u32 = 65301;
pub const XKB_KEY_Escape: u32 = 65307;
pub const XKB_KEY_Delete: u32 = 65535;
pub const XKB_KEY_Multi_key: u32 = 65312;
pub const XKB_KEY_Codeinput: u32 = 65335;
pub const XKB_KEY_SingleCandidate: u32 = 65340;
pub const XKB_KEY_MultipleCandidate: u32 = 65341;
pub const XKB_KEY_PreviousCandidate: u32 = 65342;
pub const XKB_KEY_Kanji: u32 = 65313;
pub const XKB_KEY_Muhenkan: u32 = 65314;
pub const XKB_KEY_Henkan_Mode: u32 = 65315;
pub const XKB_KEY_Henkan: u32 = 65315;
pub const XKB_KEY_Romaji: u32 = 65316;
pub const XKB_KEY_Hiragana: u32 = 65317;
pub const XKB_KEY_Katakana: u32 = 65318;
pub const XKB_KEY_Hiragana_Katakana: u32 = 65319;
pub const XKB_KEY_Zenkaku: u32 = 65320;
pub const XKB_KEY_Hankaku: u32 = 65321;
pub const XKB_KEY_Zenkaku_Hankaku: u32 = 65322;
pub const XKB_KEY_Touroku: u32 = 65323;
pub const XKB_KEY_Massyo: u32 = 65324;
pub const XKB_KEY_Kana_Lock: u32 = 65325;
pub const XKB_KEY_Kana_Shift: u32 = 65326;
pub const XKB_KEY_Eisu_Shift: u32 = 65327;
pub const XKB_KEY_Eisu_toggle: u32 = 65328;
pub const XKB_KEY_Kanji_Bangou: u32 = 65335;
pub const XKB_KEY_Zen_Koho: u32 = 65341;
pub const XKB_KEY_Mae_Koho: u32 = 65342;
pub const XKB_KEY_Home: u32 = 65360;
pub const XKB_KEY_Left: u32 = 65361;
pub const XKB_KEY_Up: u32 = 65362;
pub const XKB_KEY_Right: u32 = 65363;
pub const XKB_KEY_Down: u32 = 65364;
pub const XKB_KEY_Prior: u32 = 65365;
pub const XKB_KEY_Page_Up: u32 = 65365;
pub const XKB_KEY_Next: u32 = 65366;
pub const XKB_KEY_Page_Down: u32 = 65366;
pub const XKB_KEY_End: u32 = 65367;
pub const XKB_KEY_Begin: u32 = 65368;
pub const XKB_KEY_Select: u32 = 65376;
pub const XKB_KEY_Print: u32 = 65377;
pub const XKB_KEY_Execute: u32 = 65378;
pub const XKB_KEY_Insert: u32 = 65379;
pub const XKB_KEY_Undo: u32 = 65381;
pub const XKB_KEY_Redo: u32 = 65382;
pub const XKB_KEY_Menu: u32 = 65383;
pub const XKB_KEY_Find: u32 = 65384;
pub const XKB_KEY_Cancel: u32 = 65385;
pub const XKB_KEY_Help: u32 = 65386;
pub const XKB_KEY_Break: u32 = 65387;
pub const XKB_KEY_Mode_switch: u32 = 65406;
pub const XKB_KEY_script_switch: u32 = 65406;
pub const XKB_KEY_Num_Lock: u32 = 65407;
pub const XKB_KEY_KP_Space: u32 = 65408;
pub const XKB_KEY_KP_Tab: u32 = 65417;
pub const XKB_KEY_KP_Enter: u32 = 65421;
pub const XKB_KEY_KP_F1: u32 = 65425;
pub const XKB_KEY_KP_F2: u32 = 65426;
pub const XKB_KEY_KP_F3: u32 = 65427;
pub const XKB_KEY_KP_F4: u32 = 65428;
pub const XKB_KEY_KP_Home: u32 = 65429;
pub const XKB_KEY_KP_Left: u32 = 65430;
pub const XKB_KEY_KP_Up: u32 = 65431;
pub const XKB_KEY_KP_Right: u32 = 65432;
pub const XKB_KEY_KP_Down: u32 = 65433;
pub const XKB_KEY_KP_Prior: u32 = 65434;
pub const XKB_KEY_KP_Page_Up: u32 = 65434;
pub const XKB_KEY_KP_Next: u32 = 65435;
pub const XKB_KEY_KP_Page_Down: u32 = 65435;
pub const XKB_KEY_KP_End: u32 = 65436;
pub const XKB_KEY_KP_Begin: u32 = 65437;
pub const XKB_KEY_KP_Insert: u32 = 65438;
pub const XKB_KEY_KP_Delete: u32 = 65439;
pub const XKB_KEY_KP_Equal: u32 = 65469;
pub const XKB_KEY_KP_Multiply: u32 = 65450;
pub const XKB_KEY_KP_Add: u32 = 65451;
pub const XKB_KEY_KP_Separator: u32 = 65452;
pub const XKB_KEY_KP_Subtract: u32 = 65453;
pub const XKB_KEY_KP_Decimal: u32 = 65454;
pub const XKB_KEY_KP_Divide: u32 = 65455;
pub const XKB_KEY_KP_0: u32 = 65456;
pub const XKB_KEY_KP_1: u32 = 65457;
pub const XKB_KEY_KP_2: u32 = 65458;
pub const XKB_KEY_KP_3: u32 = 65459;
pub const XKB_KEY_KP_4: u32 = 65460;
pub const XKB_KEY_KP_5: u32 = 65461;
pub const XKB_KEY_KP_6: u32 = 65462;
pub const XKB_KEY_KP_7: u32 = 65463;
pub const XKB_KEY_KP_8: u32 = 65464;
pub const XKB_KEY_KP_9: u32 = 65465;
pub const XKB_KEY_F1: u32 = 65470;
pub const XKB_KEY_F2: u32 = 65471;
pub const XKB_KEY_F3: u32 = 65472;
pub const XKB_KEY_F4: u32 = 65473;
pub const XKB_KEY_F5: u32 = 65474;
pub const XKB_KEY_F6: u32 = 65475;
pub const XKB_KEY_F7: u32 = 65476;
pub const XKB_KEY_F8: u32 = 65477;
pub const XKB_KEY_F9: u32 = 65478;
pub const XKB_KEY_F10: u32 = 65479;
pub const XKB_KEY_F11: u32 = 65480;
pub const XKB_KEY_L1: u32 = 65480;
pub const XKB_KEY_F12: u32 = 65481;
pub const XKB_KEY_L2: u32 = 65481;
pub const XKB_KEY_F13: u32 = 65482;
pub const XKB_KEY_L3: u32 = 65482;
pub const XKB_KEY_F14: u32 = 65483;
pub const XKB_KEY_L4: u32 = 65483;
pub const XKB_KEY_F15: u32 = 65484;
pub const XKB_KEY_L5: u32 = 65484;
pub const XKB_KEY_F16: u32 = 65485;
pub const XKB_KEY_L6: u32 = 65485;
pub const XKB_KEY_F17: u32 = 65486;
pub const XKB_KEY_L7: u32 = 65486;
pub const XKB_KEY_F18: u32 = 65487;
pub const XKB_KEY_L8: u32 = 65487;
pub const XKB_KEY_F19: u32 = 65488;
pub const XKB_KEY_L9: u32 = 65488;
pub const XKB_KEY_F20: u32 = 65489;
pub const XKB_KEY_L10: u32 = 65489;
pub const XKB_KEY_F21: u32 = 65490;
pub const XKB_KEY_R1: u32 = 65490;
pub const XKB_KEY_F22: u32 = 65491;
pub const XKB_KEY_R2: u32 = 65491;
pub const XKB_KEY_F23: u32 = 65492;
pub const XKB_KEY_R3: u32 = 65492;
pub const XKB_KEY_F24: u32 = 65493;
pub const XKB_KEY_R4: u32 = 65493;
pub const XKB_KEY_F25: u32 = 65494;
pub const XKB_KEY_R5: u32 = 65494;
pub const XKB_KEY_F26: u32 = 65495;
pub const XKB_KEY_R6: u32 = 65495;
pub const XKB_KEY_F27: u32 = 65496;
pub const XKB_KEY_R7: u32 = 65496;
pub const XKB_KEY_F28: u32 = 65497;
pub const XKB_KEY_R8: u32 = 65497;
pub const XKB_KEY_F29: u32 = 65498;
pub const XKB_KEY_R9: u32 = 65498;
pub const XKB_KEY_F30: u32 = 65499;
pub const XKB_KEY_R10: u32 = 65499;
pub const XKB_KEY_F31: u32 = 65500;
pub const XKB_KEY_R11: u32 = 65500;
pub const XKB_KEY_F32: u32 = 65501;
pub const XKB_KEY_R12: u32 = 65501;
pub const XKB_KEY_F33: u32 = 65502;
pub const XKB_KEY_R13: u32 = 65502;
pub const XKB_KEY_F34: u32 = 65503;
pub const XKB_KEY_R14: u32 = 65503;
pub const XKB_KEY_F35: u32 = 65504;
pub const XKB_KEY_R15: u32 = 65504;
pub const XKB_KEY_Shift_L: u32 = 65505;
pub const XKB_KEY_Shift_R: u32 = 65506;
pub const XKB_KEY_Control_L: u32 = 65507;
pub const XKB_KEY_Control_R: u32 = 65508;
pub const XKB_KEY_Caps_Lock: u32 = 65509;
pub const XKB_KEY_Shift_Lock: u32 = 65510;
pub const XKB_KEY_Meta_L: u32 = 65511;
pub const XKB_KEY_Meta_R: u32 = 65512;
pub const XKB_KEY_Alt_L: u32 = 65513;
pub const XKB_KEY_Alt_R: u32 = 65514;
pub const XKB_KEY_Super_L: u32 = 65515;
pub const XKB_KEY_Super_R: u32 = 65516;
pub const XKB_KEY_Hyper_L: u32 = 65517;
pub const XKB_KEY_Hyper_R: u32 = 65518;
pub const XKB_KEY_ISO_Lock: u32 = 65025;
pub const XKB_KEY_ISO_Level2_Latch: u32 = 65026;
pub const XKB_KEY_ISO_Level3_Shift: u32 = 65027;
pub const XKB_KEY_ISO_Level3_Latch: u32 = 65028;
pub const XKB_KEY_ISO_Level3_Lock: u32 = 65029;
pub const XKB_KEY_ISO_Level5_Shift: u32 = 65041;
pub const XKB_KEY_ISO_Level5_Latch: u32 = 65042;
pub const XKB_KEY_ISO_Level5_Lock: u32 = 65043;
pub const XKB_KEY_ISO_Group_Shift: u32 = 65406;
pub const XKB_KEY_ISO_Group_Latch: u32 = 65030;
pub const XKB_KEY_ISO_Group_Lock: u32 = 65031;
pub const XKB_KEY_ISO_Next_Group: u32 = 65032;
pub const XKB_KEY_ISO_Next_Group_Lock: u32 = 65033;
pub const XKB_KEY_ISO_Prev_Group: u32 = 65034;
pub const XKB_KEY_ISO_Prev_Group_Lock: u32 = 65035;
pub const XKB_KEY_ISO_First_Group: u32 = 65036;
pub const XKB_KEY_ISO_First_Group_Lock: u32 = 65037;
pub const XKB_KEY_ISO_Last_Group: u32 = 65038;
pub const XKB_KEY_ISO_Last_Group_Lock: u32 = 65039;
pub const XKB_KEY_ISO_Left_Tab: u32 = 65056;
pub const XKB_KEY_ISO_Move_Line_Up: u32 = 65057;
pub const XKB_KEY_ISO_Move_Line_Down: u32 = 65058;
pub const XKB_KEY_ISO_Partial_Line_Up: u32 = 65059;
pub const XKB_KEY_ISO_Partial_Line_Down: u32 = 65060;
pub const XKB_KEY_ISO_Partial_Space_Left: u32 = 65061;
pub const XKB_KEY_ISO_Partial_Space_Right: u32 = 65062;
pub const XKB_KEY_ISO_Set_Margin_Left: u32 = 65063;
pub const XKB_KEY_ISO_Set_Margin_Right: u32 = 65064;
pub const XKB_KEY_ISO_Release_Margin_Left: u32 = 65065;
pub const XKB_KEY_ISO_Release_Margin_Right: u32 = 65066;
pub const XKB_KEY_ISO_Release_Both_Margins: u32 = 65067;
pub const XKB_KEY_ISO_Fast_Cursor_Left: u32 = 65068;
pub const XKB_KEY_ISO_Fast_Cursor_Right: u32 = 65069;
pub const XKB_KEY_ISO_Fast_Cursor_Up: u32 = 65070;
pub const XKB_KEY_ISO_Fast_Cursor_Down: u32 = 65071;
pub const XKB_KEY_ISO_Continuous_Underline: u32 = 65072;
pub const XKB_KEY_ISO_Discontinuous_Underline: u32 = 65073;
pub const XKB_KEY_ISO_Emphasize: u32 = 65074;
pub const XKB_KEY_ISO_Center_Object: u32 = 65075;
pub const XKB_KEY_ISO_Enter: u32 = 65076;
pub const XKB_KEY_dead_grave: u32 = 65104;
pub const XKB_KEY_dead_acute: u32 = 65105;
pub const XKB_KEY_dead_circumflex: u32 = 65106;
pub const XKB_KEY_dead_tilde: u32 = 65107;
pub const XKB_KEY_dead_perispomeni: u32 = 65107;
pub const XKB_KEY_dead_macron: u32 = 65108;
pub const XKB_KEY_dead_breve: u32 = 65109;
pub const XKB_KEY_dead_abovedot: u32 = 65110;
pub const XKB_KEY_dead_diaeresis: u32 = 65111;
pub const XKB_KEY_dead_abovering: u32 = 65112;
pub const XKB_KEY_dead_doubleacute: u32 = 65113;
pub const XKB_KEY_dead_caron: u32 = 65114;
pub const XKB_KEY_dead_cedilla: u32 = 65115;
pub const XKB_KEY_dead_ogonek: u32 = 65116;
pub const XKB_KEY_dead_iota: u32 = 65117;
pub const XKB_KEY_dead_voiced_sound: u32 = 65118;
pub const XKB_KEY_dead_semivoiced_sound: u32 = 65119;
pub const XKB_KEY_dead_belowdot: u32 = 65120;
pub const XKB_KEY_dead_hook: u32 = 65121;
pub const XKB_KEY_dead_horn: u32 = 65122;
pub const XKB_KEY_dead_stroke: u32 = 65123;
pub const XKB_KEY_dead_abovecomma: u32 = 65124;
pub const XKB_KEY_dead_psili: u32 = 65124;
pub const XKB_KEY_dead_abovereversedcomma: u32 = 65125;
pub const XKB_KEY_dead_dasia: u32 = 65125;
pub const XKB_KEY_dead_doublegrave: u32 = 65126;
pub const XKB_KEY_dead_belowring: u32 = 65127;
pub const XKB_KEY_dead_belowmacron: u32 = 65128;
pub const XKB_KEY_dead_belowcircumflex: u32 = 65129;
pub const XKB_KEY_dead_belowtilde: u32 = 65130;
pub const XKB_KEY_dead_belowbreve: u32 = 65131;
pub const XKB_KEY_dead_belowdiaeresis: u32 = 65132;
pub const XKB_KEY_dead_invertedbreve: u32 = 65133;
pub const XKB_KEY_dead_belowcomma: u32 = 65134;
pub const XKB_KEY_dead_currency: u32 = 65135;
pub const XKB_KEY_dead_lowline: u32 = 65168;
pub const XKB_KEY_dead_aboveverticalline: u32 = 65169;
pub const XKB_KEY_dead_belowverticalline: u32 = 65170;
pub const XKB_KEY_dead_longsolidusoverlay: u32 = 65171;
pub const XKB_KEY_dead_a: u32 = 65152;
pub const XKB_KEY_dead_A: u32 = 65153;
pub const XKB_KEY_dead_e: u32 = 65154;
pub const XKB_KEY_dead_E: u32 = 65155;
pub const XKB_KEY_dead_i: u32 = 65156;
pub const XKB_KEY_dead_I: u32 = 65157;
pub const XKB_KEY_dead_o: u32 = 65158;
pub const XKB_KEY_dead_O: u32 = 65159;
pub const XKB_KEY_dead_u: u32 = 65160;
pub const XKB_KEY_dead_U: u32 = 65161;
pub const XKB_KEY_dead_small_schwa: u32 = 65162;
pub const XKB_KEY_dead_capital_schwa: u32 = 65163;
pub const XKB_KEY_dead_greek: u32 = 65164;
pub const XKB_KEY_First_Virtual_Screen: u32 = 65232;
pub const XKB_KEY_Prev_Virtual_Screen: u32 = 65233;
pub const XKB_KEY_Next_Virtual_Screen: u32 = 65234;
pub const XKB_KEY_Last_Virtual_Screen: u32 = 65236;
pub const XKB_KEY_Terminate_Server: u32 = 65237;
pub const XKB_KEY_AccessX_Enable: u32 = 65136;
pub const XKB_KEY_AccessX_Feedback_Enable: u32 = 65137;
pub const XKB_KEY_RepeatKeys_Enable: u32 = 65138;
pub const XKB_KEY_SlowKeys_Enable: u32 = 65139;
pub const XKB_KEY_BounceKeys_Enable: u32 = 65140;
pub const XKB_KEY_StickyKeys_Enable: u32 = 65141;
pub const XKB_KEY_MouseKeys_Enable: u32 = 65142;
pub const XKB_KEY_MouseKeys_Accel_Enable: u32 = 65143;
pub const XKB_KEY_Overlay1_Enable: u32 = 65144;
pub const XKB_KEY_Overlay2_Enable: u32 = 65145;
pub const XKB_KEY_AudibleBell_Enable: u32 = 65146;
pub const XKB_KEY_Pointer_Left: u32 = 65248;
pub const XKB_KEY_Pointer_Right: u32 = 65249;
pub const XKB_KEY_Pointer_Up: u32 = 65250;
pub const XKB_KEY_Pointer_Down: u32 = 65251;
pub const XKB_KEY_Pointer_UpLeft: u32 = 65252;
pub const XKB_KEY_Pointer_UpRight: u32 = 65253;
pub const XKB_KEY_Pointer_DownLeft: u32 = 65254;
pub const XKB_KEY_Pointer_DownRight: u32 = 65255;
pub const XKB_KEY_Pointer_Button_Dflt: u32 = 65256;
pub const XKB_KEY_Pointer_Button1: u32 = 65257;
pub const XKB_KEY_Pointer_Button2: u32 = 65258;
pub const XKB_KEY_Pointer_Button3: u32 = 65259;
pub const XKB_KEY_Pointer_Button4: u32 = 65260;
pub const XKB_KEY_Pointer_Button5: u32 = 65261;
pub const XKB_KEY_Pointer_DblClick_Dflt: u32 = 65262;
pub const XKB_KEY_Pointer_DblClick1: u32 = 65263;
pub const XKB_KEY_Pointer_DblClick2: u32 = 65264;
pub const XKB_KEY_Pointer_DblClick3: u32 = 65265;
pub const XKB_KEY_Pointer_DblClick4: u32 = 65266;
pub const XKB_KEY_Pointer_DblClick5: u32 = 65267;
pub const XKB_KEY_Pointer_Drag_Dflt: u32 = 65268;
pub const XKB_KEY_Pointer_Drag1: u32 = 65269;
pub const XKB_KEY_Pointer_Drag2: u32 = 65270;
pub const XKB_KEY_Pointer_Drag3: u32 = 65271;
pub const XKB_KEY_Pointer_Drag4: u32 = 65272;
pub const XKB_KEY_Pointer_Drag5: u32 = 65277;
pub const XKB_KEY_Pointer_EnableKeys: u32 = 65273;
pub const XKB_KEY_Pointer_Accelerate: u32 = 65274;
pub const XKB_KEY_Pointer_DfltBtnNext: u32 = 65275;
pub const XKB_KEY_Pointer_DfltBtnPrev: u32 = 65276;
pub const XKB_KEY_ch: u32 = 65184;
pub const XKB_KEY_Ch: u32 = 65185;
pub const XKB_KEY_CH: u32 = 65186;
pub const XKB_KEY_c_h: u32 = 65187;
pub const XKB_KEY_C_h: u32 = 65188;
pub const XKB_KEY_C_H: u32 = 65189;
pub const XKB_KEY_3270_Duplicate: u32 = 64769;
pub const XKB_KEY_3270_FieldMark: u32 = 64770;
pub const XKB_KEY_3270_Right2: u32 = 64771;
pub const XKB_KEY_3270_Left2: u32 = 64772;
pub const XKB_KEY_3270_BackTab: u32 = 64773;
pub const XKB_KEY_3270_EraseEOF: u32 = 64774;
pub const XKB_KEY_3270_EraseInput: u32 = 64775;
pub const XKB_KEY_3270_Reset: u32 = 64776;
pub const XKB_KEY_3270_Quit: u32 = 64777;
pub const XKB_KEY_3270_PA1: u32 = 64778;
pub const XKB_KEY_3270_PA2: u32 = 64779;
pub const XKB_KEY_3270_PA3: u32 = 64780;
pub const XKB_KEY_3270_Test: u32 = 64781;
pub const XKB_KEY_3270_Attn: u32 = 64782;
pub const XKB_KEY_3270_CursorBlink: u32 = 64783;
pub const XKB_KEY_3270_AltCursor: u32 = 64784;
pub const XKB_KEY_3270_KeyClick: u32 = 64785;
pub const XKB_KEY_3270_Jump: u32 = 64786;
pub const XKB_KEY_3270_Ident: u32 = 64787;
pub const XKB_KEY_3270_Rule: u32 = 64788;
pub const XKB_KEY_3270_Copy: u32 = 64789;
pub const XKB_KEY_3270_Play: u32 = 64790;
pub const XKB_KEY_3270_Setup: u32 = 64791;
pub const XKB_KEY_3270_Record: u32 = 64792;
pub const XKB_KEY_3270_ChangeScreen: u32 = 64793;
pub const XKB_KEY_3270_DeleteWord: u32 = 64794;
pub const XKB_KEY_3270_ExSelect: u32 = 64795;
pub const XKB_KEY_3270_CursorSelect: u32 = 64796;
pub const XKB_KEY_3270_PrintScreen: u32 = 64797;
pub const XKB_KEY_3270_Enter: u32 = 64798;
pub const XKB_KEY_space: u32 = 32;
pub const XKB_KEY_exclam: u32 = 33;
pub const XKB_KEY_quotedbl: u32 = 34;
pub const XKB_KEY_numbersign: u32 = 35;
pub const XKB_KEY_dollar: u32 = 36;
pub const XKB_KEY_percent: u32 = 37;
pub const XKB_KEY_ampersand: u32 = 38;
pub const XKB_KEY_apostrophe: u32 = 39;
pub const XKB_KEY_quoteright: u32 = 39;
pub const XKB_KEY_parenleft: u32 = 40;
pub const XKB_KEY_parenright: u32 = 41;
pub const XKB_KEY_asterisk: u32 = 42;
pub const XKB_KEY_plus: u32 = 43;
pub const XKB_KEY_comma: u32 = 44;
pub const XKB_KEY_minus: u32 = 45;
pub const XKB_KEY_period: u32 = 46;
pub const XKB_KEY_slash: u32 = 47;
pub const XKB_KEY_0: u32 = 48;
pub const XKB_KEY_1: u32 = 49;
pub const XKB_KEY_2: u32 = 50;
pub const XKB_KEY_3: u32 = 51;
pub const XKB_KEY_4: u32 = 52;
pub const XKB_KEY_5: u32 = 53;
pub const XKB_KEY_6: u32 = 54;
pub const XKB_KEY_7: u32 = 55;
pub const XKB_KEY_8: u32 = 56;
pub const XKB_KEY_9: u32 = 57;
pub const XKB_KEY_colon: u32 = 58;
pub const XKB_KEY_semicolon: u32 = 59;
pub const XKB_KEY_less: u32 = 60;
pub const XKB_KEY_equal: u32 = 61;
pub const XKB_KEY_greater: u32 = 62;
pub const XKB_KEY_question: u32 = 63;
pub const XKB_KEY_at: u32 = 64;
pub const XKB_KEY_A: u32 = 65;
pub const XKB_KEY_B: u32 = 66;
pub const XKB_KEY_C: u32 = 67;
pub const XKB_KEY_D: u32 = 68;
pub const XKB_KEY_E: u32 = 69;
pub const XKB_KEY_F: u32 = 70;
pub const XKB_KEY_G: u32 = 71;
pub const XKB_KEY_H: u32 = 72;
pub const XKB_KEY_I: u32 = 73;
pub const XKB_KEY_J: u32 = 74;
pub const XKB_KEY_K: u32 = 75;
pub const XKB_KEY_L: u32 = 76;
pub const XKB_KEY_M: u32 = 77;
pub const XKB_KEY_N: u32 = 78;
pub const XKB_KEY_O: u32 = 79;
pub const XKB_KEY_P: u32 = 80;
pub const XKB_KEY_Q: u32 = 81;
pub const XKB_KEY_R: u32 = 82;
pub const XKB_KEY_S: u32 = 83;
pub const XKB_KEY_T: u32 = 84;
pub const XKB_KEY_U: u32 = 85;
pub const XKB_KEY_V: u32 = 86;
pub const XKB_KEY_W: u32 = 87;
pub const XKB_KEY_X: u32 = 88;
pub const XKB_KEY_Y: u32 = 89;
pub const XKB_KEY_Z: u32 = 90;
pub const XKB_KEY_bracketleft: u32 = 91;
pub const XKB_KEY_backslash: u32 = 92;
pub const XKB_KEY_bracketright: u32 = 93;
pub const XKB_KEY_asciicircum: u32 = 94;
pub const XKB_KEY_underscore: u32 = 95;
pub const XKB_KEY_grave: u32 = 96;
pub const XKB_KEY_quoteleft: u32 = 96;
pub const XKB_KEY_a: u32 = 97;
pub const XKB_KEY_b: u32 = 98;
pub const XKB_KEY_c: u32 = 99;
pub const XKB_KEY_d: u32 = 100;
pub const XKB_KEY_e: u32 = 101;
pub const XKB_KEY_f: u32 = 102;
pub const XKB_KEY_g: u32 = 103;
pub const XKB_KEY_h: u32 = 104;
pub const XKB_KEY_i: u32 = 105;
pub const XKB_KEY_j: u32 = 106;
pub const XKB_KEY_k: u32 = 107;
pub const XKB_KEY_l: u32 = 108;
pub const XKB_KEY_m: u32 = 109;
pub const XKB_KEY_n: u32 = 110;
pub const XKB_KEY_o: u32 = 111;
pub const XKB_KEY_p: u32 = 112;
pub const XKB_KEY_q: u32 = 113;
pub const XKB_KEY_r: u32 = 114;
pub const XKB_KEY_s: u32 = 115;
pub const XKB_KEY_t: u32 = 116;
pub const XKB_KEY_u: u32 = 117;
pub const XKB_KEY_v: u32 = 118;
pub const XKB_KEY_w: u32 = 119;
pub const XKB_KEY_x: u32 = 120;
pub const XKB_KEY_y: u32 = 121;
pub const XKB_KEY_z: u32 = 122;
pub const XKB_KEY_braceleft: u32 = 123;
pub const XKB_KEY_bar: u32 = 124;
pub const XKB_KEY_braceright: u32 = 125;
pub const XKB_KEY_asciitilde: u32 = 126;
pub const XKB_KEY_nobreakspace: u32 = 160;
pub const XKB_KEY_exclamdown: u32 = 161;
pub const XKB_KEY_cent: u32 = 162;
pub const XKB_KEY_sterling: u32 = 163;
pub const XKB_KEY_currency: u32 = 164;
pub const XKB_KEY_yen: u32 = 165;
pub const XKB_KEY_brokenbar: u32 = 166;
pub const XKB_KEY_section: u32 = 167;
pub const XKB_KEY_diaeresis: u32 = 168;
pub const XKB_KEY_copyright: u32 = 169;
pub const XKB_KEY_ordfeminine: u32 = 170;
pub const XKB_KEY_guillemotleft: u32 = 171;
pub const XKB_KEY_notsign: u32 = 172;
pub const XKB_KEY_hyphen: u32 = 173;
pub const XKB_KEY_registered: u32 = 174;
pub const XKB_KEY_macron: u32 = 175;
pub const XKB_KEY_degree: u32 = 176;
pub const XKB_KEY_plusminus: u32 = 177;
pub const XKB_KEY_twosuperior: u32 = 178;
pub const XKB_KEY_threesuperior: u32 = 179;
pub const XKB_KEY_acute: u32 = 180;
pub const XKB_KEY_mu: u32 = 181;
pub const XKB_KEY_paragraph: u32 = 182;
pub const XKB_KEY_periodcentered: u32 = 183;
pub const XKB_KEY_cedilla: u32 = 184;
pub const XKB_KEY_onesuperior: u32 = 185;
pub const XKB_KEY_masculine: u32 = 186;
pub const XKB_KEY_guillemotright: u32 = 187;
pub const XKB_KEY_onequarter: u32 = 188;
pub const XKB_KEY_onehalf: u32 = 189;
pub const XKB_KEY_threequarters: u32 = 190;
pub const XKB_KEY_questiondown: u32 = 191;
pub const XKB_KEY_Agrave: u32 = 192;
pub const XKB_KEY_Aacute: u32 = 193;
pub const XKB_KEY_Acircumflex: u32 = 194;
pub const XKB_KEY_Atilde: u32 = 195;
pub const XKB_KEY_Adiaeresis: u32 = 196;
pub const XKB_KEY_Aring: u32 = 197;
pub const XKB_KEY_AE: u32 = 198;
pub const XKB_KEY_Ccedilla: u32 = 199;
pub const XKB_KEY_Egrave: u32 = 200;
pub const XKB_KEY_Eacute: u32 = 201;
pub const XKB_KEY_Ecircumflex: u32 = 202;
pub const XKB_KEY_Ediaeresis: u32 = 203;
pub const XKB_KEY_Igrave: u32 = 204;
pub const XKB_KEY_Iacute: u32 = 205;
pub const XKB_KEY_Icircumflex: u32 = 206;
pub const XKB_KEY_Idiaeresis: u32 = 207;
pub const XKB_KEY_ETH: u32 = 208;
pub const XKB_KEY_Eth: u32 = 208;
pub const XKB_KEY_Ntilde: u32 = 209;
pub const XKB_KEY_Ograve: u32 = 210;
pub const XKB_KEY_Oacute: u32 = 211;
pub const XKB_KEY_Ocircumflex: u32 = 212;
pub const XKB_KEY_Otilde: u32 = 213;
pub const XKB_KEY_Odiaeresis: u32 = 214;
pub const XKB_KEY_multiply: u32 = 215;
pub const XKB_KEY_Oslash: u32 = 216;
pub const XKB_KEY_Ooblique: u32 = 216;
pub const XKB_KEY_Ugrave: u32 = 217;
pub const XKB_KEY_Uacute: u32 = 218;
pub const XKB_KEY_Ucircumflex: u32 = 219;
pub const XKB_KEY_Udiaeresis: u32 = 220;
pub const XKB_KEY_Yacute: u32 = 221;
pub const XKB_KEY_THORN: u32 = 222;
pub const XKB_KEY_Thorn: u32 = 222;
pub const XKB_KEY_ssharp: u32 = 223;
pub const XKB_KEY_agrave: u32 = 224;
pub const XKB_KEY_aacute: u32 = 225;
pub const XKB_KEY_acircumflex: u32 = 226;
pub const XKB_KEY_atilde: u32 = 227;
pub const XKB_KEY_adiaeresis: u32 = 228;
pub const XKB_KEY_aring: u32 = 229;
pub const XKB_KEY_ae: u32 = 230;
pub const XKB_KEY_ccedilla: u32 = 231;
pub const XKB_KEY_egrave: u32 = 232;
pub const XKB_KEY_eacute: u32 = 233;
pub const XKB_KEY_ecircumflex: u32 = 234;
pub const XKB_KEY_ediaeresis: u32 = 235;
pub const XKB_KEY_igrave: u32 = 236;
pub const XKB_KEY_iacute: u32 = 237;
pub const XKB_KEY_icircumflex: u32 = 238;
pub const XKB_KEY_idiaeresis: u32 = 239;
pub const XKB_KEY_eth: u32 = 240;
pub const XKB_KEY_ntilde: u32 = 241;
pub const XKB_KEY_ograve: u32 = 242;
pub const XKB_KEY_oacute: u32 = 243;
pub const XKB_KEY_ocircumflex: u32 = 244;
pub const XKB_KEY_otilde: u32 = 245;
pub const XKB_KEY_odiaeresis: u32 = 246;
pub const XKB_KEY_division: u32 = 247;
pub const XKB_KEY_oslash: u32 = 248;
pub const XKB_KEY_ooblique: u32 = 248;
pub const XKB_KEY_ugrave: u32 = 249;
pub const XKB_KEY_uacute: u32 = 250;
pub const XKB_KEY_ucircumflex: u32 = 251;
pub const XKB_KEY_udiaeresis: u32 = 252;
pub const XKB_KEY_yacute: u32 = 253;
pub const XKB_KEY_thorn: u32 = 254;
pub const XKB_KEY_ydiaeresis: u32 = 255;
pub const XKB_KEY_Aogonek: u32 = 417;
pub const XKB_KEY_breve: u32 = 418;
pub const XKB_KEY_Lstroke: u32 = 419;
pub const XKB_KEY_Lcaron: u32 = 421;
pub const XKB_KEY_Sacute: u32 = 422;
pub const XKB_KEY_Scaron: u32 = 425;
pub const XKB_KEY_Scedilla: u32 = 426;
pub const XKB_KEY_Tcaron: u32 = 427;
pub const XKB_KEY_Zacute: u32 = 428;
pub const XKB_KEY_Zcaron: u32 = 430;
pub const XKB_KEY_Zabovedot: u32 = 431;
pub const XKB_KEY_aogonek: u32 = 433;
pub const XKB_KEY_ogonek: u32 = 434;
pub const XKB_KEY_lstroke: u32 = 435;
pub const XKB_KEY_lcaron: u32 = 437;
pub const XKB_KEY_sacute: u32 = 438;
pub const XKB_KEY_caron: u32 = 439;
pub const XKB_KEY_scaron: u32 = 441;
pub const XKB_KEY_scedilla: u32 = 442;
pub const XKB_KEY_tcaron: u32 = 443;
pub const XKB_KEY_zacute: u32 = 444;
pub const XKB_KEY_doubleacute: u32 = 445;
pub const XKB_KEY_zcaron: u32 = 446;
pub const XKB_KEY_zabovedot: u32 = 447;
pub const XKB_KEY_Racute: u32 = 448;
pub const XKB_KEY_Abreve: u32 = 451;
pub const XKB_KEY_Lacute: u32 = 453;
pub const XKB_KEY_Cacute: u32 = 454;
pub const XKB_KEY_Ccaron: u32 = 456;
pub const XKB_KEY_Eogonek: u32 = 458;
pub const XKB_KEY_Ecaron: u32 = 460;
pub const XKB_KEY_Dcaron: u32 = 463;
pub const XKB_KEY_Dstroke: u32 = 464;
pub const XKB_KEY_Nacute: u32 = 465;
pub const XKB_KEY_Ncaron: u32 = 466;
pub const XKB_KEY_Odoubleacute: u32 = 469;
pub const XKB_KEY_Rcaron: u32 = 472;
pub const XKB_KEY_Uring: u32 = 473;
pub const XKB_KEY_Udoubleacute: u32 = 475;
pub const XKB_KEY_Tcedilla: u32 = 478;
pub const XKB_KEY_racute: u32 = 480;
pub const XKB_KEY_abreve: u32 = 483;
pub const XKB_KEY_lacute: u32 = 485;
pub const XKB_KEY_cacute: u32 = 486;
pub const XKB_KEY_ccaron: u32 = 488;
pub const XKB_KEY_eogonek: u32 = 490;
pub const XKB_KEY_ecaron: u32 = 492;
pub const XKB_KEY_dcaron: u32 = 495;
pub const XKB_KEY_dstroke: u32 = 496;
pub const XKB_KEY_nacute: u32 = 497;
pub const XKB_KEY_ncaron: u32 = 498;
pub const XKB_KEY_odoubleacute: u32 = 501;
pub const XKB_KEY_rcaron: u32 = 504;
pub const XKB_KEY_uring: u32 = 505;
pub const XKB_KEY_udoubleacute: u32 = 507;
pub const XKB_KEY_tcedilla: u32 = 510;
pub const XKB_KEY_abovedot: u32 = 511;
pub const XKB_KEY_Hstroke: u32 = 673;
pub const XKB_KEY_Hcircumflex: u32 = 678;
pub const XKB_KEY_Iabovedot: u32 = 681;
pub const XKB_KEY_Gbreve: u32 = 683;
pub const XKB_KEY_Jcircumflex: u32 = 684;
pub const XKB_KEY_hstroke: u32 = 689;
pub const XKB_KEY_hcircumflex: u32 = 694;
pub const XKB_KEY_idotless: u32 = 697;
pub const XKB_KEY_gbreve: u32 = 699;
pub const XKB_KEY_jcircumflex: u32 = 700;
pub const XKB_KEY_Cabovedot: u32 = 709;
pub const XKB_KEY_Ccircumflex: u32 = 710;
pub const XKB_KEY_Gabovedot: u32 = 725;
pub const XKB_KEY_Gcircumflex: u32 = 728;
pub const XKB_KEY_Ubreve: u32 = 733;
pub const XKB_KEY_Scircumflex: u32 = 734;
pub const XKB_KEY_cabovedot: u32 = 741;
pub const XKB_KEY_ccircumflex: u32 = 742;
pub const XKB_KEY_gabovedot: u32 = 757;
pub const XKB_KEY_gcircumflex: u32 = 760;
pub const XKB_KEY_ubreve: u32 = 765;
pub const XKB_KEY_scircumflex: u32 = 766;
pub const XKB_KEY_kra: u32 = 930;
pub const XKB_KEY_kappa: u32 = 930;
pub const XKB_KEY_Rcedilla: u32 = 931;
pub const XKB_KEY_Itilde: u32 = 933;
pub const XKB_KEY_Lcedilla: u32 = 934;
pub const XKB_KEY_Emacron: u32 = 938;
pub const XKB_KEY_Gcedilla: u32 = 939;
pub const XKB_KEY_Tslash: u32 = 940;
pub const XKB_KEY_rcedilla: u32 = 947;
pub const XKB_KEY_itilde: u32 = 949;
pub const XKB_KEY_lcedilla: u32 = 950;
pub const XKB_KEY_emacron: u32 = 954;
pub const XKB_KEY_gcedilla: u32 = 955;
pub const XKB_KEY_tslash: u32 = 956;
pub const XKB_KEY_ENG: u32 = 957;
pub const XKB_KEY_eng: u32 = 959;
pub const XKB_KEY_Amacron: u32 = 960;
pub const XKB_KEY_Iogonek: u32 = 967;
pub const XKB_KEY_Eabovedot: u32 = 972;
pub const XKB_KEY_Imacron: u32 = 975;
pub const XKB_KEY_Ncedilla: u32 = 977;
pub const XKB_KEY_Omacron: u32 = 978;
pub const XKB_KEY_Kcedilla: u32 = 979;
pub const XKB_KEY_Uogonek: u32 = 985;
pub const XKB_KEY_Utilde: u32 = 989;
pub const XKB_KEY_Umacron: u32 = 990;
pub const XKB_KEY_amacron: u32 = 992;
pub const XKB_KEY_iogonek: u32 = 999;
pub const XKB_KEY_eabovedot: u32 = 1004;
pub const XKB_KEY_imacron: u32 = 1007;
pub const XKB_KEY_ncedilla: u32 = 1009;
pub const XKB_KEY_omacron: u32 = 1010;
pub const XKB_KEY_kcedilla: u32 = 1011;
pub const XKB_KEY_uogonek: u32 = 1017;
pub const XKB_KEY_utilde: u32 = 1021;
pub const XKB_KEY_umacron: u32 = 1022;
pub const XKB_KEY_Wcircumflex: u32 = 16777588;
pub const XKB_KEY_wcircumflex: u32 = 16777589;
pub const XKB_KEY_Ycircumflex: u32 = 16777590;
pub const XKB_KEY_ycircumflex: u32 = 16777591;
pub const XKB_KEY_Babovedot: u32 = 16784898;
pub const XKB_KEY_babovedot: u32 = 16784899;
pub const XKB_KEY_Dabovedot: u32 = 16784906;
pub const XKB_KEY_dabovedot: u32 = 16784907;
pub const XKB_KEY_Fabovedot: u32 = 16784926;
pub const XKB_KEY_fabovedot: u32 = 16784927;
pub const XKB_KEY_Mabovedot: u32 = 16784960;
pub const XKB_KEY_mabovedot: u32 = 16784961;
pub const XKB_KEY_Pabovedot: u32 = 16784982;
pub const XKB_KEY_pabovedot: u32 = 16784983;
pub const XKB_KEY_Sabovedot: u32 = 16784992;
pub const XKB_KEY_sabovedot: u32 = 16784993;
pub const XKB_KEY_Tabovedot: u32 = 16785002;
pub const XKB_KEY_tabovedot: u32 = 16785003;
pub const XKB_KEY_Wgrave: u32 = 16785024;
pub const XKB_KEY_wgrave: u32 = 16785025;
pub const XKB_KEY_Wacute: u32 = 16785026;
pub const XKB_KEY_wacute: u32 = 16785027;
pub const XKB_KEY_Wdiaeresis: u32 = 16785028;
pub const XKB_KEY_wdiaeresis: u32 = 16785029;
pub const XKB_KEY_Ygrave: u32 = 16785138;
pub const XKB_KEY_ygrave: u32 = 16785139;
pub const XKB_KEY_OE: u32 = 5052;
pub const XKB_KEY_oe: u32 = 5053;
pub const XKB_KEY_Ydiaeresis: u32 = 5054;
pub const XKB_KEY_overline: u32 = 1150;
pub const XKB_KEY_kana_fullstop: u32 = 1185;
pub const XKB_KEY_kana_openingbracket: u32 = 1186;
pub const XKB_KEY_kana_closingbracket: u32 = 1187;
pub const XKB_KEY_kana_comma: u32 = 1188;
pub const XKB_KEY_kana_conjunctive: u32 = 1189;
pub const XKB_KEY_kana_middledot: u32 = 1189;
pub const XKB_KEY_kana_WO: u32 = 1190;
pub const XKB_KEY_kana_a: u32 = 1191;
pub const XKB_KEY_kana_i: u32 = 1192;
pub const XKB_KEY_kana_u: u32 = 1193;
pub const XKB_KEY_kana_e: u32 = 1194;
pub const XKB_KEY_kana_o: u32 = 1195;
pub const XKB_KEY_kana_ya: u32 = 1196;
pub const XKB_KEY_kana_yu: u32 = 1197;
pub const XKB_KEY_kana_yo: u32 = 1198;
pub const XKB_KEY_kana_tsu: u32 = 1199;
pub const XKB_KEY_kana_tu: u32 = 1199;
pub const XKB_KEY_prolongedsound: u32 = 1200;
pub const XKB_KEY_kana_A: u32 = 1201;
pub const XKB_KEY_kana_I: u32 = 1202;
pub const XKB_KEY_kana_U: u32 = 1203;
pub const XKB_KEY_kana_E: u32 = 1204;
pub const XKB_KEY_kana_O: u32 = 1205;
pub const XKB_KEY_kana_KA: u32 = 1206;
pub const XKB_KEY_kana_KI: u32 = 1207;
pub const XKB_KEY_kana_KU: u32 = 1208;
pub const XKB_KEY_kana_KE: u32 = 1209;
pub const XKB_KEY_kana_KO: u32 = 1210;
pub const XKB_KEY_kana_SA: u32 = 1211;
pub const XKB_KEY_kana_SHI: u32 = 1212;
pub const XKB_KEY_kana_SU: u32 = 1213;
pub const XKB_KEY_kana_SE: u32 = 1214;
pub const XKB_KEY_kana_SO: u32 = 1215;
pub const XKB_KEY_kana_TA: u32 = 1216;
pub const XKB_KEY_kana_CHI: u32 = 1217;
pub const XKB_KEY_kana_TI: u32 = 1217;
pub const XKB_KEY_kana_TSU: u32 = 1218;
pub const XKB_KEY_kana_TU: u32 = 1218;
pub const XKB_KEY_kana_TE: u32 = 1219;
pub const XKB_KEY_kana_TO: u32 = 1220;
pub const XKB_KEY_kana_NA: u32 = 1221;
pub const XKB_KEY_kana_NI: u32 = 1222;
pub const XKB_KEY_kana_NU: u32 = 1223;
pub const XKB_KEY_kana_NE: u32 = 1224;
pub const XKB_KEY_kana_NO: u32 = 1225;
pub const XKB_KEY_kana_HA: u32 = 1226;
pub const XKB_KEY_kana_HI: u32 = 1227;
pub const XKB_KEY_kana_FU: u32 = 1228;
pub const XKB_KEY_kana_HU: u32 = 1228;
pub const XKB_KEY_kana_HE: u32 = 1229;
pub const XKB_KEY_kana_HO: u32 = 1230;
pub const XKB_KEY_kana_MA: u32 = 1231;
pub const XKB_KEY_kana_MI: u32 = 1232;
pub const XKB_KEY_kana_MU: u32 = 1233;
pub const XKB_KEY_kana_ME: u32 = 1234;
pub const XKB_KEY_kana_MO: u32 = 1235;
pub const XKB_KEY_kana_YA: u32 = 1236;
pub const XKB_KEY_kana_YU: u32 = 1237;
pub const XKB_KEY_kana_YO: u32 = 1238;
pub const XKB_KEY_kana_RA: u32 = 1239;
pub const XKB_KEY_kana_RI: u32 = 1240;
pub const XKB_KEY_kana_RU: u32 = 1241;
pub const XKB_KEY_kana_RE: u32 = 1242;
pub const XKB_KEY_kana_RO: u32 = 1243;
pub const XKB_KEY_kana_WA: u32 = 1244;
pub const XKB_KEY_kana_N: u32 = 1245;
pub const XKB_KEY_voicedsound: u32 = 1246;
pub const XKB_KEY_semivoicedsound: u32 = 1247;
pub const XKB_KEY_kana_switch: u32 = 65406;
pub const XKB_KEY_Farsi_0: u32 = 16778992;
pub const XKB_KEY_Farsi_1: u32 = 16778993;
pub const XKB_KEY_Farsi_2: u32 = 16778994;
pub const XKB_KEY_Farsi_3: u32 = 16778995;
pub const XKB_KEY_Farsi_4: u32 = 16778996;
pub const XKB_KEY_Farsi_5: u32 = 16778997;
pub const XKB_KEY_Farsi_6: u32 = 16778998;
pub const XKB_KEY_Farsi_7: u32 = 16778999;
pub const XKB_KEY_Farsi_8: u32 = 16779000;
pub const XKB_KEY_Farsi_9: u32 = 16779001;
pub const XKB_KEY_Arabic_percent: u32 = 16778858;
pub const XKB_KEY_Arabic_superscript_alef: u32 = 16778864;
pub const XKB_KEY_Arabic_tteh: u32 = 16778873;
pub const XKB_KEY_Arabic_peh: u32 = 16778878;
pub const XKB_KEY_Arabic_tcheh: u32 = 16778886;
pub const XKB_KEY_Arabic_ddal: u32 = 16778888;
pub const XKB_KEY_Arabic_rreh: u32 = 16778897;
pub const XKB_KEY_Arabic_comma: u32 = 1452;
pub const XKB_KEY_Arabic_fullstop: u32 = 16778964;
pub const XKB_KEY_Arabic_0: u32 = 16778848;
pub const XKB_KEY_Arabic_1: u32 = 16778849;
pub const XKB_KEY_Arabic_2: u32 = 16778850;
pub const XKB_KEY_Arabic_3: u32 = 16778851;
pub const XKB_KEY_Arabic_4: u32 = 16778852;
pub const XKB_KEY_Arabic_5: u32 = 16778853;
pub const XKB_KEY_Arabic_6: u32 = 16778854;
pub const XKB_KEY_Arabic_7: u32 = 16778855;
pub const XKB_KEY_Arabic_8: u32 = 16778856;
pub const XKB_KEY_Arabic_9: u32 = 16778857;
pub const XKB_KEY_Arabic_semicolon: u32 = 1467;
pub const XKB_KEY_Arabic_question_mark: u32 = 1471;
pub const XKB_KEY_Arabic_hamza: u32 = 1473;
pub const XKB_KEY_Arabic_maddaonalef: u32 = 1474;
pub const XKB_KEY_Arabic_hamzaonalef: u32 = 1475;
pub const XKB_KEY_Arabic_hamzaonwaw: u32 = 1476;
pub const XKB_KEY_Arabic_hamzaunderalef: u32 = 1477;
pub const XKB_KEY_Arabic_hamzaonyeh: u32 = 1478;
pub const XKB_KEY_Arabic_alef: u32 = 1479;
pub const XKB_KEY_Arabic_beh: u32 = 1480;
pub const XKB_KEY_Arabic_tehmarbuta: u32 = 1481;
pub const XKB_KEY_Arabic_teh: u32 = 1482;
pub const XKB_KEY_Arabic_theh: u32 = 1483;
pub const XKB_KEY_Arabic_jeem: u32 = 1484;
pub const XKB_KEY_Arabic_hah: u32 = 1485;
pub const XKB_KEY_Arabic_khah: u32 = 1486;
pub const XKB_KEY_Arabic_dal: u32 = 1487;
pub const XKB_KEY_Arabic_thal: u32 = 1488;
pub const XKB_KEY_Arabic_ra: u32 = 1489;
pub const XKB_KEY_Arabic_zain: u32 = 1490;
pub const XKB_KEY_Arabic_seen: u32 = 1491;
pub const XKB_KEY_Arabic_sheen: u32 = 1492;
pub const XKB_KEY_Arabic_sad: u32 = 1493;
pub const XKB_KEY_Arabic_dad: u32 = 1494;
pub const XKB_KEY_Arabic_tah: u32 = 1495;
pub const XKB_KEY_Arabic_zah: u32 = 1496;
pub const XKB_KEY_Arabic_ain: u32 = 1497;
pub const XKB_KEY_Arabic_ghain: u32 = 1498;
pub const XKB_KEY_Arabic_tatweel: u32 = 1504;
pub const XKB_KEY_Arabic_feh: u32 = 1505;
pub const XKB_KEY_Arabic_qaf: u32 = 1506;
pub const XKB_KEY_Arabic_kaf: u32 = 1507;
pub const XKB_KEY_Arabic_lam: u32 = 1508;
pub const XKB_KEY_Arabic_meem: u32 = 1509;
pub const XKB_KEY_Arabic_noon: u32 = 1510;
pub const XKB_KEY_Arabic_ha: u32 = 1511;
pub const XKB_KEY_Arabic_heh: u32 = 1511;
pub const XKB_KEY_Arabic_waw: u32 = 1512;
pub const XKB_KEY_Arabic_alefmaksura: u32 = 1513;
pub const XKB_KEY_Arabic_yeh: u32 = 1514;
pub const XKB_KEY_Arabic_fathatan: u32 = 1515;
pub const XKB_KEY_Arabic_dammatan: u32 = 1516;
pub const XKB_KEY_Arabic_kasratan: u32 = 1517;
pub const XKB_KEY_Arabic_fatha: u32 = 1518;
pub const XKB_KEY_Arabic_damma: u32 = 1519;
pub const XKB_KEY_Arabic_kasra: u32 = 1520;
pub const XKB_KEY_Arabic_shadda: u32 = 1521;
pub const XKB_KEY_Arabic_sukun: u32 = 1522;
pub const XKB_KEY_Arabic_madda_above: u32 = 16778835;
pub const XKB_KEY_Arabic_hamza_above: u32 = 16778836;
pub const XKB_KEY_Arabic_hamza_below: u32 = 16778837;
pub const XKB_KEY_Arabic_jeh: u32 = 16778904;
pub const XKB_KEY_Arabic_veh: u32 = 16778916;
pub const XKB_KEY_Arabic_keheh: u32 = 16778921;
pub const XKB_KEY_Arabic_gaf: u32 = 16778927;
pub const XKB_KEY_Arabic_noon_ghunna: u32 = 16778938;
pub const XKB_KEY_Arabic_heh_doachashmee: u32 = 16778942;
pub const XKB_KEY_Farsi_yeh: u32 = 16778956;
pub const XKB_KEY_Arabic_farsi_yeh: u32 = 16778956;
pub const XKB_KEY_Arabic_yeh_baree: u32 = 16778962;
pub const XKB_KEY_Arabic_heh_goal: u32 = 16778945;
pub const XKB_KEY_Arabic_switch: u32 = 65406;
pub const XKB_KEY_Cyrillic_GHE_bar: u32 = 16778386;
pub const XKB_KEY_Cyrillic_ghe_bar: u32 = 16778387;
pub const XKB_KEY_Cyrillic_ZHE_descender: u32 = 16778390;
pub const XKB_KEY_Cyrillic_zhe_descender: u32 = 16778391;
pub const XKB_KEY_Cyrillic_KA_descender: u32 = 16778394;
pub const XKB_KEY_Cyrillic_ka_descender: u32 = 16778395;
pub const XKB_KEY_Cyrillic_KA_vertstroke: u32 = 16778396;
pub const XKB_KEY_Cyrillic_ka_vertstroke: u32 = 16778397;
pub const XKB_KEY_Cyrillic_EN_descender: u32 = 16778402;
pub const XKB_KEY_Cyrillic_en_descender: u32 = 16778403;
pub const XKB_KEY_Cyrillic_U_straight: u32 = 16778414;
pub const XKB_KEY_Cyrillic_u_straight: u32 = 16778415;
pub const XKB_KEY_Cyrillic_U_straight_bar: u32 = 16778416;
pub const XKB_KEY_Cyrillic_u_straight_bar: u32 = 16778417;
pub const XKB_KEY_Cyrillic_HA_descender: u32 = 16778418;
pub const XKB_KEY_Cyrillic_ha_descender: u32 = 16778419;
pub const XKB_KEY_Cyrillic_CHE_descender: u32 = 16778422;
pub const XKB_KEY_Cyrillic_che_descender: u32 = 16778423;
pub const XKB_KEY_Cyrillic_CHE_vertstroke: u32 = 16778424;
pub const XKB_KEY_Cyrillic_che_vertstroke: u32 = 16778425;
pub const XKB_KEY_Cyrillic_SHHA: u32 = 16778426;
pub const XKB_KEY_Cyrillic_shha: u32 = 16778427;
pub const XKB_KEY_Cyrillic_SCHWA: u32 = 16778456;
pub const XKB_KEY_Cyrillic_schwa: u32 = 16778457;
pub const XKB_KEY_Cyrillic_I_macron: u32 = 16778466;
pub const XKB_KEY_Cyrillic_i_macron: u32 = 16778467;
pub const XKB_KEY_Cyrillic_O_bar: u32 = 16778472;
pub const XKB_KEY_Cyrillic_o_bar: u32 = 16778473;
pub const XKB_KEY_Cyrillic_U_macron: u32 = 16778478;
pub const XKB_KEY_Cyrillic_u_macron: u32 = 16778479;
pub const XKB_KEY_Serbian_dje: u32 = 1697;
pub const XKB_KEY_Macedonia_gje: u32 = 1698;
pub const XKB_KEY_Cyrillic_io: u32 = 1699;
pub const XKB_KEY_Ukrainian_ie: u32 = 1700;
pub const XKB_KEY_Ukranian_je: u32 = 1700;
pub const XKB_KEY_Macedonia_dse: u32 = 1701;
pub const XKB_KEY_Ukrainian_i: u32 = 1702;
pub const XKB_KEY_Ukranian_i: u32 = 1702;
pub const XKB_KEY_Ukrainian_yi: u32 = 1703;
pub const XKB_KEY_Ukranian_yi: u32 = 1703;
pub const XKB_KEY_Cyrillic_je: u32 = 1704;
pub const XKB_KEY_Serbian_je: u32 = 1704;
pub const XKB_KEY_Cyrillic_lje: u32 = 1705;
pub const XKB_KEY_Serbian_lje: u32 = 1705;
pub const XKB_KEY_Cyrillic_nje: u32 = 1706;
pub const XKB_KEY_Serbian_nje: u32 = 1706;
pub const XKB_KEY_Serbian_tshe: u32 = 1707;
pub const XKB_KEY_Macedonia_kje: u32 = 1708;
pub const XKB_KEY_Ukrainian_ghe_with_upturn: u32 = 1709;
pub const XKB_KEY_Byelorussian_shortu: u32 = 1710;
pub const XKB_KEY_Cyrillic_dzhe: u32 = 1711;
pub const XKB_KEY_Serbian_dze: u32 = 1711;
pub const XKB_KEY_numerosign: u32 = 1712;
pub const XKB_KEY_Serbian_DJE: u32 = 1713;
pub const XKB_KEY_Macedonia_GJE: u32 = 1714;
pub const XKB_KEY_Cyrillic_IO: u32 = 1715;
pub const XKB_KEY_Ukrainian_IE: u32 = 1716;
pub const XKB_KEY_Ukranian_JE: u32 = 1716;
pub const XKB_KEY_Macedonia_DSE: u32 = 1717;
pub const XKB_KEY_Ukrainian_I: u32 = 1718;
pub const XKB_KEY_Ukranian_I: u32 = 1718;
pub const XKB_KEY_Ukrainian_YI: u32 = 1719;
pub const XKB_KEY_Ukranian_YI: u32 = 1719;
pub const XKB_KEY_Cyrillic_JE: u32 = 1720;
pub const XKB_KEY_Serbian_JE: u32 = 1720;
pub const XKB_KEY_Cyrillic_LJE: u32 = 1721;
pub const XKB_KEY_Serbian_LJE: u32 = 1721;
pub const XKB_KEY_Cyrillic_NJE: u32 = 1722;
pub const XKB_KEY_Serbian_NJE: u32 = 1722;
pub const XKB_KEY_Serbian_TSHE: u32 = 1723;
pub const XKB_KEY_Macedonia_KJE: u32 = 1724;
pub const XKB_KEY_Ukrainian_GHE_WITH_UPTURN: u32 = 1725;
pub const XKB_KEY_Byelorussian_SHORTU: u32 = 1726;
pub const XKB_KEY_Cyrillic_DZHE: u32 = 1727;
pub const XKB_KEY_Serbian_DZE: u32 = 1727;
pub const XKB_KEY_Cyrillic_yu: u32 = 1728;
pub const XKB_KEY_Cyrillic_a: u32 = 1729;
pub const XKB_KEY_Cyrillic_be: u32 = 1730;
pub const XKB_KEY_Cyrillic_tse: u32 = 1731;
pub const XKB_KEY_Cyrillic_de: u32 = 1732;
pub const XKB_KEY_Cyrillic_ie: u32 = 1733;
pub const XKB_KEY_Cyrillic_ef: u32 = 1734;
pub const XKB_KEY_Cyrillic_ghe: u32 = 1735;
pub const XKB_KEY_Cyrillic_ha: u32 = 1736;
pub const XKB_KEY_Cyrillic_i: u32 = 1737;
pub const XKB_KEY_Cyrillic_shorti: u32 = 1738;
pub const XKB_KEY_Cyrillic_ka: u32 = 1739;
pub const XKB_KEY_Cyrillic_el: u32 = 1740;
pub const XKB_KEY_Cyrillic_em: u32 = 1741;
pub const XKB_KEY_Cyrillic_en: u32 = 1742;
pub const XKB_KEY_Cyrillic_o: u32 = 1743;
pub const XKB_KEY_Cyrillic_pe: u32 = 1744;
pub const XKB_KEY_Cyrillic_ya: u32 = 1745;
pub const XKB_KEY_Cyrillic_er: u32 = 1746;
pub const XKB_KEY_Cyrillic_es: u32 = 1747;
pub const XKB_KEY_Cyrillic_te: u32 = 1748;
pub const XKB_KEY_Cyrillic_u: u32 = 1749;
pub const XKB_KEY_Cyrillic_zhe: u32 = 1750;
pub const XKB_KEY_Cyrillic_ve: u32 = 1751;
pub const XKB_KEY_Cyrillic_softsign: u32 = 1752;
pub const XKB_KEY_Cyrillic_yeru: u32 = 1753;
pub const XKB_KEY_Cyrillic_ze: u32 = 1754;
pub const XKB_KEY_Cyrillic_sha: u32 = 1755;
pub const XKB_KEY_Cyrillic_e: u32 = 1756;
pub const XKB_KEY_Cyrillic_shcha: u32 = 1757;
pub const XKB_KEY_Cyrillic_che: u32 = 1758;
pub const XKB_KEY_Cyrillic_hardsign: u32 = 1759;
pub const XKB_KEY_Cyrillic_YU: u32 = 1760;
pub const XKB_KEY_Cyrillic_A: u32 = 1761;
pub const XKB_KEY_Cyrillic_BE: u32 = 1762;
pub const XKB_KEY_Cyrillic_TSE: u32 = 1763;
pub const XKB_KEY_Cyrillic_DE: u32 = 1764;
pub const XKB_KEY_Cyrillic_IE: u32 = 1765;
pub const XKB_KEY_Cyrillic_EF: u32 = 1766;
pub const XKB_KEY_Cyrillic_GHE: u32 = 1767;
pub const XKB_KEY_Cyrillic_HA: u32 = 1768;
pub const XKB_KEY_Cyrillic_I: u32 = 1769;
pub const XKB_KEY_Cyrillic_SHORTI: u32 = 1770;
pub const XKB_KEY_Cyrillic_KA: u32 = 1771;
pub const XKB_KEY_Cyrillic_EL: u32 = 1772;
pub const XKB_KEY_Cyrillic_EM: u32 = 1773;
pub const XKB_KEY_Cyrillic_EN: u32 = 1774;
pub const XKB_KEY_Cyrillic_O: u32 = 1775;
pub const XKB_KEY_Cyrillic_PE: u32 = 1776;
pub const XKB_KEY_Cyrillic_YA: u32 = 1777;
pub const XKB_KEY_Cyrillic_ER: u32 = 1778;
pub const XKB_KEY_Cyrillic_ES: u32 = 1779;
pub const XKB_KEY_Cyrillic_TE: u32 = 1780;
pub const XKB_KEY_Cyrillic_U: u32 = 1781;
pub const XKB_KEY_Cyrillic_ZHE: u32 = 1782;
pub const XKB_KEY_Cyrillic_VE: u32 = 1783;
pub const XKB_KEY_Cyrillic_SOFTSIGN: u32 = 1784;
pub const XKB_KEY_Cyrillic_YERU: u32 = 1785;
pub const XKB_KEY_Cyrillic_ZE: u32 = 1786;
pub const XKB_KEY_Cyrillic_SHA: u32 = 1787;
pub const XKB_KEY_Cyrillic_E: u32 = 1788;
pub const XKB_KEY_Cyrillic_SHCHA: u32 = 1789;
pub const XKB_KEY_Cyrillic_CHE: u32 = 1790;
pub const XKB_KEY_Cyrillic_HARDSIGN: u32 = 1791;
pub const XKB_KEY_Greek_ALPHAaccent: u32 = 1953;
pub const XKB_KEY_Greek_EPSILONaccent: u32 = 1954;
pub const XKB_KEY_Greek_ETAaccent: u32 = 1955;
pub const XKB_KEY_Greek_IOTAaccent: u32 = 1956;
pub const XKB_KEY_Greek_IOTAdieresis: u32 = 1957;
pub const XKB_KEY_Greek_IOTAdiaeresis: u32 = 1957;
pub const XKB_KEY_Greek_OMICRONaccent: u32 = 1959;
pub const XKB_KEY_Greek_UPSILONaccent: u32 = 1960;
pub const XKB_KEY_Greek_UPSILONdieresis: u32 = 1961;
pub const XKB_KEY_Greek_OMEGAaccent: u32 = 1963;
pub const XKB_KEY_Greek_accentdieresis: u32 = 1966;
pub const XKB_KEY_Greek_horizbar: u32 = 1967;
pub const XKB_KEY_Greek_alphaaccent: u32 = 1969;
pub const XKB_KEY_Greek_epsilonaccent: u32 = 1970;
pub const XKB_KEY_Greek_etaaccent: u32 = 1971;
pub const XKB_KEY_Greek_iotaaccent: u32 = 1972;
pub const XKB_KEY_Greek_iotadieresis: u32 = 1973;
pub const XKB_KEY_Greek_iotaaccentdieresis: u32 = 1974;
pub const XKB_KEY_Greek_omicronaccent: u32 = 1975;
pub const XKB_KEY_Greek_upsilonaccent: u32 = 1976;
pub const XKB_KEY_Greek_upsilondieresis: u32 = 1977;
pub const XKB_KEY_Greek_upsilonaccentdieresis: u32 = 1978;
pub const XKB_KEY_Greek_omegaaccent: u32 = 1979;
pub const XKB_KEY_Greek_ALPHA: u32 = 1985;
pub const XKB_KEY_Greek_BETA: u32 = 1986;
pub const XKB_KEY_Greek_GAMMA: u32 = 1987;
pub const XKB_KEY_Greek_DELTA: u32 = 1988;
pub const XKB_KEY_Greek_EPSILON: u32 = 1989;
pub const XKB_KEY_Greek_ZETA: u32 = 1990;
pub const XKB_KEY_Greek_ETA: u32 = 1991;
pub const XKB_KEY_Greek_THETA: u32 = 1992;
pub const XKB_KEY_Greek_IOTA: u32 = 1993;
pub const XKB_KEY_Greek_KAPPA: u32 = 1994;
pub const XKB_KEY_Greek_LAMDA: u32 = 1995;
pub const XKB_KEY_Greek_LAMBDA: u32 = 1995;
pub const XKB_KEY_Greek_MU: u32 = 1996;
pub const XKB_KEY_Greek_NU: u32 = 1997;
pub const XKB_KEY_Greek_XI: u32 = 1998;
pub const XKB_KEY_Greek_OMICRON: u32 = 1999;
pub const XKB_KEY_Greek_PI: u32 = 2000;
pub const XKB_KEY_Greek_RHO: u32 = 2001;
pub const XKB_KEY_Greek_SIGMA: u32 = 2002;
pub const XKB_KEY_Greek_TAU: u32 = 2004;
pub const XKB_KEY_Greek_UPSILON: u32 = 2005;
pub const XKB_KEY_Greek_PHI: u32 = 2006;
pub const XKB_KEY_Greek_CHI: u32 = 2007;
pub const XKB_KEY_Greek_PSI: u32 = 2008;
pub const XKB_KEY_Greek_OMEGA: u32 = 2009;
pub const XKB_KEY_Greek_alpha: u32 = 2017;
pub const XKB_KEY_Greek_beta: u32 = 2018;
pub const XKB_KEY_Greek_gamma: u32 = 2019;
pub const XKB_KEY_Greek_delta: u32 = 2020;
pub const XKB_KEY_Greek_epsilon: u32 = 2021;
pub const XKB_KEY_Greek_zeta: u32 = 2022;
pub const XKB_KEY_Greek_eta: u32 = 2023;
pub const XKB_KEY_Greek_theta: u32 = 2024;
pub const XKB_KEY_Greek_iota: u32 = 2025;
pub const XKB_KEY_Greek_kappa: u32 = 2026;
pub const XKB_KEY_Greek_lamda: u32 = 2027;
pub const XKB_KEY_Greek_lambda: u32 = 2027;
pub const XKB_KEY_Greek_mu: u32 = 2028;
pub const XKB_KEY_Greek_nu: u32 = 2029;
pub const XKB_KEY_Greek_xi: u32 = 2030;
pub const XKB_KEY_Greek_omicron: u32 = 2031;
pub const XKB_KEY_Greek_pi: u32 = 2032;
pub const XKB_KEY_Greek_rho: u32 = 2033;
pub const XKB_KEY_Greek_sigma: u32 = 2034;
pub const XKB_KEY_Greek_finalsmallsigma: u32 = 2035;
pub const XKB_KEY_Greek_tau: u32 = 2036;
pub const XKB_KEY_Greek_upsilon: u32 = 2037;
pub const XKB_KEY_Greek_phi: u32 = 2038;
pub const XKB_KEY_Greek_chi: u32 = 2039;
pub const XKB_KEY_Greek_psi: u32 = 2040;
pub const XKB_KEY_Greek_omega: u32 = 2041;
pub const XKB_KEY_Greek_switch: u32 = 65406;
pub const XKB_KEY_leftradical: u32 = 2209;
pub const XKB_KEY_topleftradical: u32 = 2210;
pub const XKB_KEY_horizconnector: u32 = 2211;
pub const XKB_KEY_topintegral: u32 = 2212;
pub const XKB_KEY_botintegral: u32 = 2213;
pub const XKB_KEY_vertconnector: u32 = 2214;
pub const XKB_KEY_topleftsqbracket: u32 = 2215;
pub const XKB_KEY_botleftsqbracket: u32 = 2216;
pub const XKB_KEY_toprightsqbracket: u32 = 2217;
pub const XKB_KEY_botrightsqbracket: u32 = 2218;
pub const XKB_KEY_topleftparens: u32 = 2219;
pub const XKB_KEY_botleftparens: u32 = 2220;
pub const XKB_KEY_toprightparens: u32 = 2221;
pub const XKB_KEY_botrightparens: u32 = 2222;
pub const XKB_KEY_leftmiddlecurlybrace: u32 = 2223;
pub const XKB_KEY_rightmiddlecurlybrace: u32 = 2224;
pub const XKB_KEY_topleftsummation: u32 = 2225;
pub const XKB_KEY_botleftsummation: u32 = 2226;
pub const XKB_KEY_topvertsummationconnector: u32 = 2227;
pub const XKB_KEY_botvertsummationconnector: u32 = 2228;
pub const XKB_KEY_toprightsummation: u32 = 2229;
pub const XKB_KEY_botrightsummation: u32 = 2230;
pub const XKB_KEY_rightmiddlesummation: u32 = 2231;
pub const XKB_KEY_lessthanequal: u32 = 2236;
pub const XKB_KEY_notequal: u32 = 2237;
pub const XKB_KEY_greaterthanequal: u32 = 2238;
pub const XKB_KEY_integral: u32 = 2239;
pub const XKB_KEY_therefore: u32 = 2240;
pub const XKB_KEY_variation: u32 = 2241;
pub const XKB_KEY_infinity: u32 = 2242;
pub const XKB_KEY_nabla: u32 = 2245;
pub const XKB_KEY_approximate: u32 = 2248;
pub const XKB_KEY_similarequal: u32 = 2249;
pub const XKB_KEY_ifonlyif: u32 = 2253;
pub const XKB_KEY_implies: u32 = 2254;
pub const XKB_KEY_identical: u32 = 2255;
pub const XKB_KEY_radical: u32 = 2262;
pub const XKB_KEY_includedin: u32 = 2266;
pub const XKB_KEY_includes: u32 = 2267;
pub const XKB_KEY_intersection: u32 = 2268;
pub const XKB_KEY_union: u32 = 2269;
pub const XKB_KEY_logicaland: u32 = 2270;
pub const XKB_KEY_logicalor: u32 = 2271;
pub const XKB_KEY_partialderivative: u32 = 2287;
pub const XKB_KEY_function: u32 = 2294;
pub const XKB_KEY_leftarrow: u32 = 2299;
pub const XKB_KEY_uparrow: u32 = 2300;
pub const XKB_KEY_rightarrow: u32 = 2301;
pub const XKB_KEY_downarrow: u32 = 2302;
pub const XKB_KEY_blank: u32 = 2527;
pub const XKB_KEY_soliddiamond: u32 = 2528;
pub const XKB_KEY_checkerboard: u32 = 2529;
pub const XKB_KEY_ht: u32 = 2530;
pub const XKB_KEY_ff: u32 = 2531;
pub const XKB_KEY_cr: u32 = 2532;
pub const XKB_KEY_lf: u32 = 2533;
pub const XKB_KEY_nl: u32 = 2536;
pub const XKB_KEY_vt: u32 = 2537;
pub const XKB_KEY_lowrightcorner: u32 = 2538;
pub const XKB_KEY_uprightcorner: u32 = 2539;
pub const XKB_KEY_upleftcorner: u32 = 2540;
pub const XKB_KEY_lowleftcorner: u32 = 2541;
pub const XKB_KEY_crossinglines: u32 = 2542;
pub const XKB_KEY_horizlinescan1: u32 = 2543;
pub const XKB_KEY_horizlinescan3: u32 = 2544;
pub const XKB_KEY_horizlinescan5: u32 = 2545;
pub const XKB_KEY_horizlinescan7: u32 = 2546;
pub const XKB_KEY_horizlinescan9: u32 = 2547;
pub const XKB_KEY_leftt: u32 = 2548;
pub const XKB_KEY_rightt: u32 = 2549;
pub const XKB_KEY_bott: u32 = 2550;
pub const XKB_KEY_topt: u32 = 2551;
pub const XKB_KEY_vertbar: u32 = 2552;
pub const XKB_KEY_emspace: u32 = 2721;
pub const XKB_KEY_enspace: u32 = 2722;
pub const XKB_KEY_em3space: u32 = 2723;
pub const XKB_KEY_em4space: u32 = 2724;
pub const XKB_KEY_digitspace: u32 = 2725;
pub const XKB_KEY_punctspace: u32 = 2726;
pub const XKB_KEY_thinspace: u32 = 2727;
pub const XKB_KEY_hairspace: u32 = 2728;
pub const XKB_KEY_emdash: u32 = 2729;
pub const XKB_KEY_endash: u32 = 2730;
pub const XKB_KEY_signifblank: u32 = 2732;
pub const XKB_KEY_ellipsis: u32 = 2734;
pub const XKB_KEY_doubbaselinedot: u32 = 2735;
pub const XKB_KEY_onethird: u32 = 2736;
pub const XKB_KEY_twothirds: u32 = 2737;
pub const XKB_KEY_onefifth: u32 = 2738;
pub const XKB_KEY_twofifths: u32 = 2739;
pub const XKB_KEY_threefifths: u32 = 2740;
pub const XKB_KEY_fourfifths: u32 = 2741;
pub const XKB_KEY_onesixth: u32 = 2742;
pub const XKB_KEY_fivesixths: u32 = 2743;
pub const XKB_KEY_careof: u32 = 2744;
pub const XKB_KEY_figdash: u32 = 2747;
pub const XKB_KEY_leftanglebracket: u32 = 2748;
pub const XKB_KEY_decimalpoint: u32 = 2749;
pub const XKB_KEY_rightanglebracket: u32 = 2750;
pub const XKB_KEY_marker: u32 = 2751;
pub const XKB_KEY_oneeighth: u32 = 2755;
pub const XKB_KEY_threeeighths: u32 = 2756;
pub const XKB_KEY_fiveeighths: u32 = 2757;
pub const XKB_KEY_seveneighths: u32 = 2758;
pub const XKB_KEY_trademark: u32 = 2761;
pub const XKB_KEY_signaturemark: u32 = 2762;
pub const XKB_KEY_trademarkincircle: u32 = 2763;
pub const XKB_KEY_leftopentriangle: u32 = 2764;
pub const XKB_KEY_rightopentriangle: u32 = 2765;
pub const XKB_KEY_emopencircle: u32 = 2766;
pub const XKB_KEY_emopenrectangle: u32 = 2767;
pub const XKB_KEY_leftsinglequotemark: u32 = 2768;
pub const XKB_KEY_rightsinglequotemark: u32 = 2769;
pub const XKB_KEY_leftdoublequotemark: u32 = 2770;
pub const XKB_KEY_rightdoublequotemark: u32 = 2771;
pub const XKB_KEY_prescription: u32 = 2772;
pub const XKB_KEY_permille: u32 = 2773;
pub const XKB_KEY_minutes: u32 = 2774;
pub const XKB_KEY_seconds: u32 = 2775;
pub const XKB_KEY_latincross: u32 = 2777;
pub const XKB_KEY_hexagram: u32 = 2778;
pub const XKB_KEY_filledrectbullet: u32 = 2779;
pub const XKB_KEY_filledlefttribullet: u32 = 2780;
pub const XKB_KEY_filledrighttribullet: u32 = 2781;
pub const XKB_KEY_emfilledcircle: u32 = 2782;
pub const XKB_KEY_emfilledrect: u32 = 2783;
pub const XKB_KEY_enopencircbullet: u32 = 2784;
pub const XKB_KEY_enopensquarebullet: u32 = 2785;
pub const XKB_KEY_openrectbullet: u32 = 2786;
pub const XKB_KEY_opentribulletup: u32 = 2787;
pub const XKB_KEY_opentribulletdown: u32 = 2788;
pub const XKB_KEY_openstar: u32 = 2789;
pub const XKB_KEY_enfilledcircbullet: u32 = 2790;
pub const XKB_KEY_enfilledsqbullet: u32 = 2791;
pub const XKB_KEY_filledtribulletup: u32 = 2792;
pub const XKB_KEY_filledtribulletdown: u32 = 2793;
pub const XKB_KEY_leftpointer: u32 = 2794;
pub const XKB_KEY_rightpointer: u32 = 2795;
pub const XKB_KEY_club: u32 = 2796;
pub const XKB_KEY_diamond: u32 = 2797;
pub const XKB_KEY_heart: u32 = 2798;
pub const XKB_KEY_maltesecross: u32 = 2800;
pub const XKB_KEY_dagger: u32 = 2801;
pub const XKB_KEY_doubledagger: u32 = 2802;
pub const XKB_KEY_checkmark: u32 = 2803;
pub const XKB_KEY_ballotcross: u32 = 2804;
pub const XKB_KEY_musicalsharp: u32 = 2805;
pub const XKB_KEY_musicalflat: u32 = 2806;
pub const XKB_KEY_malesymbol: u32 = 2807;
pub const XKB_KEY_femalesymbol: u32 = 2808;
pub const XKB_KEY_telephone: u32 = 2809;
pub const XKB_KEY_telephonerecorder: u32 = 2810;
pub const XKB_KEY_phonographcopyright: u32 = 2811;
pub const XKB_KEY_caret: u32 = 2812;
pub const XKB_KEY_singlelowquotemark: u32 = 2813;
pub const XKB_KEY_doublelowquotemark: u32 = 2814;
pub const XKB_KEY_cursor: u32 = 2815;
pub const XKB_KEY_leftcaret: u32 = 2979;
pub const XKB_KEY_rightcaret: u32 = 2982;
pub const XKB_KEY_downcaret: u32 = 2984;
pub const XKB_KEY_upcaret: u32 = 2985;
pub const XKB_KEY_overbar: u32 = 3008;
pub const XKB_KEY_downtack: u32 = 3010;
pub const XKB_KEY_upshoe: u32 = 3011;
pub const XKB_KEY_downstile: u32 = 3012;
pub const XKB_KEY_underbar: u32 = 3014;
pub const XKB_KEY_jot: u32 = 3018;
pub const XKB_KEY_quad: u32 = 3020;
pub const XKB_KEY_uptack: u32 = 3022;
pub const XKB_KEY_circle: u32 = 3023;
pub const XKB_KEY_upstile: u32 = 3027;
pub const XKB_KEY_downshoe: u32 = 3030;
pub const XKB_KEY_rightshoe: u32 = 3032;
pub const XKB_KEY_leftshoe: u32 = 3034;
pub const XKB_KEY_lefttack: u32 = 3036;
pub const XKB_KEY_righttack: u32 = 3068;
pub const XKB_KEY_hebrew_doublelowline: u32 = 3295;
pub const XKB_KEY_hebrew_aleph: u32 = 3296;
pub const XKB_KEY_hebrew_bet: u32 = 3297;
pub const XKB_KEY_hebrew_beth: u32 = 3297;
pub const XKB_KEY_hebrew_gimel: u32 = 3298;
pub const XKB_KEY_hebrew_gimmel: u32 = 3298;
pub const XKB_KEY_hebrew_dalet: u32 = 3299;
pub const XKB_KEY_hebrew_daleth: u32 = 3299;
pub const XKB_KEY_hebrew_he: u32 = 3300;
pub const XKB_KEY_hebrew_waw: u32 = 3301;
pub const XKB_KEY_hebrew_zain: u32 = 3302;
pub const XKB_KEY_hebrew_zayin: u32 = 3302;
pub const XKB_KEY_hebrew_chet: u32 = 3303;
pub const XKB_KEY_hebrew_het: u32 = 3303;
pub const XKB_KEY_hebrew_tet: u32 = 3304;
pub const XKB_KEY_hebrew_teth: u32 = 3304;
pub const XKB_KEY_hebrew_yod: u32 = 3305;
pub const XKB_KEY_hebrew_finalkaph: u32 = 3306;
pub const XKB_KEY_hebrew_kaph: u32 = 3307;
pub const XKB_KEY_hebrew_lamed: u32 = 3308;
pub const XKB_KEY_hebrew_finalmem: u32 = 3309;
pub const XKB_KEY_hebrew_mem: u32 = 3310;
pub const XKB_KEY_hebrew_finalnun: u32 = 3311;
pub const XKB_KEY_hebrew_nun: u32 = 3312;
pub const XKB_KEY_hebrew_samech: u32 = 3313;
pub const XKB_KEY_hebrew_samekh: u32 = 3313;
pub const XKB_KEY_hebrew_ayin: u32 = 3314;
pub const XKB_KEY_hebrew_finalpe: u32 = 3315;
pub const XKB_KEY_hebrew_pe: u32 = 3316;
pub const XKB_KEY_hebrew_finalzade: u32 = 3317;
pub const XKB_KEY_hebrew_finalzadi: u32 = 3317;
pub const XKB_KEY_hebrew_zade: u32 = 3318;
pub const XKB_KEY_hebrew_zadi: u32 = 3318;
pub const XKB_KEY_hebrew_qoph: u32 = 3319;
pub const XKB_KEY_hebrew_kuf: u32 = 3319;
pub const XKB_KEY_hebrew_resh: u32 = 3320;
pub const XKB_KEY_hebrew_shin: u32 = 3321;
pub const XKB_KEY_hebrew_taw: u32 = 3322;
pub const XKB_KEY_hebrew_taf: u32 = 3322;
pub const XKB_KEY_Hebrew_switch: u32 = 65406;
pub const XKB_KEY_Thai_kokai: u32 = 3489;
pub const XKB_KEY_Thai_khokhai: u32 = 3490;
pub const XKB_KEY_Thai_khokhuat: u32 = 3491;
pub const XKB_KEY_Thai_khokhwai: u32 = 3492;
pub const XKB_KEY_Thai_khokhon: u32 = 3493;
pub const XKB_KEY_Thai_khorakhang: u32 = 3494;
pub const XKB_KEY_Thai_ngongu: u32 = 3495;
pub const XKB_KEY_Thai_chochan: u32 = 3496;
pub const XKB_KEY_Thai_choching: u32 = 3497;
pub const XKB_KEY_Thai_chochang: u32 = 3498;
pub const XKB_KEY_Thai_soso: u32 = 3499;
pub const XKB_KEY_Thai_chochoe: u32 = 3500;
pub const XKB_KEY_Thai_yoying: u32 = 3501;
pub const XKB_KEY_Thai_dochada: u32 = 3502;
pub const XKB_KEY_Thai_topatak: u32 = 3503;
pub const XKB_KEY_Thai_thothan: u32 = 3504;
pub const XKB_KEY_Thai_thonangmontho: u32 = 3505;
pub const XKB_KEY_Thai_thophuthao: u32 = 3506;
pub const XKB_KEY_Thai_nonen: u32 = 3507;
pub const XKB_KEY_Thai_dodek: u32 = 3508;
pub const XKB_KEY_Thai_totao: u32 = 3509;
pub const XKB_KEY_Thai_thothung: u32 = 3510;
pub const XKB_KEY_Thai_thothahan: u32 = 3511;
pub const XKB_KEY_Thai_thothong: u32 = 3512;
pub const XKB_KEY_Thai_nonu: u32 = 3513;
pub const XKB_KEY_Thai_bobaimai: u32 = 3514;
pub const XKB_KEY_Thai_popla: u32 = 3515;
pub const XKB_KEY_Thai_phophung: u32 = 3516;
pub const XKB_KEY_Thai_fofa: u32 = 3517;
pub const XKB_KEY_Thai_phophan: u32 = 3518;
pub const XKB_KEY_Thai_fofan: u32 = 3519;
pub const XKB_KEY_Thai_phosamphao: u32 = 3520;
pub const XKB_KEY_Thai_moma: u32 = 3521;
pub const XKB_KEY_Thai_yoyak: u32 = 3522;
pub const XKB_KEY_Thai_rorua: u32 = 3523;
pub const XKB_KEY_Thai_ru: u32 = 3524;
pub const XKB_KEY_Thai_loling: u32 = 3525;
pub const XKB_KEY_Thai_lu: u32 = 3526;
pub const XKB_KEY_Thai_wowaen: u32 = 3527;
pub const XKB_KEY_Thai_sosala: u32 = 3528;
pub const XKB_KEY_Thai_sorusi: u32 = 3529;
pub const XKB_KEY_Thai_sosua: u32 = 3530;
pub const XKB_KEY_Thai_hohip: u32 = 3531;
pub const XKB_KEY_Thai_lochula: u32 = 3532;
pub const XKB_KEY_Thai_oang: u32 = 3533;
pub const XKB_KEY_Thai_honokhuk: u32 = 3534;
pub const XKB_KEY_Thai_paiyannoi: u32 = 3535;
pub const XKB_KEY_Thai_saraa: u32 = 3536;
pub const XKB_KEY_Thai_maihanakat: u32 = 3537;
pub const XKB_KEY_Thai_saraaa: u32 = 3538;
pub const XKB_KEY_Thai_saraam: u32 = 3539;
pub const XKB_KEY_Thai_sarai: u32 = 3540;
pub const XKB_KEY_Thai_saraii: u32 = 3541;
pub const XKB_KEY_Thai_saraue: u32 = 3542;
pub const XKB_KEY_Thai_sarauee: u32 = 3543;
pub const XKB_KEY_Thai_sarau: u32 = 3544;
pub const XKB_KEY_Thai_sarauu: u32 = 3545;
pub const XKB_KEY_Thai_phinthu: u32 = 3546;
pub const XKB_KEY_Thai_maihanakat_maitho: u32 = 3550;
pub const XKB_KEY_Thai_baht: u32 = 3551;
pub const XKB_KEY_Thai_sarae: u32 = 3552;
pub const XKB_KEY_Thai_saraae: u32 = 3553;
pub const XKB_KEY_Thai_sarao: u32 = 3554;
pub const XKB_KEY_Thai_saraaimaimuan: u32 = 3555;
pub const XKB_KEY_Thai_saraaimaimalai: u32 = 3556;
pub const XKB_KEY_Thai_lakkhangyao: u32 = 3557;
pub const XKB_KEY_Thai_maiyamok: u32 = 3558;
pub const XKB_KEY_Thai_maitaikhu: u32 = 3559;
pub const XKB_KEY_Thai_maiek: u32 = 3560;
pub const XKB_KEY_Thai_maitho: u32 = 3561;
pub const XKB_KEY_Thai_maitri: u32 = 3562;
pub const XKB_KEY_Thai_maichattawa: u32 = 3563;
pub const XKB_KEY_Thai_thanthakhat: u32 = 3564;
pub const XKB_KEY_Thai_nikhahit: u32 = 3565;
pub const XKB_KEY_Thai_leksun: u32 = 3568;
pub const XKB_KEY_Thai_leknung: u32 = 3569;
pub const XKB_KEY_Thai_leksong: u32 = 3570;
pub const XKB_KEY_Thai_leksam: u32 = 3571;
pub const XKB_KEY_Thai_leksi: u32 = 3572;
pub const XKB_KEY_Thai_lekha: u32 = 3573;
pub const XKB_KEY_Thai_lekhok: u32 = 3574;
pub const XKB_KEY_Thai_lekchet: u32 = 3575;
pub const XKB_KEY_Thai_lekpaet: u32 = 3576;
pub const XKB_KEY_Thai_lekkao: u32 = 3577;
pub const XKB_KEY_Hangul: u32 = 65329;
pub const XKB_KEY_Hangul_Start: u32 = 65330;
pub const XKB_KEY_Hangul_End: u32 = 65331;
pub const XKB_KEY_Hangul_Hanja: u32 = 65332;
pub const XKB_KEY_Hangul_Jamo: u32 = 65333;
pub const XKB_KEY_Hangul_Romaja: u32 = 65334;
pub const XKB_KEY_Hangul_Codeinput: u32 = 65335;
pub const XKB_KEY_Hangul_Jeonja: u32 = 65336;
pub const XKB_KEY_Hangul_Banja: u32 = 65337;
pub const XKB_KEY_Hangul_PreHanja: u32 = 65338;
pub const XKB_KEY_Hangul_PostHanja: u32 = 65339;
pub const XKB_KEY_Hangul_SingleCandidate: u32 = 65340;
pub const XKB_KEY_Hangul_MultipleCandidate: u32 = 65341;
pub const XKB_KEY_Hangul_PreviousCandidate: u32 = 65342;
pub const XKB_KEY_Hangul_Special: u32 = 65343;
pub const XKB_KEY_Hangul_switch: u32 = 65406;
pub const XKB_KEY_Hangul_Kiyeog: u32 = 3745;
pub const XKB_KEY_Hangul_SsangKiyeog: u32 = 3746;
pub const XKB_KEY_Hangul_KiyeogSios: u32 = 3747;
pub const XKB_KEY_Hangul_Nieun: u32 = 3748;
pub const XKB_KEY_Hangul_NieunJieuj: u32 = 3749;
pub const XKB_KEY_Hangul_NieunHieuh: u32 = 3750;
pub const XKB_KEY_Hangul_Dikeud: u32 = 3751;
pub const XKB_KEY_Hangul_SsangDikeud: u32 = 3752;
pub const XKB_KEY_Hangul_Rieul: u32 = 3753;
pub const XKB_KEY_Hangul_RieulKiyeog: u32 = 3754;
pub const XKB_KEY_Hangul_RieulMieum: u32 = 3755;
pub const XKB_KEY_Hangul_RieulPieub: u32 = 3756;
pub const XKB_KEY_Hangul_RieulSios: u32 = 3757;
pub const XKB_KEY_Hangul_RieulTieut: u32 = 3758;
pub const XKB_KEY_Hangul_RieulPhieuf: u32 = 3759;
pub const XKB_KEY_Hangul_RieulHieuh: u32 = 3760;
pub const XKB_KEY_Hangul_Mieum: u32 = 3761;
pub const XKB_KEY_Hangul_Pieub: u32 = 3762;
pub const XKB_KEY_Hangul_SsangPieub: u32 = 3763;
pub const XKB_KEY_Hangul_PieubSios: u32 = 3764;
pub const XKB_KEY_Hangul_Sios: u32 = 3765;
pub const XKB_KEY_Hangul_SsangSios: u32 = 3766;
pub const XKB_KEY_Hangul_Ieung: u32 = 3767;
pub const XKB_KEY_Hangul_Jieuj: u32 = 3768;
pub const XKB_KEY_Hangul_SsangJieuj: u32 = 3769;
pub const XKB_KEY_Hangul_Cieuc: u32 = 3770;
pub const XKB_KEY_Hangul_Khieuq: u32 = 3771;
pub const XKB_KEY_Hangul_Tieut: u32 = 3772;
pub const XKB_KEY_Hangul_Phieuf: u32 = 3773;
pub const XKB_KEY_Hangul_Hieuh: u32 = 3774;
pub const XKB_KEY_Hangul_A: u32 = 3775;
pub const XKB_KEY_Hangul_AE: u32 = 3776;
pub const XKB_KEY_Hangul_YA: u32 = 3777;
pub const XKB_KEY_Hangul_YAE: u32 = 3778;
pub const XKB_KEY_Hangul_EO: u32 = 3779;
pub const XKB_KEY_Hangul_E: u32 = 3780;
pub const XKB_KEY_Hangul_YEO: u32 = 3781;
pub const XKB_KEY_Hangul_YE: u32 = 3782;
pub const XKB_KEY_Hangul_O: u32 = 3783;
pub const XKB_KEY_Hangul_WA: u32 = 3784;
pub const XKB_KEY_Hangul_WAE: u32 = 3785;
pub const XKB_KEY_Hangul_OE: u32 = 3786;
pub const XKB_KEY_Hangul_YO: u32 = 3787;
pub const XKB_KEY_Hangul_U: u32 = 3788;
pub const XKB_KEY_Hangul_WEO: u32 = 3789;
pub const XKB_KEY_Hangul_WE: u32 = 3790;
pub const XKB_KEY_Hangul_WI: u32 = 3791;
pub const XKB_KEY_Hangul_YU: u32 = 3792;
pub const XKB_KEY_Hangul_EU: u32 = 3793;
pub const XKB_KEY_Hangul_YI: u32 = 3794;
pub const XKB_KEY_Hangul_I: u32 = 3795;
pub const XKB_KEY_Hangul_J_Kiyeog: u32 = 3796;
pub const XKB_KEY_Hangul_J_SsangKiyeog: u32 = 3797;
pub const XKB_KEY_Hangul_J_KiyeogSios: u32 = 3798;
pub const XKB_KEY_Hangul_J_Nieun: u32 = 3799;
pub const XKB_KEY_Hangul_J_NieunJieuj: u32 = 3800;
pub const XKB_KEY_Hangul_J_NieunHieuh: u32 = 3801;
pub const XKB_KEY_Hangul_J_Dikeud: u32 = 3802;
pub const XKB_KEY_Hangul_J_Rieul: u32 = 3803;
pub const XKB_KEY_Hangul_J_RieulKiyeog: u32 = 3804;
pub const XKB_KEY_Hangul_J_RieulMieum: u32 = 3805;
pub const XKB_KEY_Hangul_J_RieulPieub: u32 = 3806;
pub const XKB_KEY_Hangul_J_RieulSios: u32 = 3807;
pub const XKB_KEY_Hangul_J_RieulTieut: u32 = 3808;
pub const XKB_KEY_Hangul_J_RieulPhieuf: u32 = 3809;
pub const XKB_KEY_Hangul_J_RieulHieuh: u32 = 3810;
pub const XKB_KEY_Hangul_J_Mieum: u32 = 3811;
pub const XKB_KEY_Hangul_J_Pieub: u32 = 3812;
pub const XKB_KEY_Hangul_J_PieubSios: u32 = 3813;
pub const XKB_KEY_Hangul_J_Sios: u32 = 3814;
pub const XKB_KEY_Hangul_J_SsangSios: u32 = 3815;
pub const XKB_KEY_Hangul_J_Ieung: u32 = 3816;
pub const XKB_KEY_Hangul_J_Jieuj: u32 = 3817;
pub const XKB_KEY_Hangul_J_Cieuc: u32 = 3818;
pub const XKB_KEY_Hangul_J_Khieuq: u32 = 3819;
pub const XKB_KEY_Hangul_J_Tieut: u32 = 3820;
pub const XKB_KEY_Hangul_J_Phieuf: u32 = 3821;
pub const XKB_KEY_Hangul_J_Hieuh: u32 = 3822;
pub const XKB_KEY_Hangul_RieulYeorinHieuh: u32 = 3823;
pub const XKB_KEY_Hangul_SunkyeongeumMieum: u32 = 3824;
pub const XKB_KEY_Hangul_SunkyeongeumPieub: u32 = 3825;
pub const XKB_KEY_Hangul_PanSios: u32 = 3826;
pub const XKB_KEY_Hangul_KkogjiDalrinIeung: u32 = 3827;
pub const XKB_KEY_Hangul_SunkyeongeumPhieuf: u32 = 3828;
pub const XKB_KEY_Hangul_YeorinHieuh: u32 = 3829;
pub const XKB_KEY_Hangul_AraeA: u32 = 3830;
pub const XKB_KEY_Hangul_AraeAE: u32 = 3831;
pub const XKB_KEY_Hangul_J_PanSios: u32 = 3832;
pub const XKB_KEY_Hangul_J_KkogjiDalrinIeung: u32 = 3833;
pub const XKB_KEY_Hangul_J_YeorinHieuh: u32 = 3834;
pub const XKB_KEY_Korean_Won: u32 = 3839;
pub const XKB_KEY_Armenian_ligature_ew: u32 = 16778631;
pub const XKB_KEY_Armenian_full_stop: u32 = 16778633;
pub const XKB_KEY_Armenian_verjaket: u32 = 16778633;
pub const XKB_KEY_Armenian_separation_mark: u32 = 16778589;
pub const XKB_KEY_Armenian_but: u32 = 16778589;
pub const XKB_KEY_Armenian_hyphen: u32 = 16778634;
pub const XKB_KEY_Armenian_yentamna: u32 = 16778634;
pub const XKB_KEY_Armenian_exclam: u32 = 16778588;
pub const XKB_KEY_Armenian_amanak: u32 = 16778588;
pub const XKB_KEY_Armenian_accent: u32 = 16778587;
pub const XKB_KEY_Armenian_shesht: u32 = 16778587;
pub const XKB_KEY_Armenian_question: u32 = 16778590;
pub const XKB_KEY_Armenian_paruyk: u32 = 16778590;
pub const XKB_KEY_Armenian_AYB: u32 = 16778545;
pub const XKB_KEY_Armenian_ayb: u32 = 16778593;
pub const XKB_KEY_Armenian_BEN: u32 = 16778546;
pub const XKB_KEY_Armenian_ben: u32 = 16778594;
pub const XKB_KEY_Armenian_GIM: u32 = 16778547;
pub const XKB_KEY_Armenian_gim: u32 = 16778595;
pub const XKB_KEY_Armenian_DA: u32 = 16778548;
pub const XKB_KEY_Armenian_da: u32 = 16778596;
pub const XKB_KEY_Armenian_YECH: u32 = 16778549;
pub const XKB_KEY_Armenian_yech: u32 = 16778597;
pub const XKB_KEY_Armenian_ZA: u32 = 16778550;
pub const XKB_KEY_Armenian_za: u32 = 16778598;
pub const XKB_KEY_Armenian_E: u32 = 16778551;
pub const XKB_KEY_Armenian_e: u32 = 16778599;
pub const XKB_KEY_Armenian_AT: u32 = 16778552;
pub const XKB_KEY_Armenian_at: u32 = 16778600;
pub const XKB_KEY_Armenian_TO: u32 = 16778553;
pub const XKB_KEY_Armenian_to: u32 = 16778601;
pub const XKB_KEY_Armenian_ZHE: u32 = 16778554;
pub const XKB_KEY_Armenian_zhe: u32 = 16778602;
pub const XKB_KEY_Armenian_INI: u32 = 16778555;
pub const XKB_KEY_Armenian_ini: u32 = 16778603;
pub const XKB_KEY_Armenian_LYUN: u32 = 16778556;
pub const XKB_KEY_Armenian_lyun: u32 = 16778604;
pub const XKB_KEY_Armenian_KHE: u32 = 16778557;
pub const XKB_KEY_Armenian_khe: u32 = 16778605;
pub const XKB_KEY_Armenian_TSA: u32 = 16778558;
pub const XKB_KEY_Armenian_tsa: u32 = 16778606;
pub const XKB_KEY_Armenian_KEN: u32 = 16778559;
pub const XKB_KEY_Armenian_ken: u32 = 16778607;
pub const XKB_KEY_Armenian_HO: u32 = 16778560;
pub const XKB_KEY_Armenian_ho: u32 = 16778608;
pub const XKB_KEY_Armenian_DZA: u32 = 16778561;
pub const XKB_KEY_Armenian_dza: u32 = 16778609;
pub const XKB_KEY_Armenian_GHAT: u32 = 16778562;
pub const XKB_KEY_Armenian_ghat: u32 = 16778610;
pub const XKB_KEY_Armenian_TCHE: u32 = 16778563;
pub const XKB_KEY_Armenian_tche: u32 = 16778611;
pub const XKB_KEY_Armenian_MEN: u32 = 16778564;
pub const XKB_KEY_Armenian_men: u32 = 16778612;
pub const XKB_KEY_Armenian_HI: u32 = 16778565;
pub const XKB_KEY_Armenian_hi: u32 = 16778613;
pub const XKB_KEY_Armenian_NU: u32 = 16778566;
pub const XKB_KEY_Armenian_nu: u32 = 16778614;
pub const XKB_KEY_Armenian_SHA: u32 = 16778567;
pub const XKB_KEY_Armenian_sha: u32 = 16778615;
pub const XKB_KEY_Armenian_VO: u32 = 16778568;
pub const XKB_KEY_Armenian_vo: u32 = 16778616;
pub const XKB_KEY_Armenian_CHA: u32 = 16778569;
pub const XKB_KEY_Armenian_cha: u32 = 16778617;
pub const XKB_KEY_Armenian_PE: u32 = 16778570;
pub const XKB_KEY_Armenian_pe: u32 = 16778618;
pub const XKB_KEY_Armenian_JE: u32 = 16778571;
pub const XKB_KEY_Armenian_je: u32 = 16778619;
pub const XKB_KEY_Armenian_RA: u32 = 16778572;
pub const XKB_KEY_Armenian_ra: u32 = 16778620;
pub const XKB_KEY_Armenian_SE: u32 = 16778573;
pub const XKB_KEY_Armenian_se: u32 = 16778621;
pub const XKB_KEY_Armenian_VEV: u32 = 16778574;
pub const XKB_KEY_Armenian_vev: u32 = 16778622;
pub const XKB_KEY_Armenian_TYUN: u32 = 16778575;
pub const XKB_KEY_Armenian_tyun: u32 = 16778623;
pub const XKB_KEY_Armenian_RE: u32 = 16778576;
pub const XKB_KEY_Armenian_re: u32 = 16778624;
pub const XKB_KEY_Armenian_TSO: u32 = 16778577;
pub const XKB_KEY_Armenian_tso: u32 = 16778625;
pub const XKB_KEY_Armenian_VYUN: u32 = 16778578;
pub const XKB_KEY_Armenian_vyun: u32 = 16778626;
pub const XKB_KEY_Armenian_PYUR: u32 = 16778579;
pub const XKB_KEY_Armenian_pyur: u32 = 16778627;
pub const XKB_KEY_Armenian_KE: u32 = 16778580;
pub const XKB_KEY_Armenian_ke: u32 = 16778628;
pub const XKB_KEY_Armenian_O: u32 = 16778581;
pub const XKB_KEY_Armenian_o: u32 = 16778629;
pub const XKB_KEY_Armenian_FE: u32 = 16778582;
pub const XKB_KEY_Armenian_fe: u32 = 16778630;
pub const XKB_KEY_Armenian_apostrophe: u32 = 16778586;
pub const XKB_KEY_Georgian_an: u32 = 16781520;
pub const XKB_KEY_Georgian_ban: u32 = 16781521;
pub const XKB_KEY_Georgian_gan: u32 = 16781522;
pub const XKB_KEY_Georgian_don: u32 = 16781523;
pub const XKB_KEY_Georgian_en: u32 = 16781524;
pub const XKB_KEY_Georgian_vin: u32 = 16781525;
pub const XKB_KEY_Georgian_zen: u32 = 16781526;
pub const XKB_KEY_Georgian_tan: u32 = 16781527;
pub const XKB_KEY_Georgian_in: u32 = 16781528;
pub const XKB_KEY_Georgian_kan: u32 = 16781529;
pub const XKB_KEY_Georgian_las: u32 = 16781530;
pub const XKB_KEY_Georgian_man: u32 = 16781531;
pub const XKB_KEY_Georgian_nar: u32 = 16781532;
pub const XKB_KEY_Georgian_on: u32 = 16781533;
pub const XKB_KEY_Georgian_par: u32 = 16781534;
pub const XKB_KEY_Georgian_zhar: u32 = 16781535;
pub const XKB_KEY_Georgian_rae: u32 = 16781536;
pub const XKB_KEY_Georgian_san: u32 = 16781537;
pub const XKB_KEY_Georgian_tar: u32 = 16781538;
pub const XKB_KEY_Georgian_un: u32 = 16781539;
pub const XKB_KEY_Georgian_phar: u32 = 16781540;
pub const XKB_KEY_Georgian_khar: u32 = 16781541;
pub const XKB_KEY_Georgian_ghan: u32 = 16781542;
pub const XKB_KEY_Georgian_qar: u32 = 16781543;
pub const XKB_KEY_Georgian_shin: u32 = 16781544;
pub const XKB_KEY_Georgian_chin: u32 = 16781545;
pub const XKB_KEY_Georgian_can: u32 = 16781546;
pub const XKB_KEY_Georgian_jil: u32 = 16781547;
pub const XKB_KEY_Georgian_cil: u32 = 16781548;
pub const XKB_KEY_Georgian_char: u32 = 16781549;
pub const XKB_KEY_Georgian_xan: u32 = 16781550;
pub const XKB_KEY_Georgian_jhan: u32 = 16781551;
pub const XKB_KEY_Georgian_hae: u32 = 16781552;
pub const XKB_KEY_Georgian_he: u32 = 16781553;
pub const XKB_KEY_Georgian_hie: u32 = 16781554;
pub const XKB_KEY_Georgian_we: u32 = 16781555;
pub const XKB_KEY_Georgian_har: u32 = 16781556;
pub const XKB_KEY_Georgian_hoe: u32 = 16781557;
pub const XKB_KEY_Georgian_fi: u32 = 16781558;
pub const XKB_KEY_Xabovedot: u32 = 16785034;
pub const XKB_KEY_Ibreve: u32 = 16777516;
pub const XKB_KEY_Zstroke: u32 = 16777653;
pub const XKB_KEY_Gcaron: u32 = 16777702;
pub const XKB_KEY_Ocaron: u32 = 16777681;
pub const XKB_KEY_Obarred: u32 = 16777631;
pub const XKB_KEY_xabovedot: u32 = 16785035;
pub const XKB_KEY_ibreve: u32 = 16777517;
pub const XKB_KEY_zstroke: u32 = 16777654;
pub const XKB_KEY_gcaron: u32 = 16777703;
pub const XKB_KEY_ocaron: u32 = 16777682;
pub const XKB_KEY_obarred: u32 = 16777845;
pub const XKB_KEY_SCHWA: u32 = 16777615;
pub const XKB_KEY_schwa: u32 = 16777817;
pub const XKB_KEY_EZH: u32 = 16777655;
pub const XKB_KEY_ezh: u32 = 16777874;
pub const XKB_KEY_Lbelowdot: u32 = 16784950;
pub const XKB_KEY_lbelowdot: u32 = 16784951;
pub const XKB_KEY_Abelowdot: u32 = 16785056;
pub const XKB_KEY_abelowdot: u32 = 16785057;
pub const XKB_KEY_Ahook: u32 = 16785058;
pub const XKB_KEY_ahook: u32 = 16785059;
pub const XKB_KEY_Acircumflexacute: u32 = 16785060;
pub const XKB_KEY_acircumflexacute: u32 = 16785061;
pub const XKB_KEY_Acircumflexgrave: u32 = 16785062;
pub const XKB_KEY_acircumflexgrave: u32 = 16785063;
pub const XKB_KEY_Acircumflexhook: u32 = 16785064;
pub const XKB_KEY_acircumflexhook: u32 = 16785065;
pub const XKB_KEY_Acircumflextilde: u32 = 16785066;
pub const XKB_KEY_acircumflextilde: u32 = 16785067;
pub const XKB_KEY_Acircumflexbelowdot: u32 = 16785068;
pub const XKB_KEY_acircumflexbelowdot: u32 = 16785069;
pub const XKB_KEY_Abreveacute: u32 = 16785070;
pub const XKB_KEY_abreveacute: u32 = 16785071;
pub const XKB_KEY_Abrevegrave: u32 = 16785072;
pub const XKB_KEY_abrevegrave: u32 = 16785073;
pub const XKB_KEY_Abrevehook: u32 = 16785074;
pub const XKB_KEY_abrevehook: u32 = 16785075;
pub const XKB_KEY_Abrevetilde: u32 = 16785076;
pub const XKB_KEY_abrevetilde: u32 = 16785077;
pub const XKB_KEY_Abrevebelowdot: u32 = 16785078;
pub const XKB_KEY_abrevebelowdot: u32 = 16785079;
pub const XKB_KEY_Ebelowdot: u32 = 16785080;
pub const XKB_KEY_ebelowdot: u32 = 16785081;
pub const XKB_KEY_Ehook: u32 = 16785082;
pub const XKB_KEY_ehook: u32 = 16785083;
pub const XKB_KEY_Etilde: u32 = 16785084;
pub const XKB_KEY_etilde: u32 = 16785085;
pub const XKB_KEY_Ecircumflexacute: u32 = 16785086;
pub const XKB_KEY_ecircumflexacute: u32 = 16785087;
pub const XKB_KEY_Ecircumflexgrave: u32 = 16785088;
pub const XKB_KEY_ecircumflexgrave: u32 = 16785089;
pub const XKB_KEY_Ecircumflexhook: u32 = 16785090;
pub const XKB_KEY_ecircumflexhook: u32 = 16785091;
pub const XKB_KEY_Ecircumflextilde: u32 = 16785092;
pub const XKB_KEY_ecircumflextilde: u32 = 16785093;
pub const XKB_KEY_Ecircumflexbelowdot: u32 = 16785094;
pub const XKB_KEY_ecircumflexbelowdot: u32 = 16785095;
pub const XKB_KEY_Ihook: u32 = 16785096;
pub const XKB_KEY_ihook: u32 = 16785097;
pub const XKB_KEY_Ibelowdot: u32 = 16785098;
pub const XKB_KEY_ibelowdot: u32 = 16785099;
pub const XKB_KEY_Obelowdot: u32 = 16785100;
pub const XKB_KEY_obelowdot: u32 = 16785101;
pub const XKB_KEY_Ohook: u32 = 16785102;
pub const XKB_KEY_ohook: u32 = 16785103;
pub const XKB_KEY_Ocircumflexacute: u32 = 16785104;
pub const XKB_KEY_ocircumflexacute: u32 = 16785105;
pub const XKB_KEY_Ocircumflexgrave: u32 = 16785106;
pub const XKB_KEY_ocircumflexgrave: u32 = 16785107;
pub const XKB_KEY_Ocircumflexhook: u32 = 16785108;
pub const XKB_KEY_ocircumflexhook: u32 = 16785109;
pub const XKB_KEY_Ocircumflextilde: u32 = 16785110;
pub const XKB_KEY_ocircumflextilde: u32 = 16785111;
pub const XKB_KEY_Ocircumflexbelowdot: u32 = 16785112;
pub const XKB_KEY_ocircumflexbelowdot: u32 = 16785113;
pub const XKB_KEY_Ohornacute: u32 = 16785114;
pub const XKB_KEY_ohornacute: u32 = 16785115;
pub const XKB_KEY_Ohorngrave: u32 = 16785116;
pub const XKB_KEY_ohorngrave: u32 = 16785117;
pub const XKB_KEY_Ohornhook: u32 = 16785118;
pub const XKB_KEY_ohornhook: u32 = 16785119;
pub const XKB_KEY_Ohorntilde: u32 = 16785120;
pub const XKB_KEY_ohorntilde: u32 = 16785121;
pub const XKB_KEY_Ohornbelowdot: u32 = 16785122;
pub const XKB_KEY_ohornbelowdot: u32 = 16785123;
pub const XKB_KEY_Ubelowdot: u32 = 16785124;
pub const XKB_KEY_ubelowdot: u32 = 16785125;
pub const XKB_KEY_Uhook: u32 = 16785126;
pub const XKB_KEY_uhook: u32 = 16785127;
pub const XKB_KEY_Uhornacute: u32 = 16785128;
pub const XKB_KEY_uhornacute: u32 = 16785129;
pub const XKB_KEY_Uhorngrave: u32 = 16785130;
pub const XKB_KEY_uhorngrave: u32 = 16785131;
pub const XKB_KEY_Uhornhook: u32 = 16785132;
pub const XKB_KEY_uhornhook: u32 = 16785133;
pub const XKB_KEY_Uhorntilde: u32 = 16785134;
pub const XKB_KEY_uhorntilde: u32 = 16785135;
pub const XKB_KEY_Uhornbelowdot: u32 = 16785136;
pub const XKB_KEY_uhornbelowdot: u32 = 16785137;
pub const XKB_KEY_Ybelowdot: u32 = 16785140;
pub const XKB_KEY_ybelowdot: u32 = 16785141;
pub const XKB_KEY_Yhook: u32 = 16785142;
pub const XKB_KEY_yhook: u32 = 16785143;
pub const XKB_KEY_Ytilde: u32 = 16785144;
pub const XKB_KEY_ytilde: u32 = 16785145;
pub const XKB_KEY_Ohorn: u32 = 16777632;
pub const XKB_KEY_ohorn: u32 = 16777633;
pub const XKB_KEY_Uhorn: u32 = 16777647;
pub const XKB_KEY_uhorn: u32 = 16777648;
pub const XKB_KEY_EcuSign: u32 = 16785568;
pub const XKB_KEY_ColonSign: u32 = 16785569;
pub const XKB_KEY_CruzeiroSign: u32 = 16785570;
pub const XKB_KEY_FFrancSign: u32 = 16785571;
pub const XKB_KEY_LiraSign: u32 = 16785572;
pub const XKB_KEY_MillSign: u32 = 16785573;
pub const XKB_KEY_NairaSign: u32 = 16785574;
pub const XKB_KEY_PesetaSign: u32 = 16785575;
pub const XKB_KEY_RupeeSign: u32 = 16785576;
pub const XKB_KEY_WonSign: u32 = 16785577;
pub const XKB_KEY_NewSheqelSign: u32 = 16785578;
pub const XKB_KEY_DongSign: u32 = 16785579;
pub const XKB_KEY_EuroSign: u32 = 8364;
pub const XKB_KEY_zerosuperior: u32 = 16785520;
pub const XKB_KEY_foursuperior: u32 = 16785524;
pub const XKB_KEY_fivesuperior: u32 = 16785525;
pub const XKB_KEY_sixsuperior: u32 = 16785526;
pub const XKB_KEY_sevensuperior: u32 = 16785527;
pub const XKB_KEY_eightsuperior: u32 = 16785528;
pub const XKB_KEY_ninesuperior: u32 = 16785529;
pub const XKB_KEY_zerosubscript: u32 = 16785536;
pub const XKB_KEY_onesubscript: u32 = 16785537;
pub const XKB_KEY_twosubscript: u32 = 16785538;
pub const XKB_KEY_threesubscript: u32 = 16785539;
pub const XKB_KEY_foursubscript: u32 = 16785540;
pub const XKB_KEY_fivesubscript: u32 = 16785541;
pub const XKB_KEY_sixsubscript: u32 = 16785542;
pub const XKB_KEY_sevensubscript: u32 = 16785543;
pub const XKB_KEY_eightsubscript: u32 = 16785544;
pub const XKB_KEY_ninesubscript: u32 = 16785545;
pub const XKB_KEY_partdifferential: u32 = 16785922;
pub const XKB_KEY_emptyset: u32 = 16785925;
pub const XKB_KEY_elementof: u32 = 16785928;
pub const XKB_KEY_notelementof: u32 = 16785929;
pub const XKB_KEY_containsas: u32 = 16785931;
pub const XKB_KEY_squareroot: u32 = 16785946;
pub const XKB_KEY_cuberoot: u32 = 16785947;
pub const XKB_KEY_fourthroot: u32 = 16785948;
pub const XKB_KEY_dintegral: u32 = 16785964;
pub const XKB_KEY_tintegral: u32 = 16785965;
pub const XKB_KEY_because: u32 = 16785973;
pub const XKB_KEY_approxeq: u32 = 16785992;
pub const XKB_KEY_notapproxeq: u32 = 16785991;
pub const XKB_KEY_notidentical: u32 = 16786018;
pub const XKB_KEY_stricteq: u32 = 16786019;
pub const XKB_KEY_braille_dot_1: u32 = 65521;
pub const XKB_KEY_braille_dot_2: u32 = 65522;
pub const XKB_KEY_braille_dot_3: u32 = 65523;
pub const XKB_KEY_braille_dot_4: u32 = 65524;
pub const XKB_KEY_braille_dot_5: u32 = 65525;
pub const XKB_KEY_braille_dot_6: u32 = 65526;
pub const XKB_KEY_braille_dot_7: u32 = 65527;
pub const XKB_KEY_braille_dot_8: u32 = 65528;
pub const XKB_KEY_braille_dot_9: u32 = 65529;
pub const XKB_KEY_braille_dot_10: u32 = 65530;
pub const XKB_KEY_braille_blank: u32 = 16787456;
pub const XKB_KEY_braille_dots_1: u32 = 16787457;
pub const XKB_KEY_braille_dots_2: u32 = 16787458;
pub const XKB_KEY_braille_dots_12: u32 = 16787459;
pub const XKB_KEY_braille_dots_3: u32 = 16787460;
pub const XKB_KEY_braille_dots_13: u32 = 16787461;
pub const XKB_KEY_braille_dots_23: u32 = 16787462;
pub const XKB_KEY_braille_dots_123: u32 = 16787463;
pub const XKB_KEY_braille_dots_4: u32 = 16787464;
pub const XKB_KEY_braille_dots_14: u32 = 16787465;
pub const XKB_KEY_braille_dots_24: u32 = 16787466;
pub const XKB_KEY_braille_dots_124: u32 = 16787467;
pub const XKB_KEY_braille_dots_34: u32 = 16787468;
pub const XKB_KEY_braille_dots_134: u32 = 16787469;
pub const XKB_KEY_braille_dots_234: u32 = 16787470;
pub const XKB_KEY_braille_dots_1234: u32 = 16787471;
pub const XKB_KEY_braille_dots_5: u32 = 16787472;
pub const XKB_KEY_braille_dots_15: u32 = 16787473;
pub const XKB_KEY_braille_dots_25: u32 = 16787474;
pub const XKB_KEY_braille_dots_125: u32 = 16787475;
pub const XKB_KEY_braille_dots_35: u32 = 16787476;
pub const XKB_KEY_braille_dots_135: u32 = 16787477;
pub const XKB_KEY_braille_dots_235: u32 = 16787478;
pub const XKB_KEY_braille_dots_1235: u32 = 16787479;
pub const XKB_KEY_braille_dots_45: u32 = 16787480;
pub const XKB_KEY_braille_dots_145: u32 = 16787481;
pub const XKB_KEY_braille_dots_245: u32 = 16787482;
pub const XKB_KEY_braille_dots_1245: u32 = 16787483;
pub const XKB_KEY_braille_dots_345: u32 = 16787484;
pub const XKB_KEY_braille_dots_1345: u32 = 16787485;
pub const XKB_KEY_braille_dots_2345: u32 = 16787486;
pub const XKB_KEY_braille_dots_12345: u32 = 16787487;
pub const XKB_KEY_braille_dots_6: u32 = 16787488;
pub const XKB_KEY_braille_dots_16: u32 = 16787489;
pub const XKB_KEY_braille_dots_26: u32 = 16787490;
pub const XKB_KEY_braille_dots_126: u32 = 16787491;
pub const XKB_KEY_braille_dots_36: u32 = 16787492;
pub const XKB_KEY_braille_dots_136: u32 = 16787493;
pub const XKB_KEY_braille_dots_236: u32 = 16787494;
pub const XKB_KEY_braille_dots_1236: u32 = 16787495;
pub const XKB_KEY_braille_dots_46: u32 = 16787496;
pub const XKB_KEY_braille_dots_146: u32 = 16787497;
pub const XKB_KEY_braille_dots_246: u32 = 16787498;
pub const XKB_KEY_braille_dots_1246: u32 = 16787499;
pub const XKB_KEY_braille_dots_346: u32 = 16787500;
pub const XKB_KEY_braille_dots_1346: u32 = 16787501;
pub const XKB_KEY_braille_dots_2346: u32 = 16787502;
pub const XKB_KEY_braille_dots_12346: u32 = 16787503;
pub const XKB_KEY_braille_dots_56: u32 = 16787504;
pub const XKB_KEY_braille_dots_156: u32 = 16787505;
pub const XKB_KEY_braille_dots_256: u32 = 16787506;
pub const XKB_KEY_braille_dots_1256: u32 = 16787507;
pub const XKB_KEY_braille_dots_356: u32 = 16787508;
pub const XKB_KEY_braille_dots_1356: u32 = 16787509;
pub const XKB_KEY_braille_dots_2356: u32 = 16787510;
pub const XKB_KEY_braille_dots_12356: u32 = 16787511;
pub const XKB_KEY_braille_dots_456: u32 = 16787512;
pub const XKB_KEY_braille_dots_1456: u32 = 16787513;
pub const XKB_KEY_braille_dots_2456: u32 = 16787514;
pub const XKB_KEY_braille_dots_12456: u32 = 16787515;
pub const XKB_KEY_braille_dots_3456: u32 = 16787516;
pub const XKB_KEY_braille_dots_13456: u32 = 16787517;
pub const XKB_KEY_braille_dots_23456: u32 = 16787518;
pub const XKB_KEY_braille_dots_123456: u32 = 16787519;
pub const XKB_KEY_braille_dots_7: u32 = 16787520;
pub const XKB_KEY_braille_dots_17: u32 = 16787521;
pub const XKB_KEY_braille_dots_27: u32 = 16787522;
pub const XKB_KEY_braille_dots_127: u32 = 16787523;
pub const XKB_KEY_braille_dots_37: u32 = 16787524;
pub const XKB_KEY_braille_dots_137: u32 = 16787525;
pub const XKB_KEY_braille_dots_237: u32 = 16787526;
pub const XKB_KEY_braille_dots_1237: u32 = 16787527;
pub const XKB_KEY_braille_dots_47: u32 = 16787528;
pub const XKB_KEY_braille_dots_147: u32 = 16787529;
pub const XKB_KEY_braille_dots_247: u32 = 16787530;
pub const XKB_KEY_braille_dots_1247: u32 = 16787531;
pub const XKB_KEY_braille_dots_347: u32 = 16787532;
pub const XKB_KEY_braille_dots_1347: u32 = 16787533;
pub const XKB_KEY_braille_dots_2347: u32 = 16787534;
pub const XKB_KEY_braille_dots_12347: u32 = 16787535;
pub const XKB_KEY_braille_dots_57: u32 = 16787536;
pub const XKB_KEY_braille_dots_157: u32 = 16787537;
pub const XKB_KEY_braille_dots_257: u32 = 16787538;
pub const XKB_KEY_braille_dots_1257: u32 = 16787539;
pub const XKB_KEY_braille_dots_357: u32 = 16787540;
pub const XKB_KEY_braille_dots_1357: u32 = 16787541;
pub const XKB_KEY_braille_dots_2357: u32 = 16787542;
pub const XKB_KEY_braille_dots_12357: u32 = 16787543;
pub const XKB_KEY_braille_dots_457: u32 = 16787544;
pub const XKB_KEY_braille_dots_1457: u32 = 16787545;
pub const XKB_KEY_braille_dots_2457: u32 = 16787546;
pub const XKB_KEY_braille_dots_12457: u32 = 16787547;
pub const XKB_KEY_braille_dots_3457: u32 = 16787548;
pub const XKB_KEY_braille_dots_13457: u32 = 16787549;
pub const XKB_KEY_braille_dots_23457: u32 = 16787550;
pub const XKB_KEY_braille_dots_123457: u32 = 16787551;
pub const XKB_KEY_braille_dots_67: u32 = 16787552;
pub const XKB_KEY_braille_dots_167: u32 = 16787553;
pub const XKB_KEY_braille_dots_267: u32 = 16787554;
pub const XKB_KEY_braille_dots_1267: u32 = 16787555;
pub const XKB_KEY_braille_dots_367: u32 = 16787556;
pub const XKB_KEY_braille_dots_1367: u32 = 16787557;
pub const XKB_KEY_braille_dots_2367: u32 = 16787558;
pub const XKB_KEY_braille_dots_12367: u32 = 16787559;
pub const XKB_KEY_braille_dots_467: u32 = 16787560;
pub const XKB_KEY_braille_dots_1467: u32 = 16787561;
pub const XKB_KEY_braille_dots_2467: u32 = 16787562;
pub const XKB_KEY_braille_dots_12467: u32 = 16787563;
pub const XKB_KEY_braille_dots_3467: u32 = 16787564;
pub const XKB_KEY_braille_dots_13467: u32 = 16787565;
pub const XKB_KEY_braille_dots_23467: u32 = 16787566;
pub const XKB_KEY_braille_dots_123467: u32 = 16787567;
pub const XKB_KEY_braille_dots_567: u32 = 16787568;
pub const XKB_KEY_braille_dots_1567: u32 = 16787569;
pub const XKB_KEY_braille_dots_2567: u32 = 16787570;
pub const XKB_KEY_braille_dots_12567: u32 = 16787571;
pub const XKB_KEY_braille_dots_3567: u32 = 16787572;
pub const XKB_KEY_braille_dots_13567: u32 = 16787573;
pub const XKB_KEY_braille_dots_23567: u32 = 16787574;
pub const XKB_KEY_braille_dots_123567: u32 = 16787575;
pub const XKB_KEY_braille_dots_4567: u32 = 16787576;
pub const XKB_KEY_braille_dots_14567: u32 = 16787577;
pub const XKB_KEY_braille_dots_24567: u32 = 16787578;
pub const XKB_KEY_braille_dots_124567: u32 = 16787579;
pub const XKB_KEY_braille_dots_34567: u32 = 16787580;
pub const XKB_KEY_braille_dots_134567: u32 = 16787581;
pub const XKB_KEY_braille_dots_234567: u32 = 16787582;
pub const XKB_KEY_braille_dots_1234567: u32 = 16787583;
pub const XKB_KEY_braille_dots_8: u32 = 16787584;
pub const XKB_KEY_braille_dots_18: u32 = 16787585;
pub const XKB_KEY_braille_dots_28: u32 = 16787586;
pub const XKB_KEY_braille_dots_128: u32 = 16787587;
pub const XKB_KEY_braille_dots_38: u32 = 16787588;
pub const XKB_KEY_braille_dots_138: u32 = 16787589;
pub const XKB_KEY_braille_dots_238: u32 = 16787590;
pub const XKB_KEY_braille_dots_1238: u32 = 16787591;
pub const XKB_KEY_braille_dots_48: u32 = 16787592;
pub const XKB_KEY_braille_dots_148: u32 = 16787593;
pub const XKB_KEY_braille_dots_248: u32 = 16787594;
pub const XKB_KEY_braille_dots_1248: u32 = 16787595;
pub const XKB_KEY_braille_dots_348: u32 = 16787596;
pub const XKB_KEY_braille_dots_1348: u32 = 16787597;
pub const XKB_KEY_braille_dots_2348: u32 = 16787598;
pub const XKB_KEY_braille_dots_12348: u32 = 16787599;
pub const XKB_KEY_braille_dots_58: u32 = 16787600;
pub const XKB_KEY_braille_dots_158: u32 = 16787601;
pub const XKB_KEY_braille_dots_258: u32 = 16787602;
pub const XKB_KEY_braille_dots_1258: u32 = 16787603;
pub const XKB_KEY_braille_dots_358: u32 = 16787604;
pub const XKB_KEY_braille_dots_1358: u32 = 16787605;
pub const XKB_KEY_braille_dots_2358: u32 = 16787606;
pub const XKB_KEY_braille_dots_12358: u32 = 16787607;
pub const XKB_KEY_braille_dots_458: u32 = 16787608;
pub const XKB_KEY_braille_dots_1458: u32 = 16787609;
pub const XKB_KEY_braille_dots_2458: u32 = 16787610;
pub const XKB_KEY_braille_dots_12458: u32 = 16787611;
pub const XKB_KEY_braille_dots_3458: u32 = 16787612;
pub const XKB_KEY_braille_dots_13458: u32 = 16787613;
pub const XKB_KEY_braille_dots_23458: u32 = 16787614;
pub const XKB_KEY_braille_dots_123458: u32 = 16787615;
pub const XKB_KEY_braille_dots_68: u32 = 16787616;
pub const XKB_KEY_braille_dots_168: u32 = 16787617;
pub const XKB_KEY_braille_dots_268: u32 = 16787618;
pub const XKB_KEY_braille_dots_1268: u32 = 16787619;
pub const XKB_KEY_braille_dots_368: u32 = 16787620;
pub const XKB_KEY_braille_dots_1368: u32 = 16787621;
pub const XKB_KEY_braille_dots_2368: u32 = 16787622;
pub const XKB_KEY_braille_dots_12368: u32 = 16787623;
pub const XKB_KEY_braille_dots_468: u32 = 16787624;
pub const XKB_KEY_braille_dots_1468: u32 = 16787625;
pub const XKB_KEY_braille_dots_2468: u32 = 16787626;
pub const XKB_KEY_braille_dots_12468: u32 = 16787627;
pub const XKB_KEY_braille_dots_3468: u32 = 16787628;
pub const XKB_KEY_braille_dots_13468: u32 = 16787629;
pub const XKB_KEY_braille_dots_23468: u32 = 16787630;
pub const XKB_KEY_braille_dots_123468: u32 = 16787631;
pub const XKB_KEY_braille_dots_568: u32 = 16787632;
pub const XKB_KEY_braille_dots_1568: u32 = 16787633;
pub const XKB_KEY_braille_dots_2568: u32 = 16787634;
pub const XKB_KEY_braille_dots_12568: u32 = 16787635;
pub const XKB_KEY_braille_dots_3568: u32 = 16787636;
pub const XKB_KEY_braille_dots_13568: u32 = 16787637;
pub const XKB_KEY_braille_dots_23568: u32 = 16787638;
pub const XKB_KEY_braille_dots_123568: u32 = 16787639;
pub const XKB_KEY_braille_dots_4568: u32 = 16787640;
pub const XKB_KEY_braille_dots_14568: u32 = 16787641;
pub const XKB_KEY_braille_dots_24568: u32 = 16787642;
pub const XKB_KEY_braille_dots_124568: u32 = 16787643;
pub const XKB_KEY_braille_dots_34568: u32 = 16787644;
pub const XKB_KEY_braille_dots_134568: u32 = 16787645;
pub const XKB_KEY_braille_dots_234568: u32 = 16787646;
pub const XKB_KEY_braille_dots_1234568: u32 = 16787647;
pub const XKB_KEY_braille_dots_78: u32 = 16787648;
pub const XKB_KEY_braille_dots_178: u32 = 16787649;
pub const XKB_KEY_braille_dots_278: u32 = 16787650;
pub const XKB_KEY_braille_dots_1278: u32 = 16787651;
pub const XKB_KEY_braille_dots_378: u32 = 16787652;
pub const XKB_KEY_braille_dots_1378: u32 = 16787653;
pub const XKB_KEY_braille_dots_2378: u32 = 16787654;
pub const XKB_KEY_braille_dots_12378: u32 = 16787655;
pub const XKB_KEY_braille_dots_478: u32 = 16787656;
pub const XKB_KEY_braille_dots_1478: u32 = 16787657;
pub const XKB_KEY_braille_dots_2478: u32 = 16787658;
pub const XKB_KEY_braille_dots_12478: u32 = 16787659;
pub const XKB_KEY_braille_dots_3478: u32 = 16787660;
pub const XKB_KEY_braille_dots_13478: u32 = 16787661;
pub const XKB_KEY_braille_dots_23478: u32 = 16787662;
pub const XKB_KEY_braille_dots_123478: u32 = 16787663;
pub const XKB_KEY_braille_dots_578: u32 = 16787664;
pub const XKB_KEY_braille_dots_1578: u32 = 16787665;
pub const XKB_KEY_braille_dots_2578: u32 = 16787666;
pub const XKB_KEY_braille_dots_12578: u32 = 16787667;
pub const XKB_KEY_braille_dots_3578: u32 = 16787668;
pub const XKB_KEY_braille_dots_13578: u32 = 16787669;
pub const XKB_KEY_braille_dots_23578: u32 = 16787670;
pub const XKB_KEY_braille_dots_123578: u32 = 16787671;
pub const XKB_KEY_braille_dots_4578: u32 = 16787672;
pub const XKB_KEY_braille_dots_14578: u32 = 16787673;
pub const XKB_KEY_braille_dots_24578: u32 = 16787674;
pub const XKB_KEY_braille_dots_124578: u32 = 16787675;
pub const XKB_KEY_braille_dots_34578: u32 = 16787676;
pub const XKB_KEY_braille_dots_134578: u32 = 16787677;
pub const XKB_KEY_braille_dots_234578: u32 = 16787678;
pub const XKB_KEY_braille_dots_1234578: u32 = 16787679;
pub const XKB_KEY_braille_dots_678: u32 = 16787680;
pub const XKB_KEY_braille_dots_1678: u32 = 16787681;
pub const XKB_KEY_braille_dots_2678: u32 = 16787682;
pub const XKB_KEY_braille_dots_12678: u32 = 16787683;
pub const XKB_KEY_braille_dots_3678: u32 = 16787684;
pub const XKB_KEY_braille_dots_13678: u32 = 16787685;
pub const XKB_KEY_braille_dots_23678: u32 = 16787686;
pub const XKB_KEY_braille_dots_123678: u32 = 16787687;
pub const XKB_KEY_braille_dots_4678: u32 = 16787688;
pub const XKB_KEY_braille_dots_14678: u32 = 16787689;
pub const XKB_KEY_braille_dots_24678: u32 = 16787690;
pub const XKB_KEY_braille_dots_124678: u32 = 16787691;
pub const XKB_KEY_braille_dots_34678: u32 = 16787692;
pub const XKB_KEY_braille_dots_134678: u32 = 16787693;
pub const XKB_KEY_braille_dots_234678: u32 = 16787694;
pub const XKB_KEY_braille_dots_1234678: u32 = 16787695;
pub const XKB_KEY_braille_dots_5678: u32 = 16787696;
pub const XKB_KEY_braille_dots_15678: u32 = 16787697;
pub const XKB_KEY_braille_dots_25678: u32 = 16787698;
pub const XKB_KEY_braille_dots_125678: u32 = 16787699;
pub const XKB_KEY_braille_dots_35678: u32 = 16787700;
pub const XKB_KEY_braille_dots_135678: u32 = 16787701;
pub const XKB_KEY_braille_dots_235678: u32 = 16787702;
pub const XKB_KEY_braille_dots_1235678: u32 = 16787703;
pub const XKB_KEY_braille_dots_45678: u32 = 16787704;
pub const XKB_KEY_braille_dots_145678: u32 = 16787705;
pub const XKB_KEY_braille_dots_245678: u32 = 16787706;
pub const XKB_KEY_braille_dots_1245678: u32 = 16787707;
pub const XKB_KEY_braille_dots_345678: u32 = 16787708;
pub const XKB_KEY_braille_dots_1345678: u32 = 16787709;
pub const XKB_KEY_braille_dots_2345678: u32 = 16787710;
pub const XKB_KEY_braille_dots_12345678: u32 = 16787711;
pub const XKB_KEY_Sinh_ng: u32 = 16780674;
pub const XKB_KEY_Sinh_h2: u32 = 16780675;
pub const XKB_KEY_Sinh_a: u32 = 16780677;
pub const XKB_KEY_Sinh_aa: u32 = 16780678;
pub const XKB_KEY_Sinh_ae: u32 = 16780679;
pub const XKB_KEY_Sinh_aee: u32 = 16780680;
pub const XKB_KEY_Sinh_i: u32 = 16780681;
pub const XKB_KEY_Sinh_ii: u32 = 16780682;
pub const XKB_KEY_Sinh_u: u32 = 16780683;
pub const XKB_KEY_Sinh_uu: u32 = 16780684;
pub const XKB_KEY_Sinh_ri: u32 = 16780685;
pub const XKB_KEY_Sinh_rii: u32 = 16780686;
pub const XKB_KEY_Sinh_lu: u32 = 16780687;
pub const XKB_KEY_Sinh_luu: u32 = 16780688;
pub const XKB_KEY_Sinh_e: u32 = 16780689;
pub const XKB_KEY_Sinh_ee: u32 = 16780690;
pub const XKB_KEY_Sinh_ai: u32 = 16780691;
pub const XKB_KEY_Sinh_o: u32 = 16780692;
pub const XKB_KEY_Sinh_oo: u32 = 16780693;
pub const XKB_KEY_Sinh_au: u32 = 16780694;
pub const XKB_KEY_Sinh_ka: u32 = 16780698;
pub const XKB_KEY_Sinh_kha: u32 = 16780699;
pub const XKB_KEY_Sinh_ga: u32 = 16780700;
pub const XKB_KEY_Sinh_gha: u32 = 16780701;
pub const XKB_KEY_Sinh_ng2: u32 = 16780702;
pub const XKB_KEY_Sinh_nga: u32 = 16780703;
pub const XKB_KEY_Sinh_ca: u32 = 16780704;
pub const XKB_KEY_Sinh_cha: u32 = 16780705;
pub const XKB_KEY_Sinh_ja: u32 = 16780706;
pub const XKB_KEY_Sinh_jha: u32 = 16780707;
pub const XKB_KEY_Sinh_nya: u32 = 16780708;
pub const XKB_KEY_Sinh_jnya: u32 = 16780709;
pub const XKB_KEY_Sinh_nja: u32 = 16780710;
pub const XKB_KEY_Sinh_tta: u32 = 16780711;
pub const XKB_KEY_Sinh_ttha: u32 = 16780712;
pub const XKB_KEY_Sinh_dda: u32 = 16780713;
pub const XKB_KEY_Sinh_ddha: u32 = 16780714;
pub const XKB_KEY_Sinh_nna: u32 = 16780715;
pub const XKB_KEY_Sinh_ndda: u32 = 16780716;
pub const XKB_KEY_Sinh_tha: u32 = 16780717;
pub const XKB_KEY_Sinh_thha: u32 = 16780718;
pub const XKB_KEY_Sinh_dha: u32 = 16780719;
pub const XKB_KEY_Sinh_dhha: u32 = 16780720;
pub const XKB_KEY_Sinh_na: u32 = 16780721;
pub const XKB_KEY_Sinh_ndha: u32 = 16780723;
pub const XKB_KEY_Sinh_pa: u32 = 16780724;
pub const XKB_KEY_Sinh_pha: u32 = 16780725;
pub const XKB_KEY_Sinh_ba: u32 = 16780726;
pub const XKB_KEY_Sinh_bha: u32 = 16780727;
pub const XKB_KEY_Sinh_ma: u32 = 16780728;
pub const XKB_KEY_Sinh_mba: u32 = 16780729;
pub const XKB_KEY_Sinh_ya: u32 = 16780730;
pub const XKB_KEY_Sinh_ra: u32 = 16780731;
pub const XKB_KEY_Sinh_la: u32 = 16780733;
pub const XKB_KEY_Sinh_va: u32 = 16780736;
pub const XKB_KEY_Sinh_sha: u32 = 16780737;
pub const XKB_KEY_Sinh_ssha: u32 = 16780738;
pub const XKB_KEY_Sinh_sa: u32 = 16780739;
pub const XKB_KEY_Sinh_ha: u32 = 16780740;
pub const XKB_KEY_Sinh_lla: u32 = 16780741;
pub const XKB_KEY_Sinh_fa: u32 = 16780742;
pub const XKB_KEY_Sinh_al: u32 = 16780746;
pub const XKB_KEY_Sinh_aa2: u32 = 16780751;
pub const XKB_KEY_Sinh_ae2: u32 = 16780752;
pub const XKB_KEY_Sinh_aee2: u32 = 16780753;
pub const XKB_KEY_Sinh_i2: u32 = 16780754;
pub const XKB_KEY_Sinh_ii2: u32 = 16780755;
pub const XKB_KEY_Sinh_u2: u32 = 16780756;
pub const XKB_KEY_Sinh_uu2: u32 = 16780758;
pub const XKB_KEY_Sinh_ru2: u32 = 16780760;
pub const XKB_KEY_Sinh_e2: u32 = 16780761;
pub const XKB_KEY_Sinh_ee2: u32 = 16780762;
pub const XKB_KEY_Sinh_ai2: u32 = 16780763;
pub const XKB_KEY_Sinh_o2: u32 = 16780764;
pub const XKB_KEY_Sinh_oo2: u32 = 16780765;
pub const XKB_KEY_Sinh_au2: u32 = 16780766;
pub const XKB_KEY_Sinh_lu2: u32 = 16780767;
pub const XKB_KEY_Sinh_ruu2: u32 = 16780786;
pub const XKB_KEY_Sinh_luu2: u32 = 16780787;
pub const XKB_KEY_Sinh_kunddaliya: u32 = 16780788;
pub const XKB_KEY_XF86ModeLock: u32 = 269025025;
pub const XKB_KEY_XF86MonBrightnessUp: u32 = 269025026;
pub const XKB_KEY_XF86MonBrightnessDown: u32 = 269025027;
pub const XKB_KEY_XF86KbdLightOnOff: u32 = 269025028;
pub const XKB_KEY_XF86KbdBrightnessUp: u32 = 269025029;
pub const XKB_KEY_XF86KbdBrightnessDown: u32 = 269025030;
pub const XKB_KEY_XF86MonBrightnessCycle: u32 = 269025031;
pub const XKB_KEY_XF86Standby: u32 = 269025040;
pub const XKB_KEY_XF86AudioLowerVolume: u32 = 269025041;
pub const XKB_KEY_XF86AudioMute: u32 = 269025042;
pub const XKB_KEY_XF86AudioRaiseVolume: u32 = 269025043;
pub const XKB_KEY_XF86AudioPlay: u32 = 269025044;
pub const XKB_KEY_XF86AudioStop: u32 = 269025045;
pub const XKB_KEY_XF86AudioPrev: u32 = 269025046;
pub const XKB_KEY_XF86AudioNext: u32 = 269025047;
pub const XKB_KEY_XF86HomePage: u32 = 269025048;
pub const XKB_KEY_XF86Mail: u32 = 269025049;
pub const XKB_KEY_XF86Start: u32 = 269025050;
pub const XKB_KEY_XF86Search: u32 = 269025051;
pub const XKB_KEY_XF86AudioRecord: u32 = 269025052;
pub const XKB_KEY_XF86Calculator: u32 = 269025053;
pub const XKB_KEY_XF86Memo: u32 = 269025054;
pub const XKB_KEY_XF86ToDoList: u32 = 269025055;
pub const XKB_KEY_XF86Calendar: u32 = 269025056;
pub const XKB_KEY_XF86PowerDown: u32 = 269025057;
pub const XKB_KEY_XF86ContrastAdjust: u32 = 269025058;
pub const XKB_KEY_XF86RockerUp: u32 = 269025059;
pub const XKB_KEY_XF86RockerDown: u32 = 269025060;
pub const XKB_KEY_XF86RockerEnter: u32 = 269025061;
pub const XKB_KEY_XF86Back: u32 = 269025062;
pub const XKB_KEY_XF86Forward: u32 = 269025063;
pub const XKB_KEY_XF86Stop: u32 = 269025064;
pub const XKB_KEY_XF86Refresh: u32 = 269025065;
pub const XKB_KEY_XF86PowerOff: u32 = 269025066;
pub const XKB_KEY_XF86WakeUp: u32 = 269025067;
pub const XKB_KEY_XF86Eject: u32 = 269025068;
pub const XKB_KEY_XF86ScreenSaver: u32 = 269025069;
pub const XKB_KEY_XF86WWW: u32 = 269025070;
pub const XKB_KEY_XF86Sleep: u32 = 269025071;
pub const XKB_KEY_XF86Favorites: u32 = 269025072;
pub const XKB_KEY_XF86AudioPause: u32 = 269025073;
pub const XKB_KEY_XF86AudioMedia: u32 = 269025074;
pub const XKB_KEY_XF86MyComputer: u32 = 269025075;
pub const XKB_KEY_XF86VendorHome: u32 = 269025076;
pub const XKB_KEY_XF86LightBulb: u32 = 269025077;
pub const XKB_KEY_XF86Shop: u32 = 269025078;
pub const XKB_KEY_XF86History: u32 = 269025079;
pub const XKB_KEY_XF86OpenURL: u32 = 269025080;
pub const XKB_KEY_XF86AddFavorite: u32 = 269025081;
pub const XKB_KEY_XF86HotLinks: u32 = 269025082;
pub const XKB_KEY_XF86BrightnessAdjust: u32 = 269025083;
pub const XKB_KEY_XF86Finance: u32 = 269025084;
pub const XKB_KEY_XF86Community: u32 = 269025085;
pub const XKB_KEY_XF86AudioRewind: u32 = 269025086;
pub const XKB_KEY_XF86BackForward: u32 = 269025087;
pub const XKB_KEY_XF86Launch0: u32 = 269025088;
pub const XKB_KEY_XF86Launch1: u32 = 269025089;
pub const XKB_KEY_XF86Launch2: u32 = 269025090;
pub const XKB_KEY_XF86Launch3: u32 = 269025091;
pub const XKB_KEY_XF86Launch4: u32 = 269025092;
pub const XKB_KEY_XF86Launch5: u32 = 269025093;
pub const XKB_KEY_XF86Launch6: u32 = 269025094;
pub const XKB_KEY_XF86Launch7: u32 = 269025095;
pub const XKB_KEY_XF86Launch8: u32 = 269025096;
pub const XKB_KEY_XF86Launch9: u32 = 269025097;
pub const XKB_KEY_XF86LaunchA: u32 = 269025098;
pub const XKB_KEY_XF86LaunchB: u32 = 269025099;
pub const XKB_KEY_XF86LaunchC: u32 = 269025100;
pub const XKB_KEY_XF86LaunchD: u32 = 269025101;
pub const XKB_KEY_XF86LaunchE: u32 = 269025102;
pub const XKB_KEY_XF86LaunchF: u32 = 269025103;
pub const XKB_KEY_XF86ApplicationLeft: u32 = 269025104;
pub const XKB_KEY_XF86ApplicationRight: u32 = 269025105;
pub const XKB_KEY_XF86Book: u32 = 269025106;
pub const XKB_KEY_XF86CD: u32 = 269025107;
pub const XKB_KEY_XF86Calculater: u32 = 269025108;
pub const XKB_KEY_XF86Clear: u32 = 269025109;
pub const XKB_KEY_XF86Close: u32 = 269025110;
pub const XKB_KEY_XF86Copy: u32 = 269025111;
pub const XKB_KEY_XF86Cut: u32 = 269025112;
pub const XKB_KEY_XF86Display: u32 = 269025113;
pub const XKB_KEY_XF86DOS: u32 = 269025114;
pub const XKB_KEY_XF86Documents: u32 = 269025115;
pub const XKB_KEY_XF86Excel: u32 = 269025116;
pub const XKB_KEY_XF86Explorer: u32 = 269025117;
pub const XKB_KEY_XF86Game: u32 = 269025118;
pub const XKB_KEY_XF86Go: u32 = 269025119;
pub const XKB_KEY_XF86iTouch: u32 = 269025120;
pub const XKB_KEY_XF86LogOff: u32 = 269025121;
pub const XKB_KEY_XF86Market: u32 = 269025122;
pub const XKB_KEY_XF86Meeting: u32 = 269025123;
pub const XKB_KEY_XF86MenuKB: u32 = 269025125;
pub const XKB_KEY_XF86MenuPB: u32 = 269025126;
pub const XKB_KEY_XF86MySites: u32 = 269025127;
pub const XKB_KEY_XF86New: u32 = 269025128;
pub const XKB_KEY_XF86News: u32 = 269025129;
pub const XKB_KEY_XF86OfficeHome: u32 = 269025130;
pub const XKB_KEY_XF86Open: u32 = 269025131;
pub const XKB_KEY_XF86Option: u32 = 269025132;
pub const XKB_KEY_XF86Paste: u32 = 269025133;
pub const XKB_KEY_XF86Phone: u32 = 269025134;
pub const XKB_KEY_XF86Q: u32 = 269025136;
pub const XKB_KEY_XF86Reply: u32 = 269025138;
pub const XKB_KEY_XF86Reload: u32 = 269025139;
pub const XKB_KEY_XF86RotateWindows: u32 = 269025140;
pub const XKB_KEY_XF86RotationPB: u32 = 269025141;
pub const XKB_KEY_XF86RotationKB: u32 = 269025142;
pub const XKB_KEY_XF86Save: u32 = 269025143;
pub const XKB_KEY_XF86ScrollUp: u32 = 269025144;
pub const XKB_KEY_XF86ScrollDown: u32 = 269025145;
pub const XKB_KEY_XF86ScrollClick: u32 = 269025146;
pub const XKB_KEY_XF86Send: u32 = 269025147;
pub const XKB_KEY_XF86Spell: u32 = 269025148;
pub const XKB_KEY_XF86SplitScreen: u32 = 269025149;
pub const XKB_KEY_XF86Support: u32 = 269025150;
pub const XKB_KEY_XF86TaskPane: u32 = 269025151;
pub const XKB_KEY_XF86Terminal: u32 = 269025152;
pub const XKB_KEY_XF86Tools: u32 = 269025153;
pub const XKB_KEY_XF86Travel: u32 = 269025154;
pub const XKB_KEY_XF86UserPB: u32 = 269025156;
pub const XKB_KEY_XF86User1KB: u32 = 269025157;
pub const XKB_KEY_XF86User2KB: u32 = 269025158;
pub const XKB_KEY_XF86Video: u32 = 269025159;
pub const XKB_KEY_XF86WheelButton: u32 = 269025160;
pub const XKB_KEY_XF86Word: u32 = 269025161;
pub const XKB_KEY_XF86Xfer: u32 = 269025162;
pub const XKB_KEY_XF86ZoomIn: u32 = 269025163;
pub const XKB_KEY_XF86ZoomOut: u32 = 269025164;
pub const XKB_KEY_XF86Away: u32 = 269025165;
pub const XKB_KEY_XF86Messenger: u32 = 269025166;
pub const XKB_KEY_XF86WebCam: u32 = 269025167;
pub const XKB_KEY_XF86MailForward: u32 = 269025168;
pub const XKB_KEY_XF86Pictures: u32 = 269025169;
pub const XKB_KEY_XF86Music: u32 = 269025170;
pub const XKB_KEY_XF86Battery: u32 = 269025171;
pub const XKB_KEY_XF86Bluetooth: u32 = 269025172;
pub const XKB_KEY_XF86WLAN: u32 = 269025173;
pub const XKB_KEY_XF86UWB: u32 = 269025174;
pub const XKB_KEY_XF86AudioForward: u32 = 269025175;
pub const XKB_KEY_XF86AudioRepeat: u32 = 269025176;
pub const XKB_KEY_XF86AudioRandomPlay: u32 = 269025177;
pub const XKB_KEY_XF86Subtitle: u32 = 269025178;
pub const XKB_KEY_XF86AudioCycleTrack: u32 = 269025179;
pub const XKB_KEY_XF86CycleAngle: u32 = 269025180;
pub const XKB_KEY_XF86FrameBack: u32 = 269025181;
pub const XKB_KEY_XF86FrameForward: u32 = 269025182;
pub const XKB_KEY_XF86Time: u32 = 269025183;
pub const XKB_KEY_XF86Select: u32 = 269025184;
pub const XKB_KEY_XF86View: u32 = 269025185;
pub const XKB_KEY_XF86TopMenu: u32 = 269025186;
pub const XKB_KEY_XF86Red: u32 = 269025187;
pub const XKB_KEY_XF86Green: u32 = 269025188;
pub const XKB_KEY_XF86Yellow: u32 = 269025189;
pub const XKB_KEY_XF86Blue: u32 = 269025190;
pub const XKB_KEY_XF86Suspend: u32 = 269025191;
pub const XKB_KEY_XF86Hibernate: u32 = 269025192;
pub const XKB_KEY_XF86TouchpadToggle: u32 = 269025193;
pub const XKB_KEY_XF86TouchpadOn: u32 = 269025200;
pub const XKB_KEY_XF86TouchpadOff: u32 = 269025201;
pub const XKB_KEY_XF86AudioMicMute: u32 = 269025202;
pub const XKB_KEY_XF86Keyboard: u32 = 269025203;
pub const XKB_KEY_XF86WWAN: u32 = 269025204;
pub const XKB_KEY_XF86RFKill: u32 = 269025205;
pub const XKB_KEY_XF86AudioPreset: u32 = 269025206;
pub const XKB_KEY_XF86RotationLockToggle: u32 = 269025207;
pub const XKB_KEY_XF86Switch_VT_1: u32 = 269024769;
pub const XKB_KEY_XF86Switch_VT_2: u32 = 269024770;
pub const XKB_KEY_XF86Switch_VT_3: u32 = 269024771;
pub const XKB_KEY_XF86Switch_VT_4: u32 = 269024772;
pub const XKB_KEY_XF86Switch_VT_5: u32 = 269024773;
pub const XKB_KEY_XF86Switch_VT_6: u32 = 269024774;
pub const XKB_KEY_XF86Switch_VT_7: u32 = 269024775;
pub const XKB_KEY_XF86Switch_VT_8: u32 = 269024776;
pub const XKB_KEY_XF86Switch_VT_9: u32 = 269024777;
pub const XKB_KEY_XF86Switch_VT_10: u32 = 269024778;
pub const XKB_KEY_XF86Switch_VT_11: u32 = 269024779;
pub const XKB_KEY_XF86Switch_VT_12: u32 = 269024780;
pub const XKB_KEY_XF86Ungrab: u32 = 269024800;
pub const XKB_KEY_XF86ClearGrab: u32 = 269024801;
pub const XKB_KEY_XF86Next_VMode: u32 = 269024802;
pub const XKB_KEY_XF86Prev_VMode: u32 = 269024803;
pub const XKB_KEY_XF86LogWindowTree: u32 = 269024804;
pub const XKB_KEY_XF86LogGrabInfo: u32 = 269024805;
pub const XKB_KEY_SunFA_Grave: u32 = 268828416;
pub const XKB_KEY_SunFA_Circum: u32 = 268828417;
pub const XKB_KEY_SunFA_Tilde: u32 = 268828418;
pub const XKB_KEY_SunFA_Acute: u32 = 268828419;
pub const XKB_KEY_SunFA_Diaeresis: u32 = 268828420;
pub const XKB_KEY_SunFA_Cedilla: u32 = 268828421;
pub const XKB_KEY_SunF36: u32 = 268828432;
pub const XKB_KEY_SunF37: u32 = 268828433;
pub const XKB_KEY_SunSys_Req: u32 = 268828512;
pub const XKB_KEY_SunPrint_Screen: u32 = 65377;
pub const XKB_KEY_SunCompose: u32 = 65312;
pub const XKB_KEY_SunAltGraph: u32 = 65406;
pub const XKB_KEY_SunPageUp: u32 = 65365;
pub const XKB_KEY_SunPageDown: u32 = 65366;
pub const XKB_KEY_SunUndo: u32 = 65381;
pub const XKB_KEY_SunAgain: u32 = 65382;
pub const XKB_KEY_SunFind: u32 = 65384;
pub const XKB_KEY_SunStop: u32 = 65385;
pub const XKB_KEY_SunProps: u32 = 268828528;
pub const XKB_KEY_SunFront: u32 = 268828529;
pub const XKB_KEY_SunCopy: u32 = 268828530;
pub const XKB_KEY_SunOpen: u32 = 268828531;
pub const XKB_KEY_SunPaste: u32 = 268828532;
pub const XKB_KEY_SunCut: u32 = 268828533;
pub const XKB_KEY_SunPowerSwitch: u32 = 268828534;
pub const XKB_KEY_SunAudioLowerVolume: u32 = 268828535;
pub const XKB_KEY_SunAudioMute: u32 = 268828536;
pub const XKB_KEY_SunAudioRaiseVolume: u32 = 268828537;
pub const XKB_KEY_SunVideoDegauss: u32 = 268828538;
pub const XKB_KEY_SunVideoLowerBrightness: u32 = 268828539;
pub const XKB_KEY_SunVideoRaiseBrightness: u32 = 268828540;
pub const XKB_KEY_SunPowerSwitchShift: u32 = 268828541;
pub const XKB_KEY_Dring_accent: u32 = 268500656;
pub const XKB_KEY_Dcircumflex_accent: u32 = 268500574;
pub const XKB_KEY_Dcedilla_accent: u32 = 268500524;
pub const XKB_KEY_Dacute_accent: u32 = 268500519;
pub const XKB_KEY_Dgrave_accent: u32 = 268500576;
pub const XKB_KEY_Dtilde: u32 = 268500606;
pub const XKB_KEY_Ddiaeresis: u32 = 268500514;
pub const XKB_KEY_DRemove: u32 = 268500736;
pub const XKB_KEY_hpClearLine: u32 = 268500847;
pub const XKB_KEY_hpInsertLine: u32 = 268500848;
pub const XKB_KEY_hpDeleteLine: u32 = 268500849;
pub const XKB_KEY_hpInsertChar: u32 = 268500850;
pub const XKB_KEY_hpDeleteChar: u32 = 268500851;
pub const XKB_KEY_hpBackTab: u32 = 268500852;
pub const XKB_KEY_hpKP_BackTab: u32 = 268500853;
pub const XKB_KEY_hpModelock1: u32 = 268500808;
pub const XKB_KEY_hpModelock2: u32 = 268500809;
pub const XKB_KEY_hpReset: u32 = 268500844;
pub const XKB_KEY_hpSystem: u32 = 268500845;
pub const XKB_KEY_hpUser: u32 = 268500846;
pub const XKB_KEY_hpmute_acute: u32 = 268435624;
pub const XKB_KEY_hpmute_grave: u32 = 268435625;
pub const XKB_KEY_hpmute_asciicircum: u32 = 268435626;
pub const XKB_KEY_hpmute_diaeresis: u32 = 268435627;
pub const XKB_KEY_hpmute_asciitilde: u32 = 268435628;
pub const XKB_KEY_hplira: u32 = 268435631;
pub const XKB_KEY_hpguilder: u32 = 268435646;
pub const XKB_KEY_hpYdiaeresis: u32 = 268435694;
pub const XKB_KEY_hpIO: u32 = 268435694;
pub const XKB_KEY_hplongminus: u32 = 268435702;
pub const XKB_KEY_hpblock: u32 = 268435708;
pub const XKB_KEY_osfCopy: u32 = 268762882;
pub const XKB_KEY_osfCut: u32 = 268762883;
pub const XKB_KEY_osfPaste: u32 = 268762884;
pub const XKB_KEY_osfBackTab: u32 = 268762887;
pub const XKB_KEY_osfBackSpace: u32 = 268762888;
pub const XKB_KEY_osfClear: u32 = 268762891;
pub const XKB_KEY_osfEscape: u32 = 268762907;
pub const XKB_KEY_osfAddMode: u32 = 268762929;
pub const XKB_KEY_osfPrimaryPaste: u32 = 268762930;
pub const XKB_KEY_osfQuickPaste: u32 = 268762931;
pub const XKB_KEY_osfPageLeft: u32 = 268762944;
pub const XKB_KEY_osfPageUp: u32 = 268762945;
pub const XKB_KEY_osfPageDown: u32 = 268762946;
pub const XKB_KEY_osfPageRight: u32 = 268762947;
pub const XKB_KEY_osfActivate: u32 = 268762948;
pub const XKB_KEY_osfMenuBar: u32 = 268762949;
pub const XKB_KEY_osfLeft: u32 = 268762961;
pub const XKB_KEY_osfUp: u32 = 268762962;
pub const XKB_KEY_osfRight: u32 = 268762963;
pub const XKB_KEY_osfDown: u32 = 268762964;
pub const XKB_KEY_osfEndLine: u32 = 268762967;
pub const XKB_KEY_osfBeginLine: u32 = 268762968;
pub const XKB_KEY_osfEndData: u32 = 268762969;
pub const XKB_KEY_osfBeginData: u32 = 268762970;
pub const XKB_KEY_osfPrevMenu: u32 = 268762971;
pub const XKB_KEY_osfNextMenu: u32 = 268762972;
pub const XKB_KEY_osfPrevField: u32 = 268762973;
pub const XKB_KEY_osfNextField: u32 = 268762974;
pub const XKB_KEY_osfSelect: u32 = 268762976;
pub const XKB_KEY_osfInsert: u32 = 268762979;
pub const XKB_KEY_osfUndo: u32 = 268762981;
pub const XKB_KEY_osfMenu: u32 = 268762983;
pub const XKB_KEY_osfCancel: u32 = 268762985;
pub const XKB_KEY_osfHelp: u32 = 268762986;
pub const XKB_KEY_osfSelectAll: u32 = 268762993;
pub const XKB_KEY_osfDeselectAll: u32 = 268762994;
pub const XKB_KEY_osfReselect: u32 = 268762995;
pub const XKB_KEY_osfExtend: u32 = 268762996;
pub const XKB_KEY_osfRestore: u32 = 268763000;
pub const XKB_KEY_osfDelete: u32 = 268763135;
pub const XKB_KEY_Reset: u32 = 268500844;
pub const XKB_KEY_System: u32 = 268500845;
pub const XKB_KEY_User: u32 = 268500846;
pub const XKB_KEY_ClearLine: u32 = 268500847;
pub const XKB_KEY_InsertLine: u32 = 268500848;
pub const XKB_KEY_DeleteLine: u32 = 268500849;
pub const XKB_KEY_InsertChar: u32 = 268500850;
pub const XKB_KEY_DeleteChar: u32 = 268500851;
pub const XKB_KEY_BackTab: u32 = 268500852;
pub const XKB_KEY_KP_BackTab: u32 = 268500853;
pub const XKB_KEY_Ext16bit_L: u32 = 268500854;
pub const XKB_KEY_Ext16bit_R: u32 = 268500855;
pub const XKB_KEY_mute_acute: u32 = 268435624;
pub const XKB_KEY_mute_grave: u32 = 268435625;
pub const XKB_KEY_mute_asciicircum: u32 = 268435626;
pub const XKB_KEY_mute_diaeresis: u32 = 268435627;
pub const XKB_KEY_mute_asciitilde: u32 = 268435628;
pub const XKB_KEY_lira: u32 = 268435631;
pub const XKB_KEY_guilder: u32 = 268435646;
pub const XKB_KEY_IO: u32 = 268435694;
pub const XKB_KEY_longminus: u32 = 268435702;
pub const XKB_KEY_block: u32 = 268435708;
pub const XKB_KEYCODE_INVALID: u32 = 4294967295;
pub const XKB_LAYOUT_INVALID: u32 = 4294967295;
pub const XKB_LEVEL_INVALID: u32 = 4294967295;
pub const XKB_MOD_INVALID: u32 = 4294967295;
pub const XKB_LED_INVALID: u32 = 4294967295;
pub const XKB_KEYCODE_MAX: u32 = 4294967294;
pub const XKB_GROUP_INVALID: u32 = 4294967295;
pub const NK_BINDINGS_NUM_MODIFIERS: u32 = 6;
pub const NK_BINDINGS_SCROLL_NUM_AXIS: u32 = 2;
pub type size_t = cty::c_ulong;
pub type wchar_t = cty::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: cty::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::core::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::core::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type gint8 = cty::c_schar;
pub type guint8 = cty::c_uchar;
pub type gint16 = cty::c_short;
pub type guint16 = cty::c_ushort;
pub type gint32 = cty::c_int;
pub type guint32 = cty::c_uint;
pub type gint64 = cty::c_long;
pub type guint64 = cty::c_ulong;
pub type gssize = cty::c_long;
pub type gsize = cty::c_ulong;
pub type goffset = gint64;
pub type gintptr = cty::c_long;
pub type guintptr = cty::c_ulong;
pub type GPid = cty::c_int;
pub type __u_char = cty::c_uchar;
pub type __u_short = cty::c_ushort;
pub type __u_int = cty::c_uint;
pub type __u_long = cty::c_ulong;
pub type __int8_t = cty::c_schar;
pub type __uint8_t = cty::c_uchar;
pub type __int16_t = cty::c_short;
pub type __uint16_t = cty::c_ushort;
pub type __int32_t = cty::c_int;
pub type __uint32_t = cty::c_uint;
pub type __int64_t = cty::c_long;
pub type __uint64_t = cty::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = cty::c_long;
pub type __u_quad_t = cty::c_ulong;
pub type __intmax_t = cty::c_long;
pub type __uintmax_t = cty::c_ulong;
pub type __dev_t = cty::c_ulong;
pub type __uid_t = cty::c_uint;
pub type __gid_t = cty::c_uint;
pub type __ino_t = cty::c_ulong;
pub type __ino64_t = cty::c_ulong;
pub type __mode_t = cty::c_uint;
pub type __nlink_t = cty::c_ulong;
pub type __off_t = cty::c_long;
pub type __off64_t = cty::c_long;
pub type __pid_t = cty::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [cty::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::core::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = cty::c_long;
pub type __rlim_t = cty::c_ulong;
pub type __rlim64_t = cty::c_ulong;
pub type __id_t = cty::c_uint;
pub type __time_t = cty::c_long;
pub type __useconds_t = cty::c_uint;
pub type __suseconds_t = cty::c_long;
pub type __daddr_t = cty::c_int;
pub type __key_t = cty::c_int;
pub type __clockid_t = cty::c_int;
pub type __timer_t = *mut cty::c_void;
pub type __blksize_t = cty::c_long;
pub type __blkcnt_t = cty::c_long;
pub type __blkcnt64_t = cty::c_long;
pub type __fsblkcnt_t = cty::c_ulong;
pub type __fsblkcnt64_t = cty::c_ulong;
pub type __fsfilcnt_t = cty::c_ulong;
pub type __fsfilcnt64_t = cty::c_ulong;
pub type __fsword_t = cty::c_long;
pub type __ssize_t = cty::c_long;
pub type __syscall_slong_t = cty::c_long;
pub type __syscall_ulong_t = cty::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut cty::c_char;
pub type __intptr_t = cty::c_long;
pub type __socklen_t = cty::c_uint;
pub type __sig_atomic_t = cty::c_int;
pub type clock_t = __clock_t;
pub type time_t = __time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: cty::c_int,
    pub tm_min: cty::c_int,
    pub tm_hour: cty::c_int,
    pub tm_mday: cty::c_int,
    pub tm_mon: cty::c_int,
    pub tm_year: cty::c_int,
    pub tm_wday: cty::c_int,
    pub tm_yday: cty::c_int,
    pub tm_isdst: cty::c_int,
    pub tm_gmtoff: cty::c_long,
    pub tm_zone: *const cty::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::core::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::core::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_gmtoff as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_zone as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::core::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::core::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(
        ::core::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::core::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<itimerspec>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<itimerspec>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
pub type pid_t = __pid_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const cty::c_ushort,
    pub __ctype_tolower: *const cty::c_int,
    pub __ctype_toupper: *const cty::c_int,
    pub __names: [*const cty::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::core::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__locale_struct>())).__locales as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__locale_struct>())).__ctype_b as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__locale_struct>())).__ctype_tolower as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__locale_struct>())).__ctype_toupper as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__locale_struct>())).__names as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        __s: *mut cty::c_char,
        __maxsize: size_t,
        __format: *const cty::c_char,
        __tp: *const tm,
    ) -> size_t;
}
extern "C" {
    pub fn strftime_l(
        __s: *mut cty::c_char,
        __maxsize: size_t,
        __format: *const cty::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut cty::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut cty::c_char;
}
extern "C" {
    pub fn asctime_r(__tp: *const tm, __buf: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn ctime_r(__timer: *const time_t, __buf: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub static mut __tzname: [*mut cty::c_char; 2usize];
}
extern "C" {
    pub static mut __daylight: cty::c_int;
}
extern "C" {
    pub static mut __timezone: cty::c_long;
}
extern "C" {
    pub static mut tzname: [*mut cty::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub static mut daylight: cty::c_int;
}
extern "C" {
    pub static mut timezone: cty::c_long;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn nanosleep(__requested_time: *const timespec, __remaining: *mut timespec) -> cty::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> cty::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> cty::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> cty::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: cty::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> cty::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> cty::c_int;
}
extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> cty::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: cty::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> cty::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> cty::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> cty::c_int;
}
extern "C" {
    pub fn timespec_get(__ts: *mut timespec, __base: cty::c_int) -> cty::c_int;
}
pub type gchar = cty::c_char;
pub type gshort = cty::c_short;
pub type glong = cty::c_long;
pub type gint = cty::c_int;
pub type gboolean = gint;
pub type guchar = cty::c_uchar;
pub type gushort = cty::c_ushort;
pub type gulong = cty::c_ulong;
pub type guint = cty::c_uint;
pub type gfloat = f32;
pub type gdouble = f64;
pub type gpointer = *mut cty::c_void;
pub type gconstpointer = *const cty::c_void;
pub type GCompareFunc =
    ::core::option::Option<unsafe extern "C" fn(a: gconstpointer, b: gconstpointer) -> gint>;
pub type GCompareDataFunc = ::core::option::Option<
    unsafe extern "C" fn(a: gconstpointer, b: gconstpointer, user_data: gpointer) -> gint,
>;
pub type GEqualFunc =
    ::core::option::Option<unsafe extern "C" fn(a: gconstpointer, b: gconstpointer) -> gboolean>;
pub type GDestroyNotify = ::core::option::Option<unsafe extern "C" fn(data: gpointer)>;
pub type GFunc = ::core::option::Option<unsafe extern "C" fn(data: gpointer, user_data: gpointer)>;
pub type GHashFunc = ::core::option::Option<unsafe extern "C" fn(key: gconstpointer) -> guint>;
pub type GHFunc = ::core::option::Option<
    unsafe extern "C" fn(key: gpointer, value: gpointer, user_data: gpointer),
>;
#[doc = " GCopyFunc:"]
#[doc = " @src: (not nullable): A pointer to the data which should be copied"]
#[doc = " @data: Additional data"]
#[doc = ""]
#[doc = " A function of this signature is used to copy the node data"]
#[doc = " when doing a deep-copy of a tree."]
#[doc = ""]
#[doc = " Returns: (not nullable): A pointer to the copy"]
#[doc = ""]
#[doc = " Since: 2.4"]
pub type GCopyFunc =
    ::core::option::Option<unsafe extern "C" fn(src: gconstpointer, data: gpointer) -> gpointer>;
#[doc = " GFreeFunc:"]
#[doc = " @data: a data pointer"]
#[doc = ""]
#[doc = " Declares a type of function which takes an arbitrary"]
#[doc = " data pointer argument and has no return value. It is"]
#[doc = " not currently used in GLib or GTK+."]
pub type GFreeFunc = ::core::option::Option<unsafe extern "C" fn(data: gpointer)>;
#[doc = " GTranslateFunc:"]
#[doc = " @str: the untranslated string"]
#[doc = " @data: user data specified when installing the function, e.g."]
#[doc = "  in g_option_group_set_translate_func()"]
#[doc = ""]
#[doc = " The type of functions which are used to translate user-visible"]
#[doc = " strings, for <option>--help</option> output."]
#[doc = ""]
#[doc = " Returns: a translation of the string for the current locale."]
#[doc = "  The returned string is owned by GLib and must not be freed."]
pub type GTranslateFunc = ::core::option::Option<
    unsafe extern "C" fn(str_: *const gchar, data: gpointer) -> *const gchar,
>;
pub type GDoubleIEEE754 = _GDoubleIEEE754;
pub type GFloatIEEE754 = _GFloatIEEE754;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GFloatIEEE754 {
    pub v_float: gfloat,
    pub mpn: _GFloatIEEE754__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _GFloatIEEE754__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout__GFloatIEEE754__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_GFloatIEEE754__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_GFloatIEEE754__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_GFloatIEEE754__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_GFloatIEEE754__bindgen_ty_1))
    );
}
impl _GFloatIEEE754__bindgen_ty_1 {
    #[inline]
    pub fn mantissa(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_mantissa(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn biased_exponent(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_biased_exponent(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn sign(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sign(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mantissa: guint,
        biased_exponent: guint,
        sign: guint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 23u8, {
            let mantissa: u32 = unsafe { ::core::mem::transmute(mantissa) };
            mantissa as u64
        });
        __bindgen_bitfield_unit.set(23usize, 8u8, {
            let biased_exponent: u32 = unsafe { ::core::mem::transmute(biased_exponent) };
            biased_exponent as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let sign: u32 = unsafe { ::core::mem::transmute(sign) };
            sign as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__GFloatIEEE754() {
    assert_eq!(
        ::core::mem::size_of::<_GFloatIEEE754>(),
        4usize,
        concat!("Size of: ", stringify!(_GFloatIEEE754))
    );
    assert_eq!(
        ::core::mem::align_of::<_GFloatIEEE754>(),
        4usize,
        concat!("Alignment of ", stringify!(_GFloatIEEE754))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GFloatIEEE754>())).v_float as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFloatIEEE754),
            "::",
            stringify!(v_float)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GFloatIEEE754>())).mpn as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFloatIEEE754),
            "::",
            stringify!(mpn)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GDoubleIEEE754 {
    pub v_double: gdouble,
    pub mpn: _GDoubleIEEE754__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _GDoubleIEEE754__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u32>,
}
#[test]
fn bindgen_test_layout__GDoubleIEEE754__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_GDoubleIEEE754__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_GDoubleIEEE754__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_GDoubleIEEE754__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_GDoubleIEEE754__bindgen_ty_1))
    );
}
impl _GDoubleIEEE754__bindgen_ty_1 {
    #[inline]
    pub fn mantissa_low(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_mantissa_low(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn mantissa_high(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_mantissa_high(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn biased_exponent(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(52usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_biased_exponent(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(52usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn sign(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(63usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sign(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(63usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mantissa_low: guint,
        mantissa_high: guint,
        biased_exponent: guint,
        sign: guint,
    ) -> __BindgenBitfieldUnit<[u8; 8usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let mantissa_low: u32 = unsafe { ::core::mem::transmute(mantissa_low) };
            mantissa_low as u64
        });
        __bindgen_bitfield_unit.set(32usize, 20u8, {
            let mantissa_high: u32 = unsafe { ::core::mem::transmute(mantissa_high) };
            mantissa_high as u64
        });
        __bindgen_bitfield_unit.set(52usize, 11u8, {
            let biased_exponent: u32 = unsafe { ::core::mem::transmute(biased_exponent) };
            biased_exponent as u64
        });
        __bindgen_bitfield_unit.set(63usize, 1u8, {
            let sign: u32 = unsafe { ::core::mem::transmute(sign) };
            sign as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__GDoubleIEEE754() {
    assert_eq!(
        ::core::mem::size_of::<_GDoubleIEEE754>(),
        8usize,
        concat!("Size of: ", stringify!(_GDoubleIEEE754))
    );
    assert_eq!(
        ::core::mem::align_of::<_GDoubleIEEE754>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDoubleIEEE754))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GDoubleIEEE754>())).v_double as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDoubleIEEE754),
            "::",
            stringify!(v_double)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GDoubleIEEE754>())).mpn as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDoubleIEEE754),
            "::",
            stringify!(mpn)
        )
    );
}
pub type GTimeVal = _GTimeVal;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTimeVal {
    pub tv_sec: glong,
    pub tv_usec: glong,
}
#[test]
fn bindgen_test_layout__GTimeVal() {
    assert_eq!(
        ::core::mem::size_of::<_GTimeVal>(),
        16usize,
        concat!("Size of: ", stringify!(_GTimeVal))
    );
    assert_eq!(
        ::core::mem::align_of::<_GTimeVal>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTimeVal))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GTimeVal>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTimeVal),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GTimeVal>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTimeVal),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub type grefcount = gint;
pub type gatomicrefcount = gint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBytes {
    _unused: [u8; 0],
}
pub type GBytes = _GBytes;
pub type GArray = _GArray;
pub type GByteArray = _GByteArray;
pub type GPtrArray = _GPtrArray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GArray {
    pub data: *mut gchar,
    pub len: guint,
}
#[test]
fn bindgen_test_layout__GArray() {
    assert_eq!(
        ::core::mem::size_of::<_GArray>(),
        16usize,
        concat!("Size of: ", stringify!(_GArray))
    );
    assert_eq!(
        ::core::mem::align_of::<_GArray>(),
        8usize,
        concat!("Alignment of ", stringify!(_GArray))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GArray>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GArray),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GArray>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GArray),
            "::",
            stringify!(len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GByteArray {
    pub data: *mut guint8,
    pub len: guint,
}
#[test]
fn bindgen_test_layout__GByteArray() {
    assert_eq!(
        ::core::mem::size_of::<_GByteArray>(),
        16usize,
        concat!("Size of: ", stringify!(_GByteArray))
    );
    assert_eq!(
        ::core::mem::align_of::<_GByteArray>(),
        8usize,
        concat!("Alignment of ", stringify!(_GByteArray))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GByteArray>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GByteArray),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GByteArray>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GByteArray),
            "::",
            stringify!(len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPtrArray {
    pub pdata: *mut gpointer,
    pub len: guint,
}
#[test]
fn bindgen_test_layout__GPtrArray() {
    assert_eq!(
        ::core::mem::size_of::<_GPtrArray>(),
        16usize,
        concat!("Size of: ", stringify!(_GPtrArray))
    );
    assert_eq!(
        ::core::mem::align_of::<_GPtrArray>(),
        8usize,
        concat!("Alignment of ", stringify!(_GPtrArray))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GPtrArray>())).pdata as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPtrArray),
            "::",
            stringify!(pdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GPtrArray>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPtrArray),
            "::",
            stringify!(len)
        )
    );
}
extern "C" {
    pub fn g_array_new(
        zero_terminated: gboolean,
        clear_: gboolean,
        element_size: guint,
    ) -> *mut GArray;
}
extern "C" {
    pub fn g_array_steal(array: *mut GArray, len: *mut gsize) -> gpointer;
}
extern "C" {
    pub fn g_array_sized_new(
        zero_terminated: gboolean,
        clear_: gboolean,
        element_size: guint,
        reserved_size: guint,
    ) -> *mut GArray;
}
extern "C" {
    pub fn g_array_copy(array: *mut GArray) -> *mut GArray;
}
extern "C" {
    pub fn g_array_free(array: *mut GArray, free_segment: gboolean) -> *mut gchar;
}
extern "C" {
    pub fn g_array_ref(array: *mut GArray) -> *mut GArray;
}
extern "C" {
    pub fn g_array_unref(array: *mut GArray);
}
extern "C" {
    pub fn g_array_get_element_size(array: *mut GArray) -> guint;
}
extern "C" {
    pub fn g_array_append_vals(array: *mut GArray, data: gconstpointer, len: guint) -> *mut GArray;
}
extern "C" {
    pub fn g_array_prepend_vals(array: *mut GArray, data: gconstpointer, len: guint)
        -> *mut GArray;
}
extern "C" {
    pub fn g_array_insert_vals(
        array: *mut GArray,
        index_: guint,
        data: gconstpointer,
        len: guint,
    ) -> *mut GArray;
}
extern "C" {
    pub fn g_array_set_size(array: *mut GArray, length: guint) -> *mut GArray;
}
extern "C" {
    pub fn g_array_remove_index(array: *mut GArray, index_: guint) -> *mut GArray;
}
extern "C" {
    pub fn g_array_remove_index_fast(array: *mut GArray, index_: guint) -> *mut GArray;
}
extern "C" {
    pub fn g_array_remove_range(array: *mut GArray, index_: guint, length: guint) -> *mut GArray;
}
extern "C" {
    pub fn g_array_sort(array: *mut GArray, compare_func: GCompareFunc);
}
extern "C" {
    pub fn g_array_sort_with_data(
        array: *mut GArray,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_array_binary_search(
        array: *mut GArray,
        target: gconstpointer,
        compare_func: GCompareFunc,
        out_match_index: *mut guint,
    ) -> gboolean;
}
extern "C" {
    pub fn g_array_set_clear_func(array: *mut GArray, clear_func: GDestroyNotify);
}
extern "C" {
    pub fn g_ptr_array_new() -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_new_with_free_func(element_free_func: GDestroyNotify) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_steal(array: *mut GPtrArray, len: *mut gsize) -> *mut gpointer;
}
extern "C" {
    pub fn g_ptr_array_copy(
        array: *mut GPtrArray,
        func: GCopyFunc,
        user_data: gpointer,
    ) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_sized_new(reserved_size: guint) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_new_full(
        reserved_size: guint,
        element_free_func: GDestroyNotify,
    ) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_free(array: *mut GPtrArray, free_seg: gboolean) -> *mut gpointer;
}
extern "C" {
    pub fn g_ptr_array_ref(array: *mut GPtrArray) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_unref(array: *mut GPtrArray);
}
extern "C" {
    pub fn g_ptr_array_set_free_func(array: *mut GPtrArray, element_free_func: GDestroyNotify);
}
extern "C" {
    pub fn g_ptr_array_set_size(array: *mut GPtrArray, length: gint);
}
extern "C" {
    pub fn g_ptr_array_remove_index(array: *mut GPtrArray, index_: guint) -> gpointer;
}
extern "C" {
    pub fn g_ptr_array_remove_index_fast(array: *mut GPtrArray, index_: guint) -> gpointer;
}
extern "C" {
    pub fn g_ptr_array_steal_index(array: *mut GPtrArray, index_: guint) -> gpointer;
}
extern "C" {
    pub fn g_ptr_array_steal_index_fast(array: *mut GPtrArray, index_: guint) -> gpointer;
}
extern "C" {
    pub fn g_ptr_array_remove(array: *mut GPtrArray, data: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_ptr_array_remove_fast(array: *mut GPtrArray, data: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_ptr_array_remove_range(
        array: *mut GPtrArray,
        index_: guint,
        length: guint,
    ) -> *mut GPtrArray;
}
extern "C" {
    pub fn g_ptr_array_add(array: *mut GPtrArray, data: gpointer);
}
extern "C" {
    pub fn g_ptr_array_extend(
        array_to_extend: *mut GPtrArray,
        array: *mut GPtrArray,
        func: GCopyFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_ptr_array_extend_and_steal(array_to_extend: *mut GPtrArray, array: *mut GPtrArray);
}
extern "C" {
    pub fn g_ptr_array_insert(array: *mut GPtrArray, index_: gint, data: gpointer);
}
extern "C" {
    pub fn g_ptr_array_sort(array: *mut GPtrArray, compare_func: GCompareFunc);
}
extern "C" {
    pub fn g_ptr_array_sort_with_data(
        array: *mut GPtrArray,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_ptr_array_foreach(array: *mut GPtrArray, func: GFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_ptr_array_find(
        haystack: *mut GPtrArray,
        needle: gconstpointer,
        index_: *mut guint,
    ) -> gboolean;
}
extern "C" {
    pub fn g_ptr_array_find_with_equal_func(
        haystack: *mut GPtrArray,
        needle: gconstpointer,
        equal_func: GEqualFunc,
        index_: *mut guint,
    ) -> gboolean;
}
extern "C" {
    pub fn g_byte_array_new() -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_new_take(data: *mut guint8, len: gsize) -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_steal(array: *mut GByteArray, len: *mut gsize) -> *mut guint8;
}
extern "C" {
    pub fn g_byte_array_sized_new(reserved_size: guint) -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_free(array: *mut GByteArray, free_segment: gboolean) -> *mut guint8;
}
extern "C" {
    pub fn g_byte_array_free_to_bytes(array: *mut GByteArray) -> *mut GBytes;
}
extern "C" {
    pub fn g_byte_array_ref(array: *mut GByteArray) -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_unref(array: *mut GByteArray);
}
extern "C" {
    pub fn g_byte_array_append(
        array: *mut GByteArray,
        data: *const guint8,
        len: guint,
    ) -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_prepend(
        array: *mut GByteArray,
        data: *const guint8,
        len: guint,
    ) -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_set_size(array: *mut GByteArray, length: guint) -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_remove_index(array: *mut GByteArray, index_: guint) -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_remove_index_fast(array: *mut GByteArray, index_: guint)
        -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_remove_range(
        array: *mut GByteArray,
        index_: guint,
        length: guint,
    ) -> *mut GByteArray;
}
extern "C" {
    pub fn g_byte_array_sort(array: *mut GByteArray, compare_func: GCompareFunc);
}
extern "C" {
    pub fn g_byte_array_sort_with_data(
        array: *mut GByteArray,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_atomic_int_get(atomic: *const gint) -> gint;
}
extern "C" {
    pub fn g_atomic_int_set(atomic: *mut gint, newval: gint);
}
extern "C" {
    pub fn g_atomic_int_inc(atomic: *mut gint);
}
extern "C" {
    pub fn g_atomic_int_dec_and_test(atomic: *mut gint) -> gboolean;
}
extern "C" {
    pub fn g_atomic_int_compare_and_exchange(
        atomic: *mut gint,
        oldval: gint,
        newval: gint,
    ) -> gboolean;
}
extern "C" {
    pub fn g_atomic_int_add(atomic: *mut gint, val: gint) -> gint;
}
extern "C" {
    pub fn g_atomic_int_and(atomic: *mut guint, val: guint) -> guint;
}
extern "C" {
    pub fn g_atomic_int_or(atomic: *mut guint, val: guint) -> guint;
}
extern "C" {
    pub fn g_atomic_int_xor(atomic: *mut guint, val: guint) -> guint;
}
extern "C" {
    pub fn g_atomic_pointer_get(atomic: *const cty::c_void) -> gpointer;
}
extern "C" {
    pub fn g_atomic_pointer_set(atomic: *mut cty::c_void, newval: gpointer);
}
extern "C" {
    pub fn g_atomic_pointer_compare_and_exchange(
        atomic: *mut cty::c_void,
        oldval: gpointer,
        newval: gpointer,
    ) -> gboolean;
}
extern "C" {
    pub fn g_atomic_pointer_add(atomic: *mut cty::c_void, val: gssize) -> gssize;
}
extern "C" {
    pub fn g_atomic_pointer_and(atomic: *mut cty::c_void, val: gsize) -> gsize;
}
extern "C" {
    pub fn g_atomic_pointer_or(atomic: *mut cty::c_void, val: gsize) -> gsize;
}
extern "C" {
    pub fn g_atomic_pointer_xor(atomic: *mut cty::c_void, val: gsize) -> gsize;
}
extern "C" {
    pub fn g_atomic_int_exchange_and_add(atomic: *mut gint, val: gint) -> gint;
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type GQuark = guint32;
extern "C" {
    pub fn g_quark_try_string(string: *const gchar) -> GQuark;
}
extern "C" {
    pub fn g_quark_from_static_string(string: *const gchar) -> GQuark;
}
extern "C" {
    pub fn g_quark_from_string(string: *const gchar) -> GQuark;
}
extern "C" {
    pub fn g_quark_to_string(quark: GQuark) -> *const gchar;
}
extern "C" {
    pub fn g_intern_string(string: *const gchar) -> *const gchar;
}
extern "C" {
    pub fn g_intern_static_string(string: *const gchar) -> *const gchar;
}
#[doc = " GError:"]
#[doc = " @domain: error domain, e.g. #G_FILE_ERROR"]
#[doc = " @code: error code, e.g. %G_FILE_ERROR_NOENT"]
#[doc = " @message: human-readable informative error message"]
#[doc = ""]
#[doc = " The `GError` structure contains information about"]
#[doc = " an error that has occurred."]
pub type GError = _GError;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GError {
    pub domain: GQuark,
    pub code: gint,
    pub message: *mut gchar,
}
#[test]
fn bindgen_test_layout__GError() {
    assert_eq!(
        ::core::mem::size_of::<_GError>(),
        16usize,
        concat!("Size of: ", stringify!(_GError))
    );
    assert_eq!(
        ::core::mem::align_of::<_GError>(),
        8usize,
        concat!("Alignment of ", stringify!(_GError))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GError>())).domain as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GError),
            "::",
            stringify!(domain)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GError>())).code as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_GError),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GError>())).message as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GError),
            "::",
            stringify!(message)
        )
    );
}
extern "C" {
    pub fn g_error_new(domain: GQuark, code: gint, format: *const gchar, ...) -> *mut GError;
}
extern "C" {
    pub fn g_error_new_literal(domain: GQuark, code: gint, message: *const gchar) -> *mut GError;
}
extern "C" {
    pub fn g_error_new_valist(
        domain: GQuark,
        code: gint,
        format: *const gchar,
        args: *mut __va_list_tag,
    ) -> *mut GError;
}
extern "C" {
    pub fn g_error_free(error: *mut GError);
}
extern "C" {
    pub fn g_error_copy(error: *const GError) -> *mut GError;
}
extern "C" {
    pub fn g_error_matches(error: *const GError, domain: GQuark, code: gint) -> gboolean;
}
extern "C" {
    pub fn g_set_error(
        err: *mut *mut GError,
        domain: GQuark,
        code: gint,
        format: *const gchar,
        ...
    );
}
extern "C" {
    pub fn g_set_error_literal(
        err: *mut *mut GError,
        domain: GQuark,
        code: gint,
        message: *const gchar,
    );
}
extern "C" {
    pub fn g_propagate_error(dest: *mut *mut GError, src: *mut GError);
}
extern "C" {
    pub fn g_clear_error(err: *mut *mut GError);
}
extern "C" {
    pub fn g_prefix_error(err: *mut *mut GError, format: *const gchar, ...);
}
extern "C" {
    pub fn g_propagate_prefixed_error(
        dest: *mut *mut GError,
        src: *mut GError,
        format: *const gchar,
        ...
    );
}
extern "C" {
    pub fn g_get_user_name() -> *const gchar;
}
extern "C" {
    pub fn g_get_real_name() -> *const gchar;
}
extern "C" {
    pub fn g_get_home_dir() -> *const gchar;
}
extern "C" {
    pub fn g_get_tmp_dir() -> *const gchar;
}
extern "C" {
    pub fn g_get_host_name() -> *const gchar;
}
extern "C" {
    pub fn g_get_prgname() -> *const gchar;
}
extern "C" {
    pub fn g_set_prgname(prgname: *const gchar);
}
extern "C" {
    pub fn g_get_application_name() -> *const gchar;
}
extern "C" {
    pub fn g_set_application_name(application_name: *const gchar);
}
extern "C" {
    pub fn g_get_os_info(key_name: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_reload_user_special_dirs_cache();
}
extern "C" {
    pub fn g_get_user_data_dir() -> *const gchar;
}
extern "C" {
    pub fn g_get_user_config_dir() -> *const gchar;
}
extern "C" {
    pub fn g_get_user_cache_dir() -> *const gchar;
}
extern "C" {
    pub fn g_get_system_data_dirs() -> *const *const gchar;
}
extern "C" {
    pub fn g_get_system_config_dirs() -> *const *const gchar;
}
extern "C" {
    pub fn g_get_user_runtime_dir() -> *const gchar;
}
pub const GUserDirectory_G_USER_DIRECTORY_DESKTOP: GUserDirectory = 0;
pub const GUserDirectory_G_USER_DIRECTORY_DOCUMENTS: GUserDirectory = 1;
pub const GUserDirectory_G_USER_DIRECTORY_DOWNLOAD: GUserDirectory = 2;
pub const GUserDirectory_G_USER_DIRECTORY_MUSIC: GUserDirectory = 3;
pub const GUserDirectory_G_USER_DIRECTORY_PICTURES: GUserDirectory = 4;
pub const GUserDirectory_G_USER_DIRECTORY_PUBLIC_SHARE: GUserDirectory = 5;
pub const GUserDirectory_G_USER_DIRECTORY_TEMPLATES: GUserDirectory = 6;
pub const GUserDirectory_G_USER_DIRECTORY_VIDEOS: GUserDirectory = 7;
pub const GUserDirectory_G_USER_N_DIRECTORIES: GUserDirectory = 8;
#[doc = " GUserDirectory:"]
#[doc = " @G_USER_DIRECTORY_DESKTOP: the user's Desktop directory"]
#[doc = " @G_USER_DIRECTORY_DOCUMENTS: the user's Documents directory"]
#[doc = " @G_USER_DIRECTORY_DOWNLOAD: the user's Downloads directory"]
#[doc = " @G_USER_DIRECTORY_MUSIC: the user's Music directory"]
#[doc = " @G_USER_DIRECTORY_PICTURES: the user's Pictures directory"]
#[doc = " @G_USER_DIRECTORY_PUBLIC_SHARE: the user's shared directory"]
#[doc = " @G_USER_DIRECTORY_TEMPLATES: the user's Templates directory"]
#[doc = " @G_USER_DIRECTORY_VIDEOS: the user's Movies directory"]
#[doc = " @G_USER_N_DIRECTORIES: the number of enum values"]
#[doc = ""]
#[doc = " These are logical ids for special directories which are defined"]
#[doc = " depending on the platform used. You should use g_get_user_special_dir()"]
#[doc = " to retrieve the full path associated to the logical id."]
#[doc = ""]
#[doc = " The #GUserDirectory enumeration can be extended at later date. Not"]
#[doc = " every platform has a directory for every logical id in this"]
#[doc = " enumeration."]
#[doc = ""]
#[doc = " Since: 2.14"]
pub type GUserDirectory = u32;
extern "C" {
    pub fn g_get_user_special_dir(directory: GUserDirectory) -> *const gchar;
}
#[doc = " GDebugKey:"]
#[doc = " @key: the string"]
#[doc = " @value: the flag"]
#[doc = ""]
#[doc = " Associates a string with a bit flag."]
#[doc = " Used in g_parse_debug_string()."]
pub type GDebugKey = _GDebugKey;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDebugKey {
    pub key: *const gchar,
    pub value: guint,
}
#[test]
fn bindgen_test_layout__GDebugKey() {
    assert_eq!(
        ::core::mem::size_of::<_GDebugKey>(),
        16usize,
        concat!("Size of: ", stringify!(_GDebugKey))
    );
    assert_eq!(
        ::core::mem::align_of::<_GDebugKey>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDebugKey))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GDebugKey>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDebugKey),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GDebugKey>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDebugKey),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    pub fn g_parse_debug_string(
        string: *const gchar,
        keys: *const GDebugKey,
        nkeys: guint,
    ) -> guint;
}
extern "C" {
    pub fn g_snprintf(string: *mut gchar, n: gulong, format: *const gchar, ...) -> gint;
}
extern "C" {
    pub fn g_vsnprintf(
        string: *mut gchar,
        n: gulong,
        format: *const gchar,
        args: *mut __va_list_tag,
    ) -> gint;
}
extern "C" {
    pub fn g_nullify_pointer(nullify_location: *mut gpointer);
}
pub const GFormatSizeFlags_G_FORMAT_SIZE_DEFAULT: GFormatSizeFlags = 0;
pub const GFormatSizeFlags_G_FORMAT_SIZE_LONG_FORMAT: GFormatSizeFlags = 1;
pub const GFormatSizeFlags_G_FORMAT_SIZE_IEC_UNITS: GFormatSizeFlags = 2;
pub const GFormatSizeFlags_G_FORMAT_SIZE_BITS: GFormatSizeFlags = 4;
pub type GFormatSizeFlags = u32;
extern "C" {
    pub fn g_format_size_full(size: guint64, flags: GFormatSizeFlags) -> *mut gchar;
}
extern "C" {
    pub fn g_format_size(size: guint64) -> *mut gchar;
}
extern "C" {
    pub fn g_format_size_for_display(size: goffset) -> *mut gchar;
}
#[doc = " GVoidFunc:"]
#[doc = ""]
#[doc = " Declares a type of function which takes no arguments"]
#[doc = " and has no return value. It is used to specify the type"]
#[doc = " function passed to g_atexit()."]
pub type GVoidFunc = ::core::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub fn g_atexit(func: GVoidFunc);
}
extern "C" {
    pub fn g_find_program_in_path(program: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_bit_nth_lsf(mask: gulong, nth_bit: gint) -> gint;
}
extern "C" {
    pub fn g_bit_nth_msf(mask: gulong, nth_bit: gint) -> gint;
}
extern "C" {
    pub fn g_bit_storage(number: gulong) -> guint;
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: cty::c_int,
    pub rem: cty::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::core::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::core::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<div_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<div_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: cty::c_long,
    pub rem: cty::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::core::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: cty::c_longlong,
    pub rem: cty::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::core::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> size_t;
}
extern "C" {
    pub fn atof(__nptr: *const cty::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const cty::c_char) -> cty::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const cty::c_char) -> cty::c_longlong;
}
extern "C" {
    pub fn strtod(__nptr: *const cty::c_char, __endptr: *mut *mut cty::c_char) -> f64;
}
extern "C" {
    pub fn strtof(__nptr: *const cty::c_char, __endptr: *mut *mut cty::c_char) -> f32;
}
extern "C" {
    pub fn strtold(__nptr: *const cty::c_char, __endptr: *mut *mut cty::c_char) -> u128;
}
extern "C" {
    pub fn strtol(
        __nptr: *const cty::c_char,
        __endptr: *mut *mut cty::c_char,
        __base: cty::c_int,
    ) -> cty::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const cty::c_char,
        __endptr: *mut *mut cty::c_char,
        __base: cty::c_int,
    ) -> cty::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const cty::c_char,
        __endptr: *mut *mut cty::c_char,
        __base: cty::c_int,
    ) -> cty::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const cty::c_char,
        __endptr: *mut *mut cty::c_char,
        __base: cty::c_int,
    ) -> cty::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const cty::c_char,
        __endptr: *mut *mut cty::c_char,
        __base: cty::c_int,
    ) -> cty::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const cty::c_char,
        __endptr: *mut *mut cty::c_char,
        __base: cty::c_int,
    ) -> cty::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: cty::c_long) -> *mut cty::c_char;
}
extern "C" {
    pub fn a64l(__s: *const cty::c_char) -> cty::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type id_t = __id_t;
pub type ssize_t = __ssize_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type ulong = cty::c_ulong;
pub type ushort = cty::c_ushort;
pub type uint = cty::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = cty::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [cty::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::core::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sigset_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::core::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::core::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = cty::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::core::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::core::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fd_set>())).__fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: cty::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: cty::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> cty::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::core::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    assert_eq!(
        ::core::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_internal_slist>())).__next as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: cty::c_int,
    pub __count: cty::c_uint,
    pub __owner: cty::c_int,
    pub __nusers: cty::c_uint,
    pub __kind: cty::c_int,
    pub __spins: cty::c_short,
    pub __elision: cty::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::core::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_mutex_s>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_mutex_s>())).__count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_mutex_s>())).__owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_mutex_s>())).__nusers as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_mutex_s>())).__kind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_mutex_s>())).__spins as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_mutex_s>())).__elision as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_mutex_s>())).__list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: cty::c_uint,
    pub __writers: cty::c_uint,
    pub __wrphase_futex: cty::c_uint,
    pub __writers_futex: cty::c_uint,
    pub __pad3: cty::c_uint,
    pub __pad4: cty::c_uint,
    pub __cur_writer: cty::c_int,
    pub __shared: cty::c_int,
    pub __rwelision: cty::c_schar,
    pub __pad1: [cty::c_uchar; 7usize],
    pub __pad2: cty::c_ulong,
    pub __flags: cty::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    assert_eq!(
        ::core::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__readers as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__writers as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__wrphase_futex as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__writers_futex as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__pad3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__pad4 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__cur_writer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__shared as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__rwelision as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__pad1 as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__pad2 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__flags as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [cty::c_uint; 2usize],
    pub __g_size: [cty::c_uint; 2usize],
    pub __g1_orig_size: cty::c_uint,
    pub __wrefs: cty::c_uint,
    pub __g_signals: [cty::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: cty::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: cty::c_uint,
    pub __high: cty::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq32 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq32)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: cty::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: cty::c_uint,
    pub __high: cty::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start32 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start32)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(
        ::core::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_cond_s>())).__g_refs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_cond_s>())).__g_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_cond_s>())).__g1_orig_size as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_cond_s>())).__wrefs as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_cond_s>())).__g_signals as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type pthread_t = cty::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [cty::c_char; 4usize],
    pub __align: cty::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_mutexattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_mutexattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [cty::c_char; 4usize],
    pub __align: cty::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_condattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_condattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = cty::c_uint;
pub type pthread_once_t = cty::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [cty::c_char; 56usize],
    pub __align: cty::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [cty::c_char; 40usize],
    pub __align: cty::c_long,
    _bindgen_union_align: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [cty::c_char; 48usize],
    pub __align: cty::c_longlong,
    _bindgen_union_align: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_cond_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_cond_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_cond_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [cty::c_char; 56usize],
    pub __align: cty::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_rwlock_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_rwlock_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_rwlock_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [cty::c_char; 8usize],
    pub __align: cty::c_long,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_rwlockattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_rwlockattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = cty::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [cty::c_char; 32usize],
    pub __align: cty::c_long,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_barrier_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_barrier_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [cty::c_char; 4usize],
    pub __align: cty::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_barrierattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_barrierattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
extern "C" {
    pub fn random() -> cty::c_long;
}
extern "C" {
    pub fn srandom(__seed: cty::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: cty::c_uint,
        __statebuf: *mut cty::c_char,
        __statelen: size_t,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut cty::c_char) -> *mut cty::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: cty::c_int,
    pub rand_deg: cty::c_int,
    pub rand_sep: cty::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(
        ::core::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::core::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<random_data>())).fptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<random_data>())).rptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<random_data>())).state as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<random_data>())).rand_type as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<random_data>())).rand_deg as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<random_data>())).rand_sep as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<random_data>())).end_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> cty::c_int;
}
extern "C" {
    pub fn srandom_r(__seed: cty::c_uint, __buf: *mut random_data) -> cty::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: cty::c_uint,
        __statebuf: *mut cty::c_char,
        __statelen: size_t,
        __buf: *mut random_data,
    ) -> cty::c_int;
}
extern "C" {
    pub fn setstate_r(__statebuf: *mut cty::c_char, __buf: *mut random_data) -> cty::c_int;
}
extern "C" {
    pub fn rand() -> cty::c_int;
}
extern "C" {
    pub fn srand(__seed: cty::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut cty::c_uint) -> cty::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut cty::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> cty::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut cty::c_ushort) -> cty::c_long;
}
extern "C" {
    pub fn mrand48() -> cty::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut cty::c_ushort) -> cty::c_long;
}
extern "C" {
    pub fn srand48(__seedval: cty::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut cty::c_ushort) -> *mut cty::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut cty::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [cty::c_ushort; 3usize],
    pub __old_x: [cty::c_ushort; 3usize],
    pub __c: cty::c_ushort,
    pub __init: cty::c_ushort,
    pub __a: cty::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    assert_eq!(
        ::core::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::core::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<drand48_data>())).__x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<drand48_data>())).__old_x as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<drand48_data>())).__c as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<drand48_data>())).__init as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<drand48_data>())).__a as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> cty::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut cty::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> cty::c_int;
}
extern "C" {
    pub fn lrand48_r(__buffer: *mut drand48_data, __result: *mut cty::c_long) -> cty::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut cty::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut cty::c_long,
    ) -> cty::c_int;
}
extern "C" {
    pub fn mrand48_r(__buffer: *mut drand48_data, __result: *mut cty::c_long) -> cty::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut cty::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut cty::c_long,
    ) -> cty::c_int;
}
extern "C" {
    pub fn srand48_r(__seedval: cty::c_long, __buffer: *mut drand48_data) -> cty::c_int;
}
extern "C" {
    pub fn seed48_r(__seed16v: *mut cty::c_ushort, __buffer: *mut drand48_data) -> cty::c_int;
}
extern "C" {
    pub fn lcong48_r(__param: *mut cty::c_ushort, __buffer: *mut drand48_data) -> cty::c_int;
}
extern "C" {
    pub fn malloc(__size: cty::c_ulong) -> *mut cty::c_void;
}
extern "C" {
    pub fn calloc(__nmemb: cty::c_ulong, __size: cty::c_ulong) -> *mut cty::c_void;
}
extern "C" {
    pub fn realloc(__ptr: *mut cty::c_void, __size: cty::c_ulong) -> *mut cty::c_void;
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut cty::c_void,
        __nmemb: size_t,
        __size: size_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut cty::c_void);
}
extern "C" {
    pub fn alloca(__size: cty::c_ulong) -> *mut cty::c_void;
}
extern "C" {
    pub fn valloc(__size: size_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut cty::c_void,
        __alignment: size_t,
        __size: size_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn aligned_alloc(__alignment: size_t, __size: size_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::core::option::Option<unsafe extern "C" fn()>) -> cty::c_int;
}
extern "C" {
    pub fn at_quick_exit(__func: ::core::option::Option<unsafe extern "C" fn()>) -> cty::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::core::option::Option<
            unsafe extern "C" fn(__status: cty::c_int, __arg: *mut cty::c_void),
        >,
        __arg: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    pub fn exit(__status: cty::c_int);
}
extern "C" {
    pub fn quick_exit(__status: cty::c_int);
}
extern "C" {
    pub fn _Exit(__status: cty::c_int);
}
extern "C" {
    pub fn getenv(__name: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const cty::c_char,
        __value: *const cty::c_char,
        __replace: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn clearenv() -> cty::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn mkstemps(__template: *mut cty::c_char, __suffixlen: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn system(__command: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn realpath(__name: *const cty::c_char, __resolved: *mut cty::c_char) -> *mut cty::c_char;
}
pub type __compar_fn_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *const cty::c_void, arg2: *const cty::c_void) -> cty::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const cty::c_void,
        __base: *const cty::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut cty::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn labs(__x: cty::c_long) -> cty::c_long;
}
extern "C" {
    pub fn llabs(__x: cty::c_longlong) -> cty::c_longlong;
}
extern "C" {
    pub fn div(__numer: cty::c_int, __denom: cty::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: cty::c_long, __denom: cty::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(__numer: cty::c_longlong, __denom: cty::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: cty::c_int,
        __decpt: *mut cty::c_int,
        __sign: *mut cty::c_int,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: cty::c_int,
        __decpt: *mut cty::c_int,
        __sign: *mut cty::c_int,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn gcvt(__value: f64, __ndigit: cty::c_int, __buf: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: cty::c_int,
        __decpt: *mut cty::c_int,
        __sign: *mut cty::c_int,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: cty::c_int,
        __decpt: *mut cty::c_int,
        __sign: *mut cty::c_int,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn qgcvt(__value: u128, __ndigit: cty::c_int, __buf: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: cty::c_int,
        __decpt: *mut cty::c_int,
        __sign: *mut cty::c_int,
        __buf: *mut cty::c_char,
        __len: size_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: cty::c_int,
        __decpt: *mut cty::c_int,
        __sign: *mut cty::c_int,
        __buf: *mut cty::c_char,
        __len: size_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: cty::c_int,
        __decpt: *mut cty::c_int,
        __sign: *mut cty::c_int,
        __buf: *mut cty::c_char,
        __len: size_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: cty::c_int,
        __decpt: *mut cty::c_int,
        __sign: *mut cty::c_int,
        __buf: *mut cty::c_char,
        __len: size_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn mblen(__s: *const cty::c_char, __n: size_t) -> cty::c_int;
}
extern "C" {
    pub fn mbtowc(__pwc: *mut wchar_t, __s: *const cty::c_char, __n: size_t) -> cty::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut cty::c_char, __wchar: wchar_t) -> cty::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const cty::c_char, __n: size_t) -> size_t;
}
extern "C" {
    pub fn wcstombs(__s: *mut cty::c_char, __pwcs: *const wchar_t, __n: size_t) -> size_t;
}
extern "C" {
    pub fn rpmatch(__response: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut cty::c_char,
        __tokens: *const *mut cty::c_char,
        __valuep: *mut *mut cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn g_thread_error_quark() -> GQuark;
}
pub const GThreadError_G_THREAD_ERROR_AGAIN: GThreadError = 0;
pub type GThreadError = u32;
pub type GThreadFunc = ::core::option::Option<unsafe extern "C" fn(data: gpointer) -> gpointer>;
pub type GThread = _GThread;
pub type GMutex = _GMutex;
pub type GRecMutex = _GRecMutex;
pub type GRWLock = _GRWLock;
pub type GCond = _GCond;
pub type GPrivate = _GPrivate;
pub type GOnce = _GOnce;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GMutex {
    pub p: gpointer,
    pub i: [guint; 2usize],
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__GMutex() {
    assert_eq!(
        ::core::mem::size_of::<_GMutex>(),
        8usize,
        concat!("Size of: ", stringify!(_GMutex))
    );
    assert_eq!(
        ::core::mem::align_of::<_GMutex>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMutex))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GMutex>())).p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMutex),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GMutex>())).i as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMutex),
            "::",
            stringify!(i)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRWLock {
    pub p: gpointer,
    pub i: [guint; 2usize],
}
#[test]
fn bindgen_test_layout__GRWLock() {
    assert_eq!(
        ::core::mem::size_of::<_GRWLock>(),
        16usize,
        concat!("Size of: ", stringify!(_GRWLock))
    );
    assert_eq!(
        ::core::mem::align_of::<_GRWLock>(),
        8usize,
        concat!("Alignment of ", stringify!(_GRWLock))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GRWLock>())).p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GRWLock),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GRWLock>())).i as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GRWLock),
            "::",
            stringify!(i)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCond {
    pub p: gpointer,
    pub i: [guint; 2usize],
}
#[test]
fn bindgen_test_layout__GCond() {
    assert_eq!(
        ::core::mem::size_of::<_GCond>(),
        16usize,
        concat!("Size of: ", stringify!(_GCond))
    );
    assert_eq!(
        ::core::mem::align_of::<_GCond>(),
        8usize,
        concat!("Alignment of ", stringify!(_GCond))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GCond>())).p as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_GCond), "::", stringify!(p))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GCond>())).i as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(_GCond), "::", stringify!(i))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRecMutex {
    pub p: gpointer,
    pub i: [guint; 2usize],
}
#[test]
fn bindgen_test_layout__GRecMutex() {
    assert_eq!(
        ::core::mem::size_of::<_GRecMutex>(),
        16usize,
        concat!("Size of: ", stringify!(_GRecMutex))
    );
    assert_eq!(
        ::core::mem::align_of::<_GRecMutex>(),
        8usize,
        concat!("Alignment of ", stringify!(_GRecMutex))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GRecMutex>())).p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GRecMutex),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GRecMutex>())).i as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GRecMutex),
            "::",
            stringify!(i)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPrivate {
    pub p: gpointer,
    pub notify: GDestroyNotify,
    pub future: [gpointer; 2usize],
}
#[test]
fn bindgen_test_layout__GPrivate() {
    assert_eq!(
        ::core::mem::size_of::<_GPrivate>(),
        32usize,
        concat!("Size of: ", stringify!(_GPrivate))
    );
    assert_eq!(
        ::core::mem::align_of::<_GPrivate>(),
        8usize,
        concat!("Alignment of ", stringify!(_GPrivate))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GPrivate>())).p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPrivate),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GPrivate>())).notify as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPrivate),
            "::",
            stringify!(notify)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GPrivate>())).future as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPrivate),
            "::",
            stringify!(future)
        )
    );
}
pub const GOnceStatus_G_ONCE_STATUS_NOTCALLED: GOnceStatus = 0;
pub const GOnceStatus_G_ONCE_STATUS_PROGRESS: GOnceStatus = 1;
pub const GOnceStatus_G_ONCE_STATUS_READY: GOnceStatus = 2;
pub type GOnceStatus = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOnce {
    pub status: GOnceStatus,
    pub retval: gpointer,
}
#[test]
fn bindgen_test_layout__GOnce() {
    assert_eq!(
        ::core::mem::size_of::<_GOnce>(),
        16usize,
        concat!("Size of: ", stringify!(_GOnce))
    );
    assert_eq!(
        ::core::mem::align_of::<_GOnce>(),
        8usize,
        concat!("Alignment of ", stringify!(_GOnce))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GOnce>())).status as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOnce),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GOnce>())).retval as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOnce),
            "::",
            stringify!(retval)
        )
    );
}
extern "C" {
    pub fn g_thread_ref(thread: *mut GThread) -> *mut GThread;
}
extern "C" {
    pub fn g_thread_unref(thread: *mut GThread);
}
extern "C" {
    pub fn g_thread_new(name: *const gchar, func: GThreadFunc, data: gpointer) -> *mut GThread;
}
extern "C" {
    pub fn g_thread_try_new(
        name: *const gchar,
        func: GThreadFunc,
        data: gpointer,
        error: *mut *mut GError,
    ) -> *mut GThread;
}
extern "C" {
    pub fn g_thread_self() -> *mut GThread;
}
extern "C" {
    pub fn g_thread_exit(retval: gpointer);
}
extern "C" {
    pub fn g_thread_join(thread: *mut GThread) -> gpointer;
}
extern "C" {
    pub fn g_thread_yield();
}
extern "C" {
    pub fn g_mutex_init(mutex: *mut GMutex);
}
extern "C" {
    pub fn g_mutex_clear(mutex: *mut GMutex);
}
extern "C" {
    pub fn g_mutex_lock(mutex: *mut GMutex);
}
extern "C" {
    pub fn g_mutex_trylock(mutex: *mut GMutex) -> gboolean;
}
extern "C" {
    pub fn g_mutex_unlock(mutex: *mut GMutex);
}
extern "C" {
    pub fn g_rw_lock_init(rw_lock: *mut GRWLock);
}
extern "C" {
    pub fn g_rw_lock_clear(rw_lock: *mut GRWLock);
}
extern "C" {
    pub fn g_rw_lock_writer_lock(rw_lock: *mut GRWLock);
}
extern "C" {
    pub fn g_rw_lock_writer_trylock(rw_lock: *mut GRWLock) -> gboolean;
}
extern "C" {
    pub fn g_rw_lock_writer_unlock(rw_lock: *mut GRWLock);
}
extern "C" {
    pub fn g_rw_lock_reader_lock(rw_lock: *mut GRWLock);
}
extern "C" {
    pub fn g_rw_lock_reader_trylock(rw_lock: *mut GRWLock) -> gboolean;
}
extern "C" {
    pub fn g_rw_lock_reader_unlock(rw_lock: *mut GRWLock);
}
extern "C" {
    pub fn g_rec_mutex_init(rec_mutex: *mut GRecMutex);
}
extern "C" {
    pub fn g_rec_mutex_clear(rec_mutex: *mut GRecMutex);
}
extern "C" {
    pub fn g_rec_mutex_lock(rec_mutex: *mut GRecMutex);
}
extern "C" {
    pub fn g_rec_mutex_trylock(rec_mutex: *mut GRecMutex) -> gboolean;
}
extern "C" {
    pub fn g_rec_mutex_unlock(rec_mutex: *mut GRecMutex);
}
extern "C" {
    pub fn g_cond_init(cond: *mut GCond);
}
extern "C" {
    pub fn g_cond_clear(cond: *mut GCond);
}
extern "C" {
    pub fn g_cond_wait(cond: *mut GCond, mutex: *mut GMutex);
}
extern "C" {
    pub fn g_cond_signal(cond: *mut GCond);
}
extern "C" {
    pub fn g_cond_broadcast(cond: *mut GCond);
}
extern "C" {
    pub fn g_cond_wait_until(cond: *mut GCond, mutex: *mut GMutex, end_time: gint64) -> gboolean;
}
extern "C" {
    pub fn g_private_get(key: *mut GPrivate) -> gpointer;
}
extern "C" {
    pub fn g_private_set(key: *mut GPrivate, value: gpointer);
}
extern "C" {
    pub fn g_private_replace(key: *mut GPrivate, value: gpointer);
}
extern "C" {
    pub fn g_once_impl(once: *mut GOnce, func: GThreadFunc, arg: gpointer) -> gpointer;
}
extern "C" {
    pub fn g_once_init_enter(location: *mut cty::c_void) -> gboolean;
}
extern "C" {
    pub fn g_once_init_leave(location: *mut cty::c_void, result: gsize);
}
extern "C" {
    pub fn g_get_num_processors() -> guint;
}
#[doc = " GMutexLocker:"]
#[doc = ""]
#[doc = " Opaque type. See g_mutex_locker_new() for details."]
#[doc = " Since: 2.44"]
pub type GMutexLocker = cty::c_void;
#[doc = " GRecMutexLocker:"]
#[doc = ""]
#[doc = " Opaque type. See g_rec_mutex_locker_new() for details."]
#[doc = " Since: 2.60"]
pub type GRecMutexLocker = cty::c_void;
#[doc = " GRWLockWriterLocker:"]
#[doc = ""]
#[doc = " Opaque type. See g_rw_lock_writer_locker_new() for details."]
#[doc = " Since: 2.62"]
pub type GRWLockWriterLocker = cty::c_void;
#[doc = " GRWLockReaderLocker:"]
#[doc = ""]
#[doc = " Opaque type. See g_rw_lock_reader_locker_new() for details."]
#[doc = " Since: 2.62"]
pub type GRWLockReaderLocker = cty::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAsyncQueue {
    _unused: [u8; 0],
}
pub type GAsyncQueue = _GAsyncQueue;
extern "C" {
    pub fn g_async_queue_new() -> *mut GAsyncQueue;
}
extern "C" {
    pub fn g_async_queue_new_full(item_free_func: GDestroyNotify) -> *mut GAsyncQueue;
}
extern "C" {
    pub fn g_async_queue_lock(queue: *mut GAsyncQueue);
}
extern "C" {
    pub fn g_async_queue_unlock(queue: *mut GAsyncQueue);
}
extern "C" {
    pub fn g_async_queue_ref(queue: *mut GAsyncQueue) -> *mut GAsyncQueue;
}
extern "C" {
    pub fn g_async_queue_unref(queue: *mut GAsyncQueue);
}
extern "C" {
    pub fn g_async_queue_ref_unlocked(queue: *mut GAsyncQueue);
}
extern "C" {
    pub fn g_async_queue_unref_and_unlock(queue: *mut GAsyncQueue);
}
extern "C" {
    pub fn g_async_queue_push(queue: *mut GAsyncQueue, data: gpointer);
}
extern "C" {
    pub fn g_async_queue_push_unlocked(queue: *mut GAsyncQueue, data: gpointer);
}
extern "C" {
    pub fn g_async_queue_push_sorted(
        queue: *mut GAsyncQueue,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_async_queue_push_sorted_unlocked(
        queue: *mut GAsyncQueue,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_async_queue_pop(queue: *mut GAsyncQueue) -> gpointer;
}
extern "C" {
    pub fn g_async_queue_pop_unlocked(queue: *mut GAsyncQueue) -> gpointer;
}
extern "C" {
    pub fn g_async_queue_try_pop(queue: *mut GAsyncQueue) -> gpointer;
}
extern "C" {
    pub fn g_async_queue_try_pop_unlocked(queue: *mut GAsyncQueue) -> gpointer;
}
extern "C" {
    pub fn g_async_queue_timeout_pop(queue: *mut GAsyncQueue, timeout: guint64) -> gpointer;
}
extern "C" {
    pub fn g_async_queue_timeout_pop_unlocked(
        queue: *mut GAsyncQueue,
        timeout: guint64,
    ) -> gpointer;
}
extern "C" {
    pub fn g_async_queue_length(queue: *mut GAsyncQueue) -> gint;
}
extern "C" {
    pub fn g_async_queue_length_unlocked(queue: *mut GAsyncQueue) -> gint;
}
extern "C" {
    pub fn g_async_queue_sort(queue: *mut GAsyncQueue, func: GCompareDataFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_async_queue_sort_unlocked(
        queue: *mut GAsyncQueue,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_async_queue_remove(queue: *mut GAsyncQueue, item: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_async_queue_remove_unlocked(queue: *mut GAsyncQueue, item: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_async_queue_push_front(queue: *mut GAsyncQueue, item: gpointer);
}
extern "C" {
    pub fn g_async_queue_push_front_unlocked(queue: *mut GAsyncQueue, item: gpointer);
}
extern "C" {
    pub fn g_async_queue_timed_pop(queue: *mut GAsyncQueue, end_time: *mut GTimeVal) -> gpointer;
}
extern "C" {
    pub fn g_async_queue_timed_pop_unlocked(
        queue: *mut GAsyncQueue,
        end_time: *mut GTimeVal,
    ) -> gpointer;
}
pub type sig_atomic_t = __sig_atomic_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: cty::c_int,
    pub sival_ptr: *mut cty::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sigval() {
    assert_eq!(
        ::core::mem::size_of::<sigval>(),
        8usize,
        concat!("Size of: ", stringify!(sigval))
    );
    assert_eq!(
        ::core::mem::align_of::<sigval>(),
        8usize,
        concat!("Alignment of ", stringify!(sigval))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigval>())).sival_int as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_int)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigval>())).sival_ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_ptr)
        )
    );
}
pub type __sigval_t = sigval;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t {
    pub si_signo: cty::c_int,
    pub si_errno: cty::c_int,
    pub si_code: cty::c_int,
    pub __pad0: cty::c_int,
    pub _sifields: siginfo_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo_t__bindgen_ty_1 {
    pub _pad: [cty::c_int; 28usize],
    pub _kill: siginfo_t__bindgen_ty_1__bindgen_ty_1,
    pub _timer: siginfo_t__bindgen_ty_1__bindgen_ty_2,
    pub _rt: siginfo_t__bindgen_ty_1__bindgen_ty_3,
    pub _sigchld: siginfo_t__bindgen_ty_1__bindgen_ty_4,
    pub _sigfault: siginfo_t__bindgen_ty_1__bindgen_ty_5,
    pub _sigpoll: siginfo_t__bindgen_ty_1__bindgen_ty_6,
    pub _sigsys: siginfo_t__bindgen_ty_1__bindgen_ty_7,
    _bindgen_union_align: [u64; 14usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_1 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_1>())).si_pid as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(si_pid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_1>())).si_uid as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(si_uid)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_2 {
    pub si_tid: cty::c_int,
    pub si_overrun: cty::c_int,
    pub si_sigval: __sigval_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_2>())).si_tid as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(si_tid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_2>())).si_overrun
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(si_overrun)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_2>())).si_sigval as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(si_sigval)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_3 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_sigval: __sigval_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_3>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_3>())).si_pid as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(si_pid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_3>())).si_uid as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(si_uid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_3>())).si_sigval as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(si_sigval)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_4 {
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_status: cty::c_int,
    pub si_utime: __clock_t,
    pub si_stime: __clock_t,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::core::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_4>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_4>())).si_pid as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(si_pid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_4>())).si_uid as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(si_uid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_4>())).si_status as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(si_status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_4>())).si_utime as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(si_utime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_4>())).si_stime as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(si_stime)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5 {
    pub si_addr: *mut cty::c_void,
    pub si_addr_lsb: cty::c_short,
    pub _bounds: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    pub _addr_bnd: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
    pub _pkey: __uint32_t,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    pub _lower: *mut cty::c_void,
    pub _upper: *mut cty::c_void,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1>(
        ),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<
                siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
            >()))
            ._lower as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_lower)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<
                siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
            >()))
            ._upper as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_upper)
        )
    );
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>()))
                ._addr_bnd as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(_addr_bnd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>()))._pkey
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1),
            "::",
            stringify!(_pkey)
        )
    );
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_5() {
    assert_eq!(
        ::core::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_5>())).si_addr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(si_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_5>())).si_addr_lsb
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(si_addr_lsb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_5>()))._bounds as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(_bounds)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_6 {
    pub si_band: cty::c_long,
    pub si_fd: cty::c_int,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_6() {
    assert_eq!(
        ::core::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_6>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_6>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_6>())).si_band as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(si_band)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_6>())).si_fd as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(si_fd)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_7 {
    pub _call_addr: *mut cty::c_void,
    pub _syscall: cty::c_int,
    pub _arch: cty::c_uint,
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_7() {
    assert_eq!(
        ::core::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_7>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_7>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_7>()))._call_addr
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(_call_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_7>()))._syscall as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(_syscall)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_7>()))._arch as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(_arch)
        )
    );
}
#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<siginfo_t__bindgen_ty_1>(),
        112usize,
        concat!("Size of: ", stringify!(siginfo_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<siginfo_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(siginfo_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<siginfo_t__bindgen_ty_1>()))._pad as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<siginfo_t__bindgen_ty_1>()))._kill as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_kill)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<siginfo_t__bindgen_ty_1>()))._timer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<siginfo_t__bindgen_ty_1>()))._rt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_rt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo_t__bindgen_ty_1>()))._sigchld as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_sigchld)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo_t__bindgen_ty_1>()))._sigfault as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_sigfault)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo_t__bindgen_ty_1>()))._sigpoll as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_sigpoll)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<siginfo_t__bindgen_ty_1>()))._sigsys as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t__bindgen_ty_1),
            "::",
            stringify!(_sigsys)
        )
    );
}
#[test]
fn bindgen_test_layout_siginfo_t() {
    assert_eq!(
        ::core::mem::size_of::<siginfo_t>(),
        128usize,
        concat!("Size of: ", stringify!(siginfo_t))
    );
    assert_eq!(
        ::core::mem::align_of::<siginfo_t>(),
        8usize,
        concat!("Alignment of ", stringify!(siginfo_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<siginfo_t>())).si_signo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(si_signo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<siginfo_t>())).si_errno as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(si_errno)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<siginfo_t>())).si_code as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(si_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<siginfo_t>())).__pad0 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(__pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<siginfo_t>()))._sifields as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(siginfo_t),
            "::",
            stringify!(_sifields)
        )
    );
}
pub const SI_ASYNCNL: _bindgen_ty_1 = -60;
pub const SI_DETHREAD: _bindgen_ty_1 = -7;
pub const SI_TKILL: _bindgen_ty_1 = -6;
pub const SI_SIGIO: _bindgen_ty_1 = -5;
pub const SI_ASYNCIO: _bindgen_ty_1 = -4;
pub const SI_MESGQ: _bindgen_ty_1 = -3;
pub const SI_TIMER: _bindgen_ty_1 = -2;
pub const SI_QUEUE: _bindgen_ty_1 = -1;
pub const SI_USER: _bindgen_ty_1 = 0;
pub const SI_KERNEL: _bindgen_ty_1 = 128;
pub type _bindgen_ty_1 = i32;
pub const ILL_ILLOPC: _bindgen_ty_2 = 1;
pub const ILL_ILLOPN: _bindgen_ty_2 = 2;
pub const ILL_ILLADR: _bindgen_ty_2 = 3;
pub const ILL_ILLTRP: _bindgen_ty_2 = 4;
pub const ILL_PRVOPC: _bindgen_ty_2 = 5;
pub const ILL_PRVREG: _bindgen_ty_2 = 6;
pub const ILL_COPROC: _bindgen_ty_2 = 7;
pub const ILL_BADSTK: _bindgen_ty_2 = 8;
pub const ILL_BADIADDR: _bindgen_ty_2 = 9;
pub type _bindgen_ty_2 = u32;
pub const FPE_INTDIV: _bindgen_ty_3 = 1;
pub const FPE_INTOVF: _bindgen_ty_3 = 2;
pub const FPE_FLTDIV: _bindgen_ty_3 = 3;
pub const FPE_FLTOVF: _bindgen_ty_3 = 4;
pub const FPE_FLTUND: _bindgen_ty_3 = 5;
pub const FPE_FLTRES: _bindgen_ty_3 = 6;
pub const FPE_FLTINV: _bindgen_ty_3 = 7;
pub const FPE_FLTSUB: _bindgen_ty_3 = 8;
pub const FPE_FLTUNK: _bindgen_ty_3 = 14;
pub const FPE_CONDTRAP: _bindgen_ty_3 = 15;
pub type _bindgen_ty_3 = u32;
pub const SEGV_MAPERR: _bindgen_ty_4 = 1;
pub const SEGV_ACCERR: _bindgen_ty_4 = 2;
pub const SEGV_BNDERR: _bindgen_ty_4 = 3;
pub const SEGV_PKUERR: _bindgen_ty_4 = 4;
pub const SEGV_ACCADI: _bindgen_ty_4 = 5;
pub const SEGV_ADIDERR: _bindgen_ty_4 = 6;
pub const SEGV_ADIPERR: _bindgen_ty_4 = 7;
pub type _bindgen_ty_4 = u32;
pub const BUS_ADRALN: _bindgen_ty_5 = 1;
pub const BUS_ADRERR: _bindgen_ty_5 = 2;
pub const BUS_OBJERR: _bindgen_ty_5 = 3;
pub const BUS_MCEERR_AR: _bindgen_ty_5 = 4;
pub const BUS_MCEERR_AO: _bindgen_ty_5 = 5;
pub type _bindgen_ty_5 = u32;
pub const CLD_EXITED: _bindgen_ty_6 = 1;
pub const CLD_KILLED: _bindgen_ty_6 = 2;
pub const CLD_DUMPED: _bindgen_ty_6 = 3;
pub const CLD_TRAPPED: _bindgen_ty_6 = 4;
pub const CLD_STOPPED: _bindgen_ty_6 = 5;
pub const CLD_CONTINUED: _bindgen_ty_6 = 6;
pub type _bindgen_ty_6 = u32;
pub const POLL_IN: _bindgen_ty_7 = 1;
pub const POLL_OUT: _bindgen_ty_7 = 2;
pub const POLL_MSG: _bindgen_ty_7 = 3;
pub const POLL_ERR: _bindgen_ty_7 = 4;
pub const POLL_PRI: _bindgen_ty_7 = 5;
pub const POLL_HUP: _bindgen_ty_7 = 6;
pub type _bindgen_ty_7 = u32;
pub type sigval_t = __sigval_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_value: __sigval_t,
    pub sigev_signo: cty::c_int,
    pub sigev_notify: cty::c_int,
    pub _sigev_un: sigevent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigevent__bindgen_ty_1 {
    pub _pad: [cty::c_int; 12usize],
    pub _tid: __pid_t,
    pub _sigev_thread: sigevent__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u64; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent__bindgen_ty_1__bindgen_ty_1 {
    pub _function: ::core::option::Option<unsafe extern "C" fn(arg1: __sigval_t)>,
    pub _attribute: *mut pthread_attr_t,
}
#[test]
fn bindgen_test_layout_sigevent__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<sigevent__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sigevent__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sigevent__bindgen_ty_1__bindgen_ty_1>()))._function as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_function)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sigevent__bindgen_ty_1__bindgen_ty_1>()))._attribute as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_attribute)
        )
    );
}
#[test]
fn bindgen_test_layout_sigevent__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<sigevent__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(sigevent__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<sigevent__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigevent__bindgen_ty_1>()))._pad as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1),
            "::",
            stringify!(_pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigevent__bindgen_ty_1>()))._tid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1),
            "::",
            stringify!(_tid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sigevent__bindgen_ty_1>()))._sigev_thread as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent__bindgen_ty_1),
            "::",
            stringify!(_sigev_thread)
        )
    );
}
#[test]
fn bindgen_test_layout_sigevent() {
    assert_eq!(
        ::core::mem::size_of::<sigevent>(),
        64usize,
        concat!("Size of: ", stringify!(sigevent))
    );
    assert_eq!(
        ::core::mem::align_of::<sigevent>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigevent>())).sigev_value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigevent>())).sigev_signo as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_signo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigevent>())).sigev_notify as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigevent>()))._sigev_un as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(_sigev_un)
        )
    );
}
pub type sigevent_t = sigevent;
pub const SIGEV_SIGNAL: _bindgen_ty_8 = 0;
pub const SIGEV_NONE: _bindgen_ty_8 = 1;
pub const SIGEV_THREAD: _bindgen_ty_8 = 2;
pub const SIGEV_THREAD_ID: _bindgen_ty_8 = 4;
pub type _bindgen_ty_8 = u32;
pub type __sighandler_t = ::core::option::Option<unsafe extern "C" fn(arg1: cty::c_int)>;
extern "C" {
    pub fn __sysv_signal(__sig: cty::c_int, __handler: __sighandler_t) -> __sighandler_t;
}
extern "C" {
    pub fn signal(__sig: cty::c_int, __handler: __sighandler_t) -> __sighandler_t;
}
extern "C" {
    pub fn kill(__pid: __pid_t, __sig: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn killpg(__pgrp: __pid_t, __sig: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn raise(__sig: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn ssignal(__sig: cty::c_int, __handler: __sighandler_t) -> __sighandler_t;
}
extern "C" {
    pub fn gsignal(__sig: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn psignal(__sig: cty::c_int, __s: *const cty::c_char);
}
extern "C" {
    pub fn psiginfo(__pinfo: *const siginfo_t, __s: *const cty::c_char);
}
extern "C" {
    pub fn sigblock(__mask: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn sigsetmask(__mask: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn siggetmask() -> cty::c_int;
}
pub type sig_t = __sighandler_t;
extern "C" {
    pub fn sigemptyset(__set: *mut sigset_t) -> cty::c_int;
}
extern "C" {
    pub fn sigfillset(__set: *mut sigset_t) -> cty::c_int;
}
extern "C" {
    pub fn sigaddset(__set: *mut sigset_t, __signo: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn sigdelset(__set: *mut sigset_t, __signo: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn sigismember(__set: *const sigset_t, __signo: cty::c_int) -> cty::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub __sigaction_handler: sigaction__bindgen_ty_1,
    pub sa_mask: __sigset_t,
    pub sa_flags: cty::c_int,
    pub sa_restorer: ::core::option::Option<unsafe extern "C" fn()>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigaction__bindgen_ty_1 {
    pub sa_handler: __sighandler_t,
    pub sa_sigaction: ::core::option::Option<
        unsafe extern "C" fn(arg1: cty::c_int, arg2: *mut siginfo_t, arg3: *mut cty::c_void),
    >,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sigaction__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<sigaction__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(sigaction__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<sigaction__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sigaction__bindgen_ty_1>())).sa_handler as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction__bindgen_ty_1),
            "::",
            stringify!(sa_handler)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sigaction__bindgen_ty_1>())).sa_sigaction as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction__bindgen_ty_1),
            "::",
            stringify!(sa_sigaction)
        )
    );
}
#[test]
fn bindgen_test_layout_sigaction() {
    assert_eq!(
        ::core::mem::size_of::<sigaction>(),
        152usize,
        concat!("Size of: ", stringify!(sigaction))
    );
    assert_eq!(
        ::core::mem::align_of::<sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigaction>())).__sigaction_handler as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(__sigaction_handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigaction>())).sa_mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigaction>())).sa_flags as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigaction>())).sa_restorer as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_restorer)
        )
    );
}
extern "C" {
    pub fn sigprocmask(
        __how: cty::c_int,
        __set: *const sigset_t,
        __oset: *mut sigset_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn sigsuspend(__set: *const sigset_t) -> cty::c_int;
}
extern "C" {
    pub fn sigaction(
        __sig: cty::c_int,
        __act: *const sigaction,
        __oact: *mut sigaction,
    ) -> cty::c_int;
}
extern "C" {
    pub fn sigpending(__set: *mut sigset_t) -> cty::c_int;
}
extern "C" {
    pub fn sigwait(__set: *const sigset_t, __sig: *mut cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn sigwaitinfo(__set: *const sigset_t, __info: *mut siginfo_t) -> cty::c_int;
}
extern "C" {
    pub fn sigtimedwait(
        __set: *const sigset_t,
        __info: *mut siginfo_t,
        __timeout: *const timespec,
    ) -> cty::c_int;
}
extern "C" {
    pub fn sigqueue(__pid: __pid_t, __sig: cty::c_int, __val: sigval) -> cty::c_int;
}
extern "C" {
    pub static _sys_siglist: [*const cty::c_char; 65usize];
}
extern "C" {
    pub static sys_siglist: [*const cty::c_char; 65usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpx_sw_bytes {
    pub magic1: __uint32_t,
    pub extended_size: __uint32_t,
    pub xstate_bv: __uint64_t,
    pub xstate_size: __uint32_t,
    pub __glibc_reserved1: [__uint32_t; 7usize],
}
#[test]
fn bindgen_test_layout__fpx_sw_bytes() {
    assert_eq!(
        ::core::mem::size_of::<_fpx_sw_bytes>(),
        48usize,
        concat!("Size of: ", stringify!(_fpx_sw_bytes))
    );
    assert_eq!(
        ::core::mem::align_of::<_fpx_sw_bytes>(),
        8usize,
        concat!("Alignment of ", stringify!(_fpx_sw_bytes))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_fpx_sw_bytes>())).magic1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(magic1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_fpx_sw_bytes>())).extended_size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(extended_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_fpx_sw_bytes>())).xstate_bv as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(xstate_bv)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_fpx_sw_bytes>())).xstate_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(xstate_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_fpx_sw_bytes>())).__glibc_reserved1 as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpx_sw_bytes),
            "::",
            stringify!(__glibc_reserved1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpreg {
    pub significand: [cty::c_ushort; 4usize],
    pub exponent: cty::c_ushort,
}
#[test]
fn bindgen_test_layout__fpreg() {
    assert_eq!(
        ::core::mem::size_of::<_fpreg>(),
        10usize,
        concat!("Size of: ", stringify!(_fpreg))
    );
    assert_eq!(
        ::core::mem::align_of::<_fpreg>(),
        2usize,
        concat!("Alignment of ", stringify!(_fpreg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_fpreg>())).significand as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpreg),
            "::",
            stringify!(significand)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_fpreg>())).exponent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpreg),
            "::",
            stringify!(exponent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpxreg {
    pub significand: [cty::c_ushort; 4usize],
    pub exponent: cty::c_ushort,
    pub __glibc_reserved1: [cty::c_ushort; 3usize],
}
#[test]
fn bindgen_test_layout__fpxreg() {
    assert_eq!(
        ::core::mem::size_of::<_fpxreg>(),
        16usize,
        concat!("Size of: ", stringify!(_fpxreg))
    );
    assert_eq!(
        ::core::mem::align_of::<_fpxreg>(),
        2usize,
        concat!("Alignment of ", stringify!(_fpxreg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_fpxreg>())).significand as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpxreg),
            "::",
            stringify!(significand)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_fpxreg>())).exponent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpxreg),
            "::",
            stringify!(exponent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_fpxreg>())).__glibc_reserved1 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpxreg),
            "::",
            stringify!(__glibc_reserved1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmmreg {
    pub element: [__uint32_t; 4usize],
}
#[test]
fn bindgen_test_layout__xmmreg() {
    assert_eq!(
        ::core::mem::size_of::<_xmmreg>(),
        16usize,
        concat!("Size of: ", stringify!(_xmmreg))
    );
    assert_eq!(
        ::core::mem::align_of::<_xmmreg>(),
        4usize,
        concat!("Alignment of ", stringify!(_xmmreg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_xmmreg>())).element as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_xmmreg),
            "::",
            stringify!(element)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpstate {
    pub cwd: __uint16_t,
    pub swd: __uint16_t,
    pub ftw: __uint16_t,
    pub fop: __uint16_t,
    pub rip: __uint64_t,
    pub rdp: __uint64_t,
    pub mxcsr: __uint32_t,
    pub mxcr_mask: __uint32_t,
    pub _st: [_fpxreg; 8usize],
    pub _xmm: [_xmmreg; 16usize],
    pub __glibc_reserved1: [__uint32_t; 24usize],
}
#[test]
fn bindgen_test_layout__fpstate() {
    assert_eq!(
        ::core::mem::size_of::<_fpstate>(),
        512usize,
        concat!("Size of: ", stringify!(_fpstate))
    );
    assert_eq!(
        ::core::mem::align_of::<_fpstate>(),
        8usize,
        concat!("Alignment of ", stringify!(_fpstate))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_fpstate>())).cwd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(cwd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_fpstate>())).swd as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(swd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_fpstate>())).ftw as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(ftw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_fpstate>())).fop as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(fop)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_fpstate>())).rip as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_fpstate>())).rdp as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(rdp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_fpstate>())).mxcsr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(mxcsr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_fpstate>())).mxcr_mask as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(mxcr_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_fpstate>()))._st as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(_st)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_fpstate>()))._xmm as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(_xmm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_fpstate>())).__glibc_reserved1 as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(_fpstate),
            "::",
            stringify!(__glibc_reserved1)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigcontext {
    pub r8: __uint64_t,
    pub r9: __uint64_t,
    pub r10: __uint64_t,
    pub r11: __uint64_t,
    pub r12: __uint64_t,
    pub r13: __uint64_t,
    pub r14: __uint64_t,
    pub r15: __uint64_t,
    pub rdi: __uint64_t,
    pub rsi: __uint64_t,
    pub rbp: __uint64_t,
    pub rbx: __uint64_t,
    pub rdx: __uint64_t,
    pub rax: __uint64_t,
    pub rcx: __uint64_t,
    pub rsp: __uint64_t,
    pub rip: __uint64_t,
    pub eflags: __uint64_t,
    pub cs: cty::c_ushort,
    pub gs: cty::c_ushort,
    pub fs: cty::c_ushort,
    pub __pad0: cty::c_ushort,
    pub err: __uint64_t,
    pub trapno: __uint64_t,
    pub oldmask: __uint64_t,
    pub cr2: __uint64_t,
    pub __bindgen_anon_1: sigcontext__bindgen_ty_1,
    pub __reserved1: [__uint64_t; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigcontext__bindgen_ty_1 {
    pub fpstate: *mut _fpstate,
    pub __fpstate_word: __uint64_t,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sigcontext__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<sigcontext__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(sigcontext__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<sigcontext__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sigcontext__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sigcontext__bindgen_ty_1>())).fpstate as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext__bindgen_ty_1),
            "::",
            stringify!(fpstate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sigcontext__bindgen_ty_1>())).__fpstate_word as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext__bindgen_ty_1),
            "::",
            stringify!(__fpstate_word)
        )
    );
}
#[test]
fn bindgen_test_layout_sigcontext() {
    assert_eq!(
        ::core::mem::size_of::<sigcontext>(),
        256usize,
        concat!("Size of: ", stringify!(sigcontext))
    );
    assert_eq!(
        ::core::mem::align_of::<sigcontext>(),
        8usize,
        concat!("Alignment of ", stringify!(sigcontext))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigcontext>())).r8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r8)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigcontext>())).r9 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r9)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigcontext>())).r10 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r10)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigcontext>())).r11 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r11)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigcontext>())).r12 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r12)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigcontext>())).r13 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r13)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigcontext>())).r14 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r14)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigcontext>())).r15 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(r15)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigcontext>())).rdi as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rdi)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigcontext>())).rsi as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rsi)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigcontext>())).rbp as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rbp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigcontext>())).rbx as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rbx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigcontext>())).rdx as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigcontext>())).rax as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rax)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigcontext>())).rcx as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rcx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigcontext>())).rsp as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rsp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigcontext>())).rip as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigcontext>())).eflags as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(eflags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigcontext>())).cs as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(cs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigcontext>())).gs as *const _ as usize },
        146usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(gs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigcontext>())).fs as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(fs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigcontext>())).__pad0 as *const _ as usize },
        150usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(__pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigcontext>())).err as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(err)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigcontext>())).trapno as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(trapno)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigcontext>())).oldmask as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(oldmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigcontext>())).cr2 as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(cr2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigcontext>())).__reserved1 as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(sigcontext),
            "::",
            stringify!(__reserved1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xsave_hdr {
    pub xstate_bv: __uint64_t,
    pub __glibc_reserved1: [__uint64_t; 2usize],
    pub __glibc_reserved2: [__uint64_t; 5usize],
}
#[test]
fn bindgen_test_layout__xsave_hdr() {
    assert_eq!(
        ::core::mem::size_of::<_xsave_hdr>(),
        64usize,
        concat!("Size of: ", stringify!(_xsave_hdr))
    );
    assert_eq!(
        ::core::mem::align_of::<_xsave_hdr>(),
        8usize,
        concat!("Alignment of ", stringify!(_xsave_hdr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_xsave_hdr>())).xstate_bv as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_xsave_hdr),
            "::",
            stringify!(xstate_bv)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_xsave_hdr>())).__glibc_reserved1 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_xsave_hdr),
            "::",
            stringify!(__glibc_reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_xsave_hdr>())).__glibc_reserved2 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_xsave_hdr),
            "::",
            stringify!(__glibc_reserved2)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ymmh_state {
    pub ymmh_space: [__uint32_t; 64usize],
}
#[test]
fn bindgen_test_layout__ymmh_state() {
    assert_eq!(
        ::core::mem::size_of::<_ymmh_state>(),
        256usize,
        concat!("Size of: ", stringify!(_ymmh_state))
    );
    assert_eq!(
        ::core::mem::align_of::<_ymmh_state>(),
        4usize,
        concat!("Alignment of ", stringify!(_ymmh_state))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_ymmh_state>())).ymmh_space as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ymmh_state),
            "::",
            stringify!(ymmh_space)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _xstate {
    pub fpstate: _fpstate,
    pub xstate_hdr: _xsave_hdr,
    pub ymmh: _ymmh_state,
}
#[test]
fn bindgen_test_layout__xstate() {
    assert_eq!(
        ::core::mem::size_of::<_xstate>(),
        832usize,
        concat!("Size of: ", stringify!(_xstate))
    );
    assert_eq!(
        ::core::mem::align_of::<_xstate>(),
        8usize,
        concat!("Alignment of ", stringify!(_xstate))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_xstate>())).fpstate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_xstate),
            "::",
            stringify!(fpstate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_xstate>())).xstate_hdr as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(_xstate),
            "::",
            stringify!(xstate_hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_xstate>())).ymmh as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(_xstate),
            "::",
            stringify!(ymmh)
        )
    );
}
extern "C" {
    pub fn sigreturn(__scp: *mut sigcontext) -> cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stack_t {
    pub ss_sp: *mut cty::c_void,
    pub ss_flags: cty::c_int,
    pub ss_size: size_t,
}
#[test]
fn bindgen_test_layout_stack_t() {
    assert_eq!(
        ::core::mem::size_of::<stack_t>(),
        24usize,
        concat!("Size of: ", stringify!(stack_t))
    );
    assert_eq!(
        ::core::mem::align_of::<stack_t>(),
        8usize,
        concat!("Alignment of ", stringify!(stack_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<stack_t>())).ss_sp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_t),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<stack_t>())).ss_flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_t),
            "::",
            stringify!(ss_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<stack_t>())).ss_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(stack_t),
            "::",
            stringify!(ss_size)
        )
    );
}
pub type greg_t = cty::c_longlong;
pub type gregset_t = [greg_t; 23usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _libc_fpxreg {
    pub significand: [cty::c_ushort; 4usize],
    pub exponent: cty::c_ushort,
    pub __glibc_reserved1: [cty::c_ushort; 3usize],
}
#[test]
fn bindgen_test_layout__libc_fpxreg() {
    assert_eq!(
        ::core::mem::size_of::<_libc_fpxreg>(),
        16usize,
        concat!("Size of: ", stringify!(_libc_fpxreg))
    );
    assert_eq!(
        ::core::mem::align_of::<_libc_fpxreg>(),
        2usize,
        concat!("Alignment of ", stringify!(_libc_fpxreg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_libc_fpxreg>())).significand as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpxreg),
            "::",
            stringify!(significand)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_libc_fpxreg>())).exponent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpxreg),
            "::",
            stringify!(exponent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_libc_fpxreg>())).__glibc_reserved1 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpxreg),
            "::",
            stringify!(__glibc_reserved1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _libc_xmmreg {
    pub element: [__uint32_t; 4usize],
}
#[test]
fn bindgen_test_layout__libc_xmmreg() {
    assert_eq!(
        ::core::mem::size_of::<_libc_xmmreg>(),
        16usize,
        concat!("Size of: ", stringify!(_libc_xmmreg))
    );
    assert_eq!(
        ::core::mem::align_of::<_libc_xmmreg>(),
        4usize,
        concat!("Alignment of ", stringify!(_libc_xmmreg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_libc_xmmreg>())).element as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_xmmreg),
            "::",
            stringify!(element)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _libc_fpstate {
    pub cwd: __uint16_t,
    pub swd: __uint16_t,
    pub ftw: __uint16_t,
    pub fop: __uint16_t,
    pub rip: __uint64_t,
    pub rdp: __uint64_t,
    pub mxcsr: __uint32_t,
    pub mxcr_mask: __uint32_t,
    pub _st: [_libc_fpxreg; 8usize],
    pub _xmm: [_libc_xmmreg; 16usize],
    pub __glibc_reserved1: [__uint32_t; 24usize],
}
#[test]
fn bindgen_test_layout__libc_fpstate() {
    assert_eq!(
        ::core::mem::size_of::<_libc_fpstate>(),
        512usize,
        concat!("Size of: ", stringify!(_libc_fpstate))
    );
    assert_eq!(
        ::core::mem::align_of::<_libc_fpstate>(),
        8usize,
        concat!("Alignment of ", stringify!(_libc_fpstate))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_libc_fpstate>())).cwd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(cwd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_libc_fpstate>())).swd as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(swd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_libc_fpstate>())).ftw as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(ftw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_libc_fpstate>())).fop as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(fop)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_libc_fpstate>())).rip as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(rip)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_libc_fpstate>())).rdp as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(rdp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_libc_fpstate>())).mxcsr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(mxcsr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_libc_fpstate>())).mxcr_mask as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(mxcr_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_libc_fpstate>()))._st as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(_st)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_libc_fpstate>()))._xmm as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(_xmm)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_libc_fpstate>())).__glibc_reserved1 as *const _ as usize
        },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(_libc_fpstate),
            "::",
            stringify!(__glibc_reserved1)
        )
    );
}
pub type fpregset_t = *mut _libc_fpstate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mcontext_t {
    pub gregs: gregset_t,
    pub fpregs: fpregset_t,
    pub __reserved1: [cty::c_ulonglong; 8usize],
}
#[test]
fn bindgen_test_layout_mcontext_t() {
    assert_eq!(
        ::core::mem::size_of::<mcontext_t>(),
        256usize,
        concat!("Size of: ", stringify!(mcontext_t))
    );
    assert_eq!(
        ::core::mem::align_of::<mcontext_t>(),
        8usize,
        concat!("Alignment of ", stringify!(mcontext_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mcontext_t>())).gregs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mcontext_t),
            "::",
            stringify!(gregs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mcontext_t>())).fpregs as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(mcontext_t),
            "::",
            stringify!(fpregs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mcontext_t>())).__reserved1 as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(mcontext_t),
            "::",
            stringify!(__reserved1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucontext_t {
    pub uc_flags: cty::c_ulong,
    pub uc_link: *mut ucontext_t,
    pub uc_stack: stack_t,
    pub uc_mcontext: mcontext_t,
    pub uc_sigmask: sigset_t,
    pub __fpregs_mem: _libc_fpstate,
    pub __ssp: [cty::c_ulonglong; 4usize],
}
#[test]
fn bindgen_test_layout_ucontext_t() {
    assert_eq!(
        ::core::mem::size_of::<ucontext_t>(),
        968usize,
        concat!("Size of: ", stringify!(ucontext_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ucontext_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ucontext_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ucontext_t>())).uc_flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(uc_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ucontext_t>())).uc_link as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(uc_link)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ucontext_t>())).uc_stack as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(uc_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ucontext_t>())).uc_mcontext as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(uc_mcontext)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ucontext_t>())).uc_sigmask as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(uc_sigmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ucontext_t>())).__fpregs_mem as *const _ as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(__fpregs_mem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ucontext_t>())).__ssp as *const _ as usize },
        936usize,
        concat!(
            "Offset of field: ",
            stringify!(ucontext_t),
            "::",
            stringify!(__ssp)
        )
    );
}
extern "C" {
    pub fn siginterrupt(__sig: cty::c_int, __interrupt: cty::c_int) -> cty::c_int;
}
pub const SS_ONSTACK: _bindgen_ty_9 = 1;
pub const SS_DISABLE: _bindgen_ty_9 = 2;
pub type _bindgen_ty_9 = u32;
extern "C" {
    pub fn sigaltstack(__ss: *const stack_t, __oss: *mut stack_t) -> cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigstack {
    pub ss_sp: *mut cty::c_void,
    pub ss_onstack: cty::c_int,
}
#[test]
fn bindgen_test_layout_sigstack() {
    assert_eq!(
        ::core::mem::size_of::<sigstack>(),
        16usize,
        concat!("Size of: ", stringify!(sigstack))
    );
    assert_eq!(
        ::core::mem::align_of::<sigstack>(),
        8usize,
        concat!("Alignment of ", stringify!(sigstack))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigstack>())).ss_sp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sigstack>())).ss_onstack as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_onstack)
        )
    );
}
extern "C" {
    pub fn sigstack(__ss: *mut sigstack, __oss: *mut sigstack) -> cty::c_int;
}
extern "C" {
    pub fn pthread_sigmask(
        __how: cty::c_int,
        __newmask: *const __sigset_t,
        __oldmask: *mut __sigset_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_kill(__threadid: pthread_t, __signo: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn __libc_current_sigrtmin() -> cty::c_int;
}
extern "C" {
    pub fn __libc_current_sigrtmax() -> cty::c_int;
}
extern "C" {
    pub fn g_on_error_query(prg_name: *const gchar);
}
extern "C" {
    pub fn g_on_error_stack_trace(prg_name: *const gchar);
}
extern "C" {
    pub fn g_base64_encode_step(
        in_: *const guchar,
        len: gsize,
        break_lines: gboolean,
        out: *mut gchar,
        state: *mut gint,
        save: *mut gint,
    ) -> gsize;
}
extern "C" {
    pub fn g_base64_encode_close(
        break_lines: gboolean,
        out: *mut gchar,
        state: *mut gint,
        save: *mut gint,
    ) -> gsize;
}
extern "C" {
    pub fn g_base64_encode(data: *const guchar, len: gsize) -> *mut gchar;
}
extern "C" {
    pub fn g_base64_decode_step(
        in_: *const gchar,
        len: gsize,
        out: *mut guchar,
        state: *mut gint,
        save: *mut guint,
    ) -> gsize;
}
extern "C" {
    pub fn g_base64_decode(text: *const gchar, out_len: *mut gsize) -> *mut guchar;
}
extern "C" {
    pub fn g_base64_decode_inplace(text: *mut gchar, out_len: *mut gsize) -> *mut guchar;
}
extern "C" {
    pub fn g_bit_lock(address: *mut gint, lock_bit: gint);
}
extern "C" {
    pub fn g_bit_trylock(address: *mut gint, lock_bit: gint) -> gboolean;
}
extern "C" {
    pub fn g_bit_unlock(address: *mut gint, lock_bit: gint);
}
extern "C" {
    pub fn g_pointer_bit_lock(address: *mut cty::c_void, lock_bit: gint);
}
extern "C" {
    pub fn g_pointer_bit_trylock(address: *mut cty::c_void, lock_bit: gint) -> gboolean;
}
extern "C" {
    pub fn g_pointer_bit_unlock(address: *mut cty::c_void, lock_bit: gint);
}
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_INVALID_URI: GBookmarkFileError = 0;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_INVALID_VALUE: GBookmarkFileError = 1;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED: GBookmarkFileError = 2;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND: GBookmarkFileError = 3;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_READ: GBookmarkFileError = 4;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING: GBookmarkFileError = 5;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_WRITE: GBookmarkFileError = 6;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND: GBookmarkFileError = 7;
#[doc = " GBookmarkFileError:"]
#[doc = " @G_BOOKMARK_FILE_ERROR_INVALID_URI: URI was ill-formed"]
#[doc = " @G_BOOKMARK_FILE_ERROR_INVALID_VALUE: a requested field was not found"]
#[doc = " @G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED: a requested application did"]
#[doc = "     not register a bookmark"]
#[doc = " @G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND: a requested URI was not found"]
#[doc = " @G_BOOKMARK_FILE_ERROR_READ: document was ill formed"]
#[doc = " @G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING: the text being parsed was"]
#[doc = "     in an unknown encoding"]
#[doc = " @G_BOOKMARK_FILE_ERROR_WRITE: an error occurred while writing"]
#[doc = " @G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND: requested file was not found"]
#[doc = ""]
#[doc = " Error codes returned by bookmark file parsing."]
pub type GBookmarkFileError = u32;
extern "C" {
    pub fn g_bookmark_file_error_quark() -> GQuark;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBookmarkFile {
    _unused: [u8; 0],
}
#[doc = " GBookmarkFile:"]
#[doc = ""]
#[doc = " The `GBookmarkFile` structure contains only"]
#[doc = " private data and should not be directly accessed."]
pub type GBookmarkFile = _GBookmarkFile;
extern "C" {
    pub fn g_bookmark_file_new() -> *mut GBookmarkFile;
}
extern "C" {
    pub fn g_bookmark_file_free(bookmark: *mut GBookmarkFile);
}
extern "C" {
    pub fn g_bookmark_file_load_from_file(
        bookmark: *mut GBookmarkFile,
        filename: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_load_from_data(
        bookmark: *mut GBookmarkFile,
        data: *const gchar,
        length: gsize,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_load_from_data_dirs(
        bookmark: *mut GBookmarkFile,
        file: *const gchar,
        full_path: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_to_data(
        bookmark: *mut GBookmarkFile,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_bookmark_file_to_file(
        bookmark: *mut GBookmarkFile,
        filename: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_set_title(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        title: *const gchar,
    );
}
extern "C" {
    pub fn g_bookmark_file_get_title(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_bookmark_file_set_description(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        description: *const gchar,
    );
}
extern "C" {
    pub fn g_bookmark_file_get_description(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_bookmark_file_set_mime_type(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        mime_type: *const gchar,
    );
}
extern "C" {
    pub fn g_bookmark_file_get_mime_type(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_bookmark_file_set_groups(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        groups: *mut *const gchar,
        length: gsize,
    );
}
extern "C" {
    pub fn g_bookmark_file_add_group(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        group: *const gchar,
    );
}
extern "C" {
    pub fn g_bookmark_file_has_group(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        group: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_get_groups(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_bookmark_file_add_application(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        exec: *const gchar,
    );
}
extern "C" {
    pub fn g_bookmark_file_has_application(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_get_applications(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_bookmark_file_set_app_info(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        exec: *const gchar,
        count: gint,
        stamp: time_t,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_get_app_info(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        exec: *mut *mut gchar,
        count: *mut guint,
        stamp: *mut time_t,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_set_is_private(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        is_private: gboolean,
    );
}
extern "C" {
    pub fn g_bookmark_file_get_is_private(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_set_icon(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        href: *const gchar,
        mime_type: *const gchar,
    );
}
extern "C" {
    pub fn g_bookmark_file_get_icon(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        href: *mut *mut gchar,
        mime_type: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_set_added(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        added: time_t,
    );
}
extern "C" {
    pub fn g_bookmark_file_get_added(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> time_t;
}
extern "C" {
    pub fn g_bookmark_file_set_modified(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        modified: time_t,
    );
}
extern "C" {
    pub fn g_bookmark_file_get_modified(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> time_t;
}
extern "C" {
    pub fn g_bookmark_file_set_visited(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        visited: time_t,
    );
}
extern "C" {
    pub fn g_bookmark_file_get_visited(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> time_t;
}
extern "C" {
    pub fn g_bookmark_file_has_item(bookmark: *mut GBookmarkFile, uri: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_get_size(bookmark: *mut GBookmarkFile) -> gint;
}
extern "C" {
    pub fn g_bookmark_file_get_uris(
        bookmark: *mut GBookmarkFile,
        length: *mut gsize,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_bookmark_file_remove_group(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        group: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_remove_application(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_remove_item(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bookmark_file_move_item(
        bookmark: *mut GBookmarkFile,
        old_uri: *const gchar,
        new_uri: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_bytes_new(data: gconstpointer, size: gsize) -> *mut GBytes;
}
extern "C" {
    pub fn g_bytes_new_take(data: gpointer, size: gsize) -> *mut GBytes;
}
extern "C" {
    pub fn g_bytes_new_static(data: gconstpointer, size: gsize) -> *mut GBytes;
}
extern "C" {
    pub fn g_bytes_new_with_free_func(
        data: gconstpointer,
        size: gsize,
        free_func: GDestroyNotify,
        user_data: gpointer,
    ) -> *mut GBytes;
}
extern "C" {
    pub fn g_bytes_new_from_bytes(bytes: *mut GBytes, offset: gsize, length: gsize) -> *mut GBytes;
}
extern "C" {
    pub fn g_bytes_get_data(bytes: *mut GBytes, size: *mut gsize) -> gconstpointer;
}
extern "C" {
    pub fn g_bytes_get_size(bytes: *mut GBytes) -> gsize;
}
extern "C" {
    pub fn g_bytes_ref(bytes: *mut GBytes) -> *mut GBytes;
}
extern "C" {
    pub fn g_bytes_unref(bytes: *mut GBytes);
}
extern "C" {
    pub fn g_bytes_unref_to_data(bytes: *mut GBytes, size: *mut gsize) -> gpointer;
}
extern "C" {
    pub fn g_bytes_unref_to_array(bytes: *mut GBytes) -> *mut GByteArray;
}
extern "C" {
    pub fn g_bytes_hash(bytes: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_bytes_equal(bytes1: gconstpointer, bytes2: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_bytes_compare(bytes1: gconstpointer, bytes2: gconstpointer) -> gint;
}
extern "C" {
    pub fn g_get_charset(charset: *mut *const cty::c_char) -> gboolean;
}
extern "C" {
    pub fn g_get_codeset() -> *mut gchar;
}
extern "C" {
    pub fn g_get_console_charset(charset: *mut *const cty::c_char) -> gboolean;
}
extern "C" {
    pub fn g_get_language_names() -> *const *const gchar;
}
extern "C" {
    pub fn g_get_language_names_with_category(category_name: *const gchar) -> *const *const gchar;
}
extern "C" {
    pub fn g_get_locale_variants(locale: *const gchar) -> *mut *mut gchar;
}
pub const GChecksumType_G_CHECKSUM_MD5: GChecksumType = 0;
pub const GChecksumType_G_CHECKSUM_SHA1: GChecksumType = 1;
pub const GChecksumType_G_CHECKSUM_SHA256: GChecksumType = 2;
pub const GChecksumType_G_CHECKSUM_SHA512: GChecksumType = 3;
pub const GChecksumType_G_CHECKSUM_SHA384: GChecksumType = 4;
#[doc = " GChecksumType:"]
#[doc = " @G_CHECKSUM_MD5: Use the MD5 hashing algorithm"]
#[doc = " @G_CHECKSUM_SHA1: Use the SHA-1 hashing algorithm"]
#[doc = " @G_CHECKSUM_SHA256: Use the SHA-256 hashing algorithm"]
#[doc = " @G_CHECKSUM_SHA384: Use the SHA-384 hashing algorithm (Since: 2.51)"]
#[doc = " @G_CHECKSUM_SHA512: Use the SHA-512 hashing algorithm (Since: 2.36)"]
#[doc = ""]
#[doc = " The hashing algorithm to be used by #GChecksum when performing the"]
#[doc = " digest of some data."]
#[doc = ""]
#[doc = " Note that the #GChecksumType enumeration may be extended at a later"]
#[doc = " date to include new hashing algorithm types."]
#[doc = ""]
#[doc = " Since: 2.16"]
pub type GChecksumType = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GChecksum {
    _unused: [u8; 0],
}
#[doc = " GChecksum:"]
#[doc = ""]
#[doc = " An opaque structure representing a checksumming operation."]
#[doc = " To create a new GChecksum, use g_checksum_new(). To free"]
#[doc = " a GChecksum, use g_checksum_free()."]
#[doc = ""]
#[doc = " Since: 2.16"]
pub type GChecksum = _GChecksum;
extern "C" {
    pub fn g_checksum_type_get_length(checksum_type: GChecksumType) -> gssize;
}
extern "C" {
    pub fn g_checksum_new(checksum_type: GChecksumType) -> *mut GChecksum;
}
extern "C" {
    pub fn g_checksum_reset(checksum: *mut GChecksum);
}
extern "C" {
    pub fn g_checksum_copy(checksum: *const GChecksum) -> *mut GChecksum;
}
extern "C" {
    pub fn g_checksum_free(checksum: *mut GChecksum);
}
extern "C" {
    pub fn g_checksum_update(checksum: *mut GChecksum, data: *const guchar, length: gssize);
}
extern "C" {
    pub fn g_checksum_get_string(checksum: *mut GChecksum) -> *const gchar;
}
extern "C" {
    pub fn g_checksum_get_digest(
        checksum: *mut GChecksum,
        buffer: *mut guint8,
        digest_len: *mut gsize,
    );
}
extern "C" {
    pub fn g_compute_checksum_for_data(
        checksum_type: GChecksumType,
        data: *const guchar,
        length: gsize,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_compute_checksum_for_string(
        checksum_type: GChecksumType,
        str_: *const gchar,
        length: gssize,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_compute_checksum_for_bytes(
        checksum_type: GChecksumType,
        data: *mut GBytes,
    ) -> *mut gchar;
}
pub const GConvertError_G_CONVERT_ERROR_NO_CONVERSION: GConvertError = 0;
pub const GConvertError_G_CONVERT_ERROR_ILLEGAL_SEQUENCE: GConvertError = 1;
pub const GConvertError_G_CONVERT_ERROR_FAILED: GConvertError = 2;
pub const GConvertError_G_CONVERT_ERROR_PARTIAL_INPUT: GConvertError = 3;
pub const GConvertError_G_CONVERT_ERROR_BAD_URI: GConvertError = 4;
pub const GConvertError_G_CONVERT_ERROR_NOT_ABSOLUTE_PATH: GConvertError = 5;
pub const GConvertError_G_CONVERT_ERROR_NO_MEMORY: GConvertError = 6;
pub const GConvertError_G_CONVERT_ERROR_EMBEDDED_NUL: GConvertError = 7;
#[doc = " GConvertError:"]
#[doc = " @G_CONVERT_ERROR_NO_CONVERSION: Conversion between the requested character"]
#[doc = "     sets is not supported."]
#[doc = " @G_CONVERT_ERROR_ILLEGAL_SEQUENCE: Invalid byte sequence in conversion input;"]
#[doc = "    or the character sequence could not be represented in the target"]
#[doc = "    character set."]
#[doc = " @G_CONVERT_ERROR_FAILED: Conversion failed for some reason."]
#[doc = " @G_CONVERT_ERROR_PARTIAL_INPUT: Partial character sequence at end of input."]
#[doc = " @G_CONVERT_ERROR_BAD_URI: URI is invalid."]
#[doc = " @G_CONVERT_ERROR_NOT_ABSOLUTE_PATH: Pathname is not an absolute path."]
#[doc = " @G_CONVERT_ERROR_NO_MEMORY: No memory available. Since: 2.40"]
#[doc = " @G_CONVERT_ERROR_EMBEDDED_NUL: An embedded NUL character is present in"]
#[doc = "     conversion output where a NUL-terminated string is expected."]
#[doc = "     Since: 2.56"]
#[doc = ""]
#[doc = " Error codes returned by character set conversion routines."]
pub type GConvertError = u32;
extern "C" {
    pub fn g_convert_error_quark() -> GQuark;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIConv {
    _unused: [u8; 0],
}
#[doc = " GIConv: (skip)"]
#[doc = ""]
#[doc = " The GIConv struct wraps an iconv() conversion descriptor. It contains"]
#[doc = " private data and should only be accessed using the following functions."]
pub type GIConv = *mut _GIConv;
extern "C" {
    pub fn g_iconv_open(to_codeset: *const gchar, from_codeset: *const gchar) -> GIConv;
}
extern "C" {
    pub fn g_iconv(
        converter: GIConv,
        inbuf: *mut *mut gchar,
        inbytes_left: *mut gsize,
        outbuf: *mut *mut gchar,
        outbytes_left: *mut gsize,
    ) -> gsize;
}
extern "C" {
    pub fn g_iconv_close(converter: GIConv) -> gint;
}
extern "C" {
    pub fn g_convert(
        str_: *const gchar,
        len: gssize,
        to_codeset: *const gchar,
        from_codeset: *const gchar,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_convert_with_iconv(
        str_: *const gchar,
        len: gssize,
        converter: GIConv,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_convert_with_fallback(
        str_: *const gchar,
        len: gssize,
        to_codeset: *const gchar,
        from_codeset: *const gchar,
        fallback: *const gchar,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_locale_to_utf8(
        opsysstring: *const gchar,
        len: gssize,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_locale_from_utf8(
        utf8string: *const gchar,
        len: gssize,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_filename_to_utf8(
        opsysstring: *const gchar,
        len: gssize,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_filename_from_utf8(
        utf8string: *const gchar,
        len: gssize,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_filename_from_uri(
        uri: *const gchar,
        hostname: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_filename_to_uri(
        filename: *const gchar,
        hostname: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_filename_display_name(filename: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_get_filename_charsets(filename_charsets: *mut *mut *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_filename_display_basename(filename: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_uri_list_extract_uris(uri_list: *const gchar) -> *mut *mut gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GData {
    _unused: [u8; 0],
}
pub type GData = _GData;
pub type GDataForeachFunc = ::core::option::Option<
    unsafe extern "C" fn(key_id: GQuark, data: gpointer, user_data: gpointer),
>;
extern "C" {
    pub fn g_datalist_init(datalist: *mut *mut GData);
}
extern "C" {
    pub fn g_datalist_clear(datalist: *mut *mut GData);
}
extern "C" {
    pub fn g_datalist_id_get_data(datalist: *mut *mut GData, key_id: GQuark) -> gpointer;
}
extern "C" {
    pub fn g_datalist_id_set_data_full(
        datalist: *mut *mut GData,
        key_id: GQuark,
        data: gpointer,
        destroy_func: GDestroyNotify,
    );
}
pub type GDuplicateFunc =
    ::core::option::Option<unsafe extern "C" fn(data: gpointer, user_data: gpointer) -> gpointer>;
extern "C" {
    pub fn g_datalist_id_dup_data(
        datalist: *mut *mut GData,
        key_id: GQuark,
        dup_func: GDuplicateFunc,
        user_data: gpointer,
    ) -> gpointer;
}
extern "C" {
    pub fn g_datalist_id_replace_data(
        datalist: *mut *mut GData,
        key_id: GQuark,
        oldval: gpointer,
        newval: gpointer,
        destroy: GDestroyNotify,
        old_destroy: *mut GDestroyNotify,
    ) -> gboolean;
}
extern "C" {
    pub fn g_datalist_id_remove_no_notify(datalist: *mut *mut GData, key_id: GQuark) -> gpointer;
}
extern "C" {
    pub fn g_datalist_foreach(
        datalist: *mut *mut GData,
        func: GDataForeachFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_datalist_set_flags(datalist: *mut *mut GData, flags: guint);
}
extern "C" {
    pub fn g_datalist_unset_flags(datalist: *mut *mut GData, flags: guint);
}
extern "C" {
    pub fn g_datalist_get_flags(datalist: *mut *mut GData) -> guint;
}
extern "C" {
    pub fn g_dataset_destroy(dataset_location: gconstpointer);
}
extern "C" {
    pub fn g_dataset_id_get_data(dataset_location: gconstpointer, key_id: GQuark) -> gpointer;
}
extern "C" {
    pub fn g_datalist_get_data(datalist: *mut *mut GData, key: *const gchar) -> gpointer;
}
extern "C" {
    pub fn g_dataset_id_set_data_full(
        dataset_location: gconstpointer,
        key_id: GQuark,
        data: gpointer,
        destroy_func: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_dataset_id_remove_no_notify(
        dataset_location: gconstpointer,
        key_id: GQuark,
    ) -> gpointer;
}
extern "C" {
    pub fn g_dataset_foreach(
        dataset_location: gconstpointer,
        func: GDataForeachFunc,
        user_data: gpointer,
    );
}
pub type GTime = gint32;
pub type GDateYear = guint16;
pub type GDateDay = guint8;
pub type GDate = _GDate;
pub const GDateDMY_G_DATE_DAY: GDateDMY = 0;
pub const GDateDMY_G_DATE_MONTH: GDateDMY = 1;
pub const GDateDMY_G_DATE_YEAR: GDateDMY = 2;
pub type GDateDMY = u32;
pub const GDateWeekday_G_DATE_BAD_WEEKDAY: GDateWeekday = 0;
pub const GDateWeekday_G_DATE_MONDAY: GDateWeekday = 1;
pub const GDateWeekday_G_DATE_TUESDAY: GDateWeekday = 2;
pub const GDateWeekday_G_DATE_WEDNESDAY: GDateWeekday = 3;
pub const GDateWeekday_G_DATE_THURSDAY: GDateWeekday = 4;
pub const GDateWeekday_G_DATE_FRIDAY: GDateWeekday = 5;
pub const GDateWeekday_G_DATE_SATURDAY: GDateWeekday = 6;
pub const GDateWeekday_G_DATE_SUNDAY: GDateWeekday = 7;
pub type GDateWeekday = u32;
pub const GDateMonth_G_DATE_BAD_MONTH: GDateMonth = 0;
pub const GDateMonth_G_DATE_JANUARY: GDateMonth = 1;
pub const GDateMonth_G_DATE_FEBRUARY: GDateMonth = 2;
pub const GDateMonth_G_DATE_MARCH: GDateMonth = 3;
pub const GDateMonth_G_DATE_APRIL: GDateMonth = 4;
pub const GDateMonth_G_DATE_MAY: GDateMonth = 5;
pub const GDateMonth_G_DATE_JUNE: GDateMonth = 6;
pub const GDateMonth_G_DATE_JULY: GDateMonth = 7;
pub const GDateMonth_G_DATE_AUGUST: GDateMonth = 8;
pub const GDateMonth_G_DATE_SEPTEMBER: GDateMonth = 9;
pub const GDateMonth_G_DATE_OCTOBER: GDateMonth = 10;
pub const GDateMonth_G_DATE_NOVEMBER: GDateMonth = 11;
pub const GDateMonth_G_DATE_DECEMBER: GDateMonth = 12;
pub type GDateMonth = u32;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _GDate {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u32>,
}
#[test]
fn bindgen_test_layout__GDate() {
    assert_eq!(
        ::core::mem::size_of::<_GDate>(),
        8usize,
        concat!("Size of: ", stringify!(_GDate))
    );
    assert_eq!(
        ::core::mem::align_of::<_GDate>(),
        4usize,
        concat!("Alignment of ", stringify!(_GDate))
    );
}
impl _GDate {
    #[inline]
    pub fn julian_days(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_julian_days(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn julian(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_julian(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dmy(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(33usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dmy(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn day(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(34usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_day(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(34usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn month(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(40usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_month(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(40usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn year(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(44usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_year(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(44usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        julian_days: guint,
        julian: guint,
        dmy: guint,
        day: guint,
        month: guint,
        year: guint,
    ) -> __BindgenBitfieldUnit<[u8; 8usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let julian_days: u32 = unsafe { ::core::mem::transmute(julian_days) };
            julian_days as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let julian: u32 = unsafe { ::core::mem::transmute(julian) };
            julian as u64
        });
        __bindgen_bitfield_unit.set(33usize, 1u8, {
            let dmy: u32 = unsafe { ::core::mem::transmute(dmy) };
            dmy as u64
        });
        __bindgen_bitfield_unit.set(34usize, 6u8, {
            let day: u32 = unsafe { ::core::mem::transmute(day) };
            day as u64
        });
        __bindgen_bitfield_unit.set(40usize, 4u8, {
            let month: u32 = unsafe { ::core::mem::transmute(month) };
            month as u64
        });
        __bindgen_bitfield_unit.set(44usize, 16u8, {
            let year: u32 = unsafe { ::core::mem::transmute(year) };
            year as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn g_date_new() -> *mut GDate;
}
extern "C" {
    pub fn g_date_new_dmy(day: GDateDay, month: GDateMonth, year: GDateYear) -> *mut GDate;
}
extern "C" {
    pub fn g_date_new_julian(julian_day: guint32) -> *mut GDate;
}
extern "C" {
    pub fn g_date_free(date: *mut GDate);
}
extern "C" {
    pub fn g_date_copy(date: *const GDate) -> *mut GDate;
}
extern "C" {
    pub fn g_date_valid(date: *const GDate) -> gboolean;
}
extern "C" {
    pub fn g_date_valid_day(day: GDateDay) -> gboolean;
}
extern "C" {
    pub fn g_date_valid_month(month: GDateMonth) -> gboolean;
}
extern "C" {
    pub fn g_date_valid_year(year: GDateYear) -> gboolean;
}
extern "C" {
    pub fn g_date_valid_weekday(weekday: GDateWeekday) -> gboolean;
}
extern "C" {
    pub fn g_date_valid_julian(julian_date: guint32) -> gboolean;
}
extern "C" {
    pub fn g_date_valid_dmy(day: GDateDay, month: GDateMonth, year: GDateYear) -> gboolean;
}
extern "C" {
    pub fn g_date_get_weekday(date: *const GDate) -> GDateWeekday;
}
extern "C" {
    pub fn g_date_get_month(date: *const GDate) -> GDateMonth;
}
extern "C" {
    pub fn g_date_get_year(date: *const GDate) -> GDateYear;
}
extern "C" {
    pub fn g_date_get_day(date: *const GDate) -> GDateDay;
}
extern "C" {
    pub fn g_date_get_julian(date: *const GDate) -> guint32;
}
extern "C" {
    pub fn g_date_get_day_of_year(date: *const GDate) -> guint;
}
extern "C" {
    pub fn g_date_get_monday_week_of_year(date: *const GDate) -> guint;
}
extern "C" {
    pub fn g_date_get_sunday_week_of_year(date: *const GDate) -> guint;
}
extern "C" {
    pub fn g_date_get_iso8601_week_of_year(date: *const GDate) -> guint;
}
extern "C" {
    pub fn g_date_clear(date: *mut GDate, n_dates: guint);
}
extern "C" {
    pub fn g_date_set_parse(date: *mut GDate, str_: *const gchar);
}
extern "C" {
    pub fn g_date_set_time_t(date: *mut GDate, timet: time_t);
}
extern "C" {
    pub fn g_date_set_time_val(date: *mut GDate, timeval: *mut GTimeVal);
}
extern "C" {
    pub fn g_date_set_time(date: *mut GDate, time_: GTime);
}
extern "C" {
    pub fn g_date_set_month(date: *mut GDate, month: GDateMonth);
}
extern "C" {
    pub fn g_date_set_day(date: *mut GDate, day: GDateDay);
}
extern "C" {
    pub fn g_date_set_year(date: *mut GDate, year: GDateYear);
}
extern "C" {
    pub fn g_date_set_dmy(date: *mut GDate, day: GDateDay, month: GDateMonth, y: GDateYear);
}
extern "C" {
    pub fn g_date_set_julian(date: *mut GDate, julian_date: guint32);
}
extern "C" {
    pub fn g_date_is_first_of_month(date: *const GDate) -> gboolean;
}
extern "C" {
    pub fn g_date_is_last_of_month(date: *const GDate) -> gboolean;
}
extern "C" {
    pub fn g_date_add_days(date: *mut GDate, n_days: guint);
}
extern "C" {
    pub fn g_date_subtract_days(date: *mut GDate, n_days: guint);
}
extern "C" {
    pub fn g_date_add_months(date: *mut GDate, n_months: guint);
}
extern "C" {
    pub fn g_date_subtract_months(date: *mut GDate, n_months: guint);
}
extern "C" {
    pub fn g_date_add_years(date: *mut GDate, n_years: guint);
}
extern "C" {
    pub fn g_date_subtract_years(date: *mut GDate, n_years: guint);
}
extern "C" {
    pub fn g_date_is_leap_year(year: GDateYear) -> gboolean;
}
extern "C" {
    pub fn g_date_get_days_in_month(month: GDateMonth, year: GDateYear) -> guint8;
}
extern "C" {
    pub fn g_date_get_monday_weeks_in_year(year: GDateYear) -> guint8;
}
extern "C" {
    pub fn g_date_get_sunday_weeks_in_year(year: GDateYear) -> guint8;
}
extern "C" {
    pub fn g_date_days_between(date1: *const GDate, date2: *const GDate) -> gint;
}
extern "C" {
    pub fn g_date_compare(lhs: *const GDate, rhs: *const GDate) -> gint;
}
extern "C" {
    pub fn g_date_to_struct_tm(date: *const GDate, tm: *mut tm);
}
extern "C" {
    pub fn g_date_clamp(date: *mut GDate, min_date: *const GDate, max_date: *const GDate);
}
extern "C" {
    pub fn g_date_order(date1: *mut GDate, date2: *mut GDate);
}
extern "C" {
    pub fn g_date_strftime(
        s: *mut gchar,
        slen: gsize,
        format: *const gchar,
        date: *const GDate,
    ) -> gsize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTimeZone {
    _unused: [u8; 0],
}
pub type GTimeZone = _GTimeZone;
pub const GTimeType_G_TIME_TYPE_STANDARD: GTimeType = 0;
pub const GTimeType_G_TIME_TYPE_DAYLIGHT: GTimeType = 1;
pub const GTimeType_G_TIME_TYPE_UNIVERSAL: GTimeType = 2;
#[doc = " GTimeType:"]
#[doc = " @G_TIME_TYPE_STANDARD: the time is in local standard time"]
#[doc = " @G_TIME_TYPE_DAYLIGHT: the time is in local daylight time"]
#[doc = " @G_TIME_TYPE_UNIVERSAL: the time is in UTC"]
#[doc = ""]
#[doc = " Disambiguates a given time in two ways."]
#[doc = ""]
#[doc = " First, specifies if the given time is in universal or local time."]
#[doc = ""]
#[doc = " Second, if the time is in local time, specifies if it is local"]
#[doc = " standard time or local daylight time.  This is important for the case"]
#[doc = " where the same local time occurs twice (during daylight savings time"]
#[doc = " transitions, for example)."]
pub type GTimeType = u32;
extern "C" {
    pub fn g_time_zone_new(identifier: *const gchar) -> *mut GTimeZone;
}
extern "C" {
    pub fn g_time_zone_new_utc() -> *mut GTimeZone;
}
extern "C" {
    pub fn g_time_zone_new_local() -> *mut GTimeZone;
}
extern "C" {
    pub fn g_time_zone_new_offset(seconds: gint32) -> *mut GTimeZone;
}
extern "C" {
    pub fn g_time_zone_ref(tz: *mut GTimeZone) -> *mut GTimeZone;
}
extern "C" {
    pub fn g_time_zone_unref(tz: *mut GTimeZone);
}
extern "C" {
    pub fn g_time_zone_find_interval(tz: *mut GTimeZone, type_: GTimeType, time_: gint64) -> gint;
}
extern "C" {
    pub fn g_time_zone_adjust_time(
        tz: *mut GTimeZone,
        type_: GTimeType,
        time_: *mut gint64,
    ) -> gint;
}
extern "C" {
    pub fn g_time_zone_get_abbreviation(tz: *mut GTimeZone, interval: gint) -> *const gchar;
}
extern "C" {
    pub fn g_time_zone_get_offset(tz: *mut GTimeZone, interval: gint) -> gint32;
}
extern "C" {
    pub fn g_time_zone_is_dst(tz: *mut GTimeZone, interval: gint) -> gboolean;
}
extern "C" {
    pub fn g_time_zone_get_identifier(tz: *mut GTimeZone) -> *const gchar;
}
#[doc = " GTimeSpan:"]
#[doc = ""]
#[doc = " A value representing an interval of time, in microseconds."]
#[doc = ""]
#[doc = " Since: 2.26"]
pub type GTimeSpan = gint64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDateTime {
    _unused: [u8; 0],
}
#[doc = " GDateTime:"]
#[doc = ""]
#[doc = " `GDateTime` is an opaque structure whose members"]
#[doc = " cannot be accessed directly."]
#[doc = ""]
#[doc = " Since: 2.26"]
pub type GDateTime = _GDateTime;
extern "C" {
    pub fn g_date_time_unref(datetime: *mut GDateTime);
}
extern "C" {
    pub fn g_date_time_ref(datetime: *mut GDateTime) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_now(tz: *mut GTimeZone) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_now_local() -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_now_utc() -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_from_unix_local(t: gint64) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_from_unix_utc(t: gint64) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_from_timeval_local(tv: *const GTimeVal) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_from_timeval_utc(tv: *const GTimeVal) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_from_iso8601(
        text: *const gchar,
        default_tz: *mut GTimeZone,
    ) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new(
        tz: *mut GTimeZone,
        year: gint,
        month: gint,
        day: gint,
        hour: gint,
        minute: gint,
        seconds: gdouble,
    ) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_local(
        year: gint,
        month: gint,
        day: gint,
        hour: gint,
        minute: gint,
        seconds: gdouble,
    ) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_new_utc(
        year: gint,
        month: gint,
        day: gint,
        hour: gint,
        minute: gint,
        seconds: gdouble,
    ) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add(datetime: *mut GDateTime, timespan: GTimeSpan) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add_years(datetime: *mut GDateTime, years: gint) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add_months(datetime: *mut GDateTime, months: gint) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add_weeks(datetime: *mut GDateTime, weeks: gint) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add_days(datetime: *mut GDateTime, days: gint) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add_hours(datetime: *mut GDateTime, hours: gint) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add_minutes(datetime: *mut GDateTime, minutes: gint) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add_seconds(datetime: *mut GDateTime, seconds: gdouble) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_add_full(
        datetime: *mut GDateTime,
        years: gint,
        months: gint,
        days: gint,
        hours: gint,
        minutes: gint,
        seconds: gdouble,
    ) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_compare(dt1: gconstpointer, dt2: gconstpointer) -> gint;
}
extern "C" {
    pub fn g_date_time_difference(end: *mut GDateTime, begin: *mut GDateTime) -> GTimeSpan;
}
extern "C" {
    pub fn g_date_time_hash(datetime: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_date_time_equal(dt1: gconstpointer, dt2: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_date_time_get_ymd(
        datetime: *mut GDateTime,
        year: *mut gint,
        month: *mut gint,
        day: *mut gint,
    );
}
extern "C" {
    pub fn g_date_time_get_year(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_month(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_day_of_month(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_week_numbering_year(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_week_of_year(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_day_of_week(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_day_of_year(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_hour(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_minute(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_second(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_microsecond(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    pub fn g_date_time_get_seconds(datetime: *mut GDateTime) -> gdouble;
}
extern "C" {
    pub fn g_date_time_to_unix(datetime: *mut GDateTime) -> gint64;
}
extern "C" {
    pub fn g_date_time_to_timeval(datetime: *mut GDateTime, tv: *mut GTimeVal) -> gboolean;
}
extern "C" {
    pub fn g_date_time_get_utc_offset(datetime: *mut GDateTime) -> GTimeSpan;
}
extern "C" {
    pub fn g_date_time_get_timezone(datetime: *mut GDateTime) -> *mut GTimeZone;
}
extern "C" {
    pub fn g_date_time_get_timezone_abbreviation(datetime: *mut GDateTime) -> *const gchar;
}
extern "C" {
    pub fn g_date_time_is_daylight_savings(datetime: *mut GDateTime) -> gboolean;
}
extern "C" {
    pub fn g_date_time_to_timezone(datetime: *mut GDateTime, tz: *mut GTimeZone) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_to_local(datetime: *mut GDateTime) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_to_utc(datetime: *mut GDateTime) -> *mut GDateTime;
}
extern "C" {
    pub fn g_date_time_format(datetime: *mut GDateTime, format: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_date_time_format_iso8601(datetime: *mut GDateTime) -> *mut gchar;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dirent {
    pub d_ino: __ino_t,
    pub d_off: __off_t,
    pub d_reclen: cty::c_ushort,
    pub d_type: cty::c_uchar,
    pub d_name: [cty::c_char; 256usize],
}
#[test]
fn bindgen_test_layout_dirent() {
    assert_eq!(
        ::core::mem::size_of::<dirent>(),
        280usize,
        concat!("Size of: ", stringify!(dirent))
    );
    assert_eq!(
        ::core::mem::align_of::<dirent>(),
        8usize,
        concat!("Alignment of ", stringify!(dirent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dirent>())).d_ino as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dirent>())).d_off as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_off)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dirent>())).d_reclen as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_reclen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dirent>())).d_type as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dirent>())).d_name as *const _ as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_name)
        )
    );
}
pub const DT_UNKNOWN: _bindgen_ty_10 = 0;
pub const DT_FIFO: _bindgen_ty_10 = 1;
pub const DT_CHR: _bindgen_ty_10 = 2;
pub const DT_DIR: _bindgen_ty_10 = 4;
pub const DT_BLK: _bindgen_ty_10 = 6;
pub const DT_REG: _bindgen_ty_10 = 8;
pub const DT_LNK: _bindgen_ty_10 = 10;
pub const DT_SOCK: _bindgen_ty_10 = 12;
pub const DT_WHT: _bindgen_ty_10 = 14;
pub type _bindgen_ty_10 = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __dirstream {
    _unused: [u8; 0],
}
pub type DIR = __dirstream;
extern "C" {
    pub fn opendir(__name: *const cty::c_char) -> *mut DIR;
}
extern "C" {
    pub fn fdopendir(__fd: cty::c_int) -> *mut DIR;
}
extern "C" {
    pub fn closedir(__dirp: *mut DIR) -> cty::c_int;
}
extern "C" {
    pub fn readdir(__dirp: *mut DIR) -> *mut dirent;
}
extern "C" {
    pub fn readdir_r(
        __dirp: *mut DIR,
        __entry: *mut dirent,
        __result: *mut *mut dirent,
    ) -> cty::c_int;
}
extern "C" {
    pub fn rewinddir(__dirp: *mut DIR);
}
extern "C" {
    pub fn seekdir(__dirp: *mut DIR, __pos: cty::c_long);
}
extern "C" {
    pub fn telldir(__dirp: *mut DIR) -> cty::c_long;
}
extern "C" {
    pub fn dirfd(__dirp: *mut DIR) -> cty::c_int;
}
extern "C" {
    pub fn scandir(
        __dir: *const cty::c_char,
        __namelist: *mut *mut *mut dirent,
        __selector: ::core::option::Option<unsafe extern "C" fn(arg1: *const dirent) -> cty::c_int>,
        __cmp: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut *const dirent, arg2: *mut *const dirent) -> cty::c_int,
        >,
    ) -> cty::c_int;
}
extern "C" {
    pub fn alphasort(__e1: *mut *const dirent, __e2: *mut *const dirent) -> cty::c_int;
}
extern "C" {
    pub fn getdirentries(
        __fd: cty::c_int,
        __buf: *mut cty::c_char,
        __nbytes: size_t,
        __basep: *mut __off_t,
    ) -> __ssize_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDir {
    _unused: [u8; 0],
}
pub type GDir = _GDir;
extern "C" {
    pub fn g_dir_open(path: *const gchar, flags: guint, error: *mut *mut GError) -> *mut GDir;
}
extern "C" {
    pub fn g_dir_read_name(dir: *mut GDir) -> *const gchar;
}
extern "C" {
    pub fn g_dir_rewind(dir: *mut GDir);
}
extern "C" {
    pub fn g_dir_close(dir: *mut GDir);
}
extern "C" {
    pub fn g_getenv(variable: *const gchar) -> *const gchar;
}
extern "C" {
    pub fn g_setenv(variable: *const gchar, value: *const gchar, overwrite: gboolean) -> gboolean;
}
extern "C" {
    pub fn g_unsetenv(variable: *const gchar);
}
extern "C" {
    pub fn g_listenv() -> *mut *mut gchar;
}
extern "C" {
    pub fn g_get_environ() -> *mut *mut gchar;
}
extern "C" {
    pub fn g_environ_getenv(envp: *mut *mut gchar, variable: *const gchar) -> *const gchar;
}
extern "C" {
    pub fn g_environ_setenv(
        envp: *mut *mut gchar,
        variable: *const gchar,
        value: *const gchar,
        overwrite: gboolean,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_environ_unsetenv(envp: *mut *mut gchar, variable: *const gchar) -> *mut *mut gchar;
}
pub const GFileError_G_FILE_ERROR_EXIST: GFileError = 0;
pub const GFileError_G_FILE_ERROR_ISDIR: GFileError = 1;
pub const GFileError_G_FILE_ERROR_ACCES: GFileError = 2;
pub const GFileError_G_FILE_ERROR_NAMETOOLONG: GFileError = 3;
pub const GFileError_G_FILE_ERROR_NOENT: GFileError = 4;
pub const GFileError_G_FILE_ERROR_NOTDIR: GFileError = 5;
pub const GFileError_G_FILE_ERROR_NXIO: GFileError = 6;
pub const GFileError_G_FILE_ERROR_NODEV: GFileError = 7;
pub const GFileError_G_FILE_ERROR_ROFS: GFileError = 8;
pub const GFileError_G_FILE_ERROR_TXTBSY: GFileError = 9;
pub const GFileError_G_FILE_ERROR_FAULT: GFileError = 10;
pub const GFileError_G_FILE_ERROR_LOOP: GFileError = 11;
pub const GFileError_G_FILE_ERROR_NOSPC: GFileError = 12;
pub const GFileError_G_FILE_ERROR_NOMEM: GFileError = 13;
pub const GFileError_G_FILE_ERROR_MFILE: GFileError = 14;
pub const GFileError_G_FILE_ERROR_NFILE: GFileError = 15;
pub const GFileError_G_FILE_ERROR_BADF: GFileError = 16;
pub const GFileError_G_FILE_ERROR_INVAL: GFileError = 17;
pub const GFileError_G_FILE_ERROR_PIPE: GFileError = 18;
pub const GFileError_G_FILE_ERROR_AGAIN: GFileError = 19;
pub const GFileError_G_FILE_ERROR_INTR: GFileError = 20;
pub const GFileError_G_FILE_ERROR_IO: GFileError = 21;
pub const GFileError_G_FILE_ERROR_PERM: GFileError = 22;
pub const GFileError_G_FILE_ERROR_NOSYS: GFileError = 23;
pub const GFileError_G_FILE_ERROR_FAILED: GFileError = 24;
pub type GFileError = u32;
pub const GFileTest_G_FILE_TEST_IS_REGULAR: GFileTest = 1;
pub const GFileTest_G_FILE_TEST_IS_SYMLINK: GFileTest = 2;
pub const GFileTest_G_FILE_TEST_IS_DIR: GFileTest = 4;
pub const GFileTest_G_FILE_TEST_IS_EXECUTABLE: GFileTest = 8;
pub const GFileTest_G_FILE_TEST_EXISTS: GFileTest = 16;
pub type GFileTest = u32;
extern "C" {
    pub fn g_file_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_file_error_from_errno(err_no: gint) -> GFileError;
}
extern "C" {
    pub fn g_file_test(filename: *const gchar, test: GFileTest) -> gboolean;
}
extern "C" {
    pub fn g_file_get_contents(
        filename: *const gchar,
        contents: *mut *mut gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_set_contents(
        filename: *const gchar,
        contents: *const gchar,
        length: gssize,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_file_read_link(filename: *const gchar, error: *mut *mut GError) -> *mut gchar;
}
extern "C" {
    pub fn g_mkdtemp(tmpl: *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_mkdtemp_full(tmpl: *mut gchar, mode: gint) -> *mut gchar;
}
extern "C" {
    pub fn g_mkstemp(tmpl: *mut gchar) -> gint;
}
extern "C" {
    pub fn g_mkstemp_full(tmpl: *mut gchar, flags: gint, mode: gint) -> gint;
}
extern "C" {
    pub fn g_file_open_tmp(
        tmpl: *const gchar,
        name_used: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gint;
}
extern "C" {
    pub fn g_dir_make_tmp(tmpl: *const gchar, error: *mut *mut GError) -> *mut gchar;
}
extern "C" {
    pub fn g_build_path(separator: *const gchar, first_element: *const gchar, ...) -> *mut gchar;
}
extern "C" {
    pub fn g_build_pathv(separator: *const gchar, args: *mut *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_build_filename(first_element: *const gchar, ...) -> *mut gchar;
}
extern "C" {
    pub fn g_build_filenamev(args: *mut *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_build_filename_valist(first_element: *const gchar, args: *mut va_list) -> *mut gchar;
}
extern "C" {
    pub fn g_mkdir_with_parents(pathname: *const gchar, mode: gint) -> gint;
}
extern "C" {
    pub fn g_path_is_absolute(file_name: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_path_skip_root(file_name: *const gchar) -> *const gchar;
}
extern "C" {
    pub fn g_basename(file_name: *const gchar) -> *const gchar;
}
extern "C" {
    pub fn g_get_current_dir() -> *mut gchar;
}
extern "C" {
    pub fn g_path_get_basename(file_name: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_path_get_dirname(file_name: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_canonicalize_filename(filename: *const gchar, relative_to: *const gchar)
        -> *mut gchar;
}
extern "C" {
    pub fn g_strip_context(msgid: *const gchar, msgval: *const gchar) -> *const gchar;
}
extern "C" {
    pub fn g_dgettext(domain: *const gchar, msgid: *const gchar) -> *const gchar;
}
extern "C" {
    pub fn g_dcgettext(domain: *const gchar, msgid: *const gchar, category: gint) -> *const gchar;
}
extern "C" {
    pub fn g_dngettext(
        domain: *const gchar,
        msgid: *const gchar,
        msgid_plural: *const gchar,
        n: gulong,
    ) -> *const gchar;
}
extern "C" {
    pub fn g_dpgettext(
        domain: *const gchar,
        msgctxtid: *const gchar,
        msgidoffset: gsize,
    ) -> *const gchar;
}
extern "C" {
    pub fn g_dpgettext2(
        domain: *const gchar,
        context: *const gchar,
        msgid: *const gchar,
    ) -> *const gchar;
}
#[doc = " GMemVTable:"]
#[doc = " @malloc: function to use for allocating memory."]
#[doc = " @realloc: function to use for reallocating memory."]
#[doc = " @free: function to use to free memory."]
#[doc = " @calloc: function to use for allocating zero-filled memory."]
#[doc = " @try_malloc: function to use for allocating memory without a default error handler."]
#[doc = " @try_realloc: function to use for reallocating memory without a default error handler."]
#[doc = ""]
#[doc = " A set of functions used to perform memory allocation. The same #GMemVTable must"]
#[doc = " be used for all allocations in the same program; a call to g_mem_set_vtable(),"]
#[doc = " if it exists, should be prior to any use of GLib."]
#[doc = ""]
#[doc = " This functions related to this has been deprecated in 2.46, and no longer work."]
pub type GMemVTable = _GMemVTable;
extern "C" {
    pub fn g_free(mem: gpointer);
}
extern "C" {
    pub fn g_clear_pointer(pp: *mut gpointer, destroy: GDestroyNotify);
}
extern "C" {
    pub fn g_malloc(n_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_malloc0(n_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_realloc(mem: gpointer, n_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_try_malloc(n_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_try_malloc0(n_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_try_realloc(mem: gpointer, n_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_malloc_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_malloc0_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_realloc_n(mem: gpointer, n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_try_malloc_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_try_malloc0_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
extern "C" {
    pub fn g_try_realloc_n(mem: gpointer, n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMemVTable {
    pub malloc: ::core::option::Option<unsafe extern "C" fn(n_bytes: gsize) -> gpointer>,
    pub realloc:
        ::core::option::Option<unsafe extern "C" fn(mem: gpointer, n_bytes: gsize) -> gpointer>,
    pub free: ::core::option::Option<unsafe extern "C" fn(mem: gpointer)>,
    pub calloc: ::core::option::Option<
        unsafe extern "C" fn(n_blocks: gsize, n_block_bytes: gsize) -> gpointer,
    >,
    pub try_malloc: ::core::option::Option<unsafe extern "C" fn(n_bytes: gsize) -> gpointer>,
    pub try_realloc:
        ::core::option::Option<unsafe extern "C" fn(mem: gpointer, n_bytes: gsize) -> gpointer>,
}
#[test]
fn bindgen_test_layout__GMemVTable() {
    assert_eq!(
        ::core::mem::size_of::<_GMemVTable>(),
        48usize,
        concat!("Size of: ", stringify!(_GMemVTable))
    );
    assert_eq!(
        ::core::mem::align_of::<_GMemVTable>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMemVTable))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GMemVTable>())).malloc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemVTable),
            "::",
            stringify!(malloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GMemVTable>())).realloc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemVTable),
            "::",
            stringify!(realloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GMemVTable>())).free as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemVTable),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GMemVTable>())).calloc as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemVTable),
            "::",
            stringify!(calloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GMemVTable>())).try_malloc as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemVTable),
            "::",
            stringify!(try_malloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GMemVTable>())).try_realloc as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemVTable),
            "::",
            stringify!(try_realloc)
        )
    );
}
extern "C" {
    pub fn g_mem_set_vtable(vtable: *mut GMemVTable);
}
extern "C" {
    pub fn g_mem_is_system_malloc() -> gboolean;
}
extern "C" {
    pub static mut g_mem_gc_friendly: gboolean;
}
extern "C" {
    pub static mut glib_mem_profiler_table: *mut GMemVTable;
}
extern "C" {
    pub fn g_mem_profile();
}
pub type GNode = _GNode;
pub const GTraverseFlags_G_TRAVERSE_LEAVES: GTraverseFlags = 1;
pub const GTraverseFlags_G_TRAVERSE_NON_LEAVES: GTraverseFlags = 2;
pub const GTraverseFlags_G_TRAVERSE_ALL: GTraverseFlags = 3;
pub const GTraverseFlags_G_TRAVERSE_MASK: GTraverseFlags = 3;
pub const GTraverseFlags_G_TRAVERSE_LEAFS: GTraverseFlags = 1;
pub const GTraverseFlags_G_TRAVERSE_NON_LEAFS: GTraverseFlags = 2;
pub type GTraverseFlags = u32;
pub const GTraverseType_G_IN_ORDER: GTraverseType = 0;
pub const GTraverseType_G_PRE_ORDER: GTraverseType = 1;
pub const GTraverseType_G_POST_ORDER: GTraverseType = 2;
pub const GTraverseType_G_LEVEL_ORDER: GTraverseType = 3;
pub type GTraverseType = u32;
pub type GNodeTraverseFunc =
    ::core::option::Option<unsafe extern "C" fn(node: *mut GNode, data: gpointer) -> gboolean>;
pub type GNodeForeachFunc =
    ::core::option::Option<unsafe extern "C" fn(node: *mut GNode, data: gpointer)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GNode {
    pub data: gpointer,
    pub next: *mut GNode,
    pub prev: *mut GNode,
    pub parent: *mut GNode,
    pub children: *mut GNode,
}
#[test]
fn bindgen_test_layout__GNode() {
    assert_eq!(
        ::core::mem::size_of::<_GNode>(),
        40usize,
        concat!("Size of: ", stringify!(_GNode))
    );
    assert_eq!(
        ::core::mem::align_of::<_GNode>(),
        8usize,
        concat!("Alignment of ", stringify!(_GNode))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GNode>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNode),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GNode>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNode),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GNode>())).prev as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNode),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GNode>())).parent as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNode),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GNode>())).children as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNode),
            "::",
            stringify!(children)
        )
    );
}
extern "C" {
    pub fn g_node_new(data: gpointer) -> *mut GNode;
}
extern "C" {
    pub fn g_node_destroy(root: *mut GNode);
}
extern "C" {
    pub fn g_node_unlink(node: *mut GNode);
}
extern "C" {
    pub fn g_node_copy_deep(node: *mut GNode, copy_func: GCopyFunc, data: gpointer) -> *mut GNode;
}
extern "C" {
    pub fn g_node_copy(node: *mut GNode) -> *mut GNode;
}
extern "C" {
    pub fn g_node_insert(parent: *mut GNode, position: gint, node: *mut GNode) -> *mut GNode;
}
extern "C" {
    pub fn g_node_insert_before(
        parent: *mut GNode,
        sibling: *mut GNode,
        node: *mut GNode,
    ) -> *mut GNode;
}
extern "C" {
    pub fn g_node_insert_after(
        parent: *mut GNode,
        sibling: *mut GNode,
        node: *mut GNode,
    ) -> *mut GNode;
}
extern "C" {
    pub fn g_node_prepend(parent: *mut GNode, node: *mut GNode) -> *mut GNode;
}
extern "C" {
    pub fn g_node_n_nodes(root: *mut GNode, flags: GTraverseFlags) -> guint;
}
extern "C" {
    pub fn g_node_get_root(node: *mut GNode) -> *mut GNode;
}
extern "C" {
    pub fn g_node_is_ancestor(node: *mut GNode, descendant: *mut GNode) -> gboolean;
}
extern "C" {
    pub fn g_node_depth(node: *mut GNode) -> guint;
}
extern "C" {
    pub fn g_node_find(
        root: *mut GNode,
        order: GTraverseType,
        flags: GTraverseFlags,
        data: gpointer,
    ) -> *mut GNode;
}
extern "C" {
    pub fn g_node_traverse(
        root: *mut GNode,
        order: GTraverseType,
        flags: GTraverseFlags,
        max_depth: gint,
        func: GNodeTraverseFunc,
        data: gpointer,
    );
}
extern "C" {
    pub fn g_node_max_height(root: *mut GNode) -> guint;
}
extern "C" {
    pub fn g_node_children_foreach(
        node: *mut GNode,
        flags: GTraverseFlags,
        func: GNodeForeachFunc,
        data: gpointer,
    );
}
extern "C" {
    pub fn g_node_reverse_children(node: *mut GNode);
}
extern "C" {
    pub fn g_node_n_children(node: *mut GNode) -> guint;
}
extern "C" {
    pub fn g_node_nth_child(node: *mut GNode, n: guint) -> *mut GNode;
}
extern "C" {
    pub fn g_node_last_child(node: *mut GNode) -> *mut GNode;
}
extern "C" {
    pub fn g_node_find_child(node: *mut GNode, flags: GTraverseFlags, data: gpointer)
        -> *mut GNode;
}
extern "C" {
    pub fn g_node_child_position(node: *mut GNode, child: *mut GNode) -> gint;
}
extern "C" {
    pub fn g_node_child_index(node: *mut GNode, data: gpointer) -> gint;
}
extern "C" {
    pub fn g_node_first_sibling(node: *mut GNode) -> *mut GNode;
}
extern "C" {
    pub fn g_node_last_sibling(node: *mut GNode) -> *mut GNode;
}
pub type GList = _GList;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GList {
    pub data: gpointer,
    pub next: *mut GList,
    pub prev: *mut GList,
}
#[test]
fn bindgen_test_layout__GList() {
    assert_eq!(
        ::core::mem::size_of::<_GList>(),
        24usize,
        concat!("Size of: ", stringify!(_GList))
    );
    assert_eq!(
        ::core::mem::align_of::<_GList>(),
        8usize,
        concat!("Alignment of ", stringify!(_GList))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GList>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GList),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GList>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GList),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GList>())).prev as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GList),
            "::",
            stringify!(prev)
        )
    );
}
extern "C" {
    pub fn g_list_alloc() -> *mut GList;
}
extern "C" {
    pub fn g_list_free(list: *mut GList);
}
extern "C" {
    pub fn g_list_free_1(list: *mut GList);
}
extern "C" {
    pub fn g_list_free_full(list: *mut GList, free_func: GDestroyNotify);
}
extern "C" {
    pub fn g_list_append(list: *mut GList, data: gpointer) -> *mut GList;
}
extern "C" {
    pub fn g_list_prepend(list: *mut GList, data: gpointer) -> *mut GList;
}
extern "C" {
    pub fn g_list_insert(list: *mut GList, data: gpointer, position: gint) -> *mut GList;
}
extern "C" {
    pub fn g_list_insert_sorted(list: *mut GList, data: gpointer, func: GCompareFunc)
        -> *mut GList;
}
extern "C" {
    pub fn g_list_insert_sorted_with_data(
        list: *mut GList,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_list_insert_before(
        list: *mut GList,
        sibling: *mut GList,
        data: gpointer,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_list_insert_before_link(
        list: *mut GList,
        sibling: *mut GList,
        link_: *mut GList,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_list_concat(list1: *mut GList, list2: *mut GList) -> *mut GList;
}
extern "C" {
    pub fn g_list_remove(list: *mut GList, data: gconstpointer) -> *mut GList;
}
extern "C" {
    pub fn g_list_remove_all(list: *mut GList, data: gconstpointer) -> *mut GList;
}
extern "C" {
    pub fn g_list_remove_link(list: *mut GList, llink: *mut GList) -> *mut GList;
}
extern "C" {
    pub fn g_list_delete_link(list: *mut GList, link_: *mut GList) -> *mut GList;
}
extern "C" {
    pub fn g_list_reverse(list: *mut GList) -> *mut GList;
}
extern "C" {
    pub fn g_list_copy(list: *mut GList) -> *mut GList;
}
extern "C" {
    pub fn g_list_copy_deep(list: *mut GList, func: GCopyFunc, user_data: gpointer) -> *mut GList;
}
extern "C" {
    pub fn g_list_nth(list: *mut GList, n: guint) -> *mut GList;
}
extern "C" {
    pub fn g_list_nth_prev(list: *mut GList, n: guint) -> *mut GList;
}
extern "C" {
    pub fn g_list_find(list: *mut GList, data: gconstpointer) -> *mut GList;
}
extern "C" {
    pub fn g_list_find_custom(
        list: *mut GList,
        data: gconstpointer,
        func: GCompareFunc,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_list_position(list: *mut GList, llink: *mut GList) -> gint;
}
extern "C" {
    pub fn g_list_index(list: *mut GList, data: gconstpointer) -> gint;
}
extern "C" {
    pub fn g_list_last(list: *mut GList) -> *mut GList;
}
extern "C" {
    pub fn g_list_first(list: *mut GList) -> *mut GList;
}
extern "C" {
    pub fn g_list_length(list: *mut GList) -> guint;
}
extern "C" {
    pub fn g_list_foreach(list: *mut GList, func: GFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_list_sort(list: *mut GList, compare_func: GCompareFunc) -> *mut GList;
}
extern "C" {
    pub fn g_list_sort_with_data(
        list: *mut GList,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_list_nth_data(list: *mut GList, n: guint) -> gpointer;
}
extern "C" {
    pub fn g_clear_list(list_ptr: *mut *mut GList, destroy: GDestroyNotify);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHashTable {
    _unused: [u8; 0],
}
pub type GHashTable = _GHashTable;
pub type GHRFunc = ::core::option::Option<
    unsafe extern "C" fn(key: gpointer, value: gpointer, user_data: gpointer) -> gboolean,
>;
pub type GHashTableIter = _GHashTableIter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHashTableIter {
    pub dummy1: gpointer,
    pub dummy2: gpointer,
    pub dummy3: gpointer,
    pub dummy4: cty::c_int,
    pub dummy5: gboolean,
    pub dummy6: gpointer,
}
#[test]
fn bindgen_test_layout__GHashTableIter() {
    assert_eq!(
        ::core::mem::size_of::<_GHashTableIter>(),
        40usize,
        concat!("Size of: ", stringify!(_GHashTableIter))
    );
    assert_eq!(
        ::core::mem::align_of::<_GHashTableIter>(),
        8usize,
        concat!("Alignment of ", stringify!(_GHashTableIter))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GHashTableIter>())).dummy1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHashTableIter),
            "::",
            stringify!(dummy1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GHashTableIter>())).dummy2 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHashTableIter),
            "::",
            stringify!(dummy2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GHashTableIter>())).dummy3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHashTableIter),
            "::",
            stringify!(dummy3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GHashTableIter>())).dummy4 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHashTableIter),
            "::",
            stringify!(dummy4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GHashTableIter>())).dummy5 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHashTableIter),
            "::",
            stringify!(dummy5)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GHashTableIter>())).dummy6 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHashTableIter),
            "::",
            stringify!(dummy6)
        )
    );
}
extern "C" {
    pub fn g_hash_table_new(hash_func: GHashFunc, key_equal_func: GEqualFunc) -> *mut GHashTable;
}
extern "C" {
    pub fn g_hash_table_new_full(
        hash_func: GHashFunc,
        key_equal_func: GEqualFunc,
        key_destroy_func: GDestroyNotify,
        value_destroy_func: GDestroyNotify,
    ) -> *mut GHashTable;
}
extern "C" {
    pub fn g_hash_table_destroy(hash_table: *mut GHashTable);
}
extern "C" {
    pub fn g_hash_table_insert(
        hash_table: *mut GHashTable,
        key: gpointer,
        value: gpointer,
    ) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_replace(
        hash_table: *mut GHashTable,
        key: gpointer,
        value: gpointer,
    ) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_add(hash_table: *mut GHashTable, key: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_remove(hash_table: *mut GHashTable, key: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_remove_all(hash_table: *mut GHashTable);
}
extern "C" {
    pub fn g_hash_table_steal(hash_table: *mut GHashTable, key: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_steal_extended(
        hash_table: *mut GHashTable,
        lookup_key: gconstpointer,
        stolen_key: *mut gpointer,
        stolen_value: *mut gpointer,
    ) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_steal_all(hash_table: *mut GHashTable);
}
extern "C" {
    pub fn g_hash_table_lookup(hash_table: *mut GHashTable, key: gconstpointer) -> gpointer;
}
extern "C" {
    pub fn g_hash_table_contains(hash_table: *mut GHashTable, key: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_lookup_extended(
        hash_table: *mut GHashTable,
        lookup_key: gconstpointer,
        orig_key: *mut gpointer,
        value: *mut gpointer,
    ) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_foreach(hash_table: *mut GHashTable, func: GHFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_hash_table_find(
        hash_table: *mut GHashTable,
        predicate: GHRFunc,
        user_data: gpointer,
    ) -> gpointer;
}
extern "C" {
    pub fn g_hash_table_foreach_remove(
        hash_table: *mut GHashTable,
        func: GHRFunc,
        user_data: gpointer,
    ) -> guint;
}
extern "C" {
    pub fn g_hash_table_foreach_steal(
        hash_table: *mut GHashTable,
        func: GHRFunc,
        user_data: gpointer,
    ) -> guint;
}
extern "C" {
    pub fn g_hash_table_size(hash_table: *mut GHashTable) -> guint;
}
extern "C" {
    pub fn g_hash_table_get_keys(hash_table: *mut GHashTable) -> *mut GList;
}
extern "C" {
    pub fn g_hash_table_get_values(hash_table: *mut GHashTable) -> *mut GList;
}
extern "C" {
    pub fn g_hash_table_get_keys_as_array(
        hash_table: *mut GHashTable,
        length: *mut guint,
    ) -> *mut gpointer;
}
extern "C" {
    pub fn g_hash_table_iter_init(iter: *mut GHashTableIter, hash_table: *mut GHashTable);
}
extern "C" {
    pub fn g_hash_table_iter_next(
        iter: *mut GHashTableIter,
        key: *mut gpointer,
        value: *mut gpointer,
    ) -> gboolean;
}
extern "C" {
    pub fn g_hash_table_iter_get_hash_table(iter: *mut GHashTableIter) -> *mut GHashTable;
}
extern "C" {
    pub fn g_hash_table_iter_remove(iter: *mut GHashTableIter);
}
extern "C" {
    pub fn g_hash_table_iter_replace(iter: *mut GHashTableIter, value: gpointer);
}
extern "C" {
    pub fn g_hash_table_iter_steal(iter: *mut GHashTableIter);
}
extern "C" {
    pub fn g_hash_table_ref(hash_table: *mut GHashTable) -> *mut GHashTable;
}
extern "C" {
    pub fn g_hash_table_unref(hash_table: *mut GHashTable);
}
extern "C" {
    pub fn g_str_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_str_hash(v: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_int_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_int_hash(v: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_int64_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_int64_hash(v: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_double_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_double_hash(v: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_direct_hash(v: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_direct_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHmac {
    _unused: [u8; 0],
}
#[doc = " GHmac:"]
#[doc = ""]
#[doc = " An opaque structure representing a HMAC operation."]
#[doc = " To create a new GHmac, use g_hmac_new(). To free"]
#[doc = " a GHmac, use g_hmac_unref()."]
#[doc = ""]
#[doc = " Since: 2.30"]
pub type GHmac = _GHmac;
extern "C" {
    pub fn g_hmac_new(digest_type: GChecksumType, key: *const guchar, key_len: gsize)
        -> *mut GHmac;
}
extern "C" {
    pub fn g_hmac_copy(hmac: *const GHmac) -> *mut GHmac;
}
extern "C" {
    pub fn g_hmac_ref(hmac: *mut GHmac) -> *mut GHmac;
}
extern "C" {
    pub fn g_hmac_unref(hmac: *mut GHmac);
}
extern "C" {
    pub fn g_hmac_update(hmac: *mut GHmac, data: *const guchar, length: gssize);
}
extern "C" {
    pub fn g_hmac_get_string(hmac: *mut GHmac) -> *const gchar;
}
extern "C" {
    pub fn g_hmac_get_digest(hmac: *mut GHmac, buffer: *mut guint8, digest_len: *mut gsize);
}
extern "C" {
    pub fn g_compute_hmac_for_data(
        digest_type: GChecksumType,
        key: *const guchar,
        key_len: gsize,
        data: *const guchar,
        length: gsize,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_compute_hmac_for_string(
        digest_type: GChecksumType,
        key: *const guchar,
        key_len: gsize,
        str_: *const gchar,
        length: gssize,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_compute_hmac_for_bytes(
        digest_type: GChecksumType,
        key: *mut GBytes,
        data: *mut GBytes,
    ) -> *mut gchar;
}
pub type GHook = _GHook;
pub type GHookList = _GHookList;
pub type GHookCompareFunc =
    ::core::option::Option<unsafe extern "C" fn(new_hook: *mut GHook, sibling: *mut GHook) -> gint>;
pub type GHookFindFunc =
    ::core::option::Option<unsafe extern "C" fn(hook: *mut GHook, data: gpointer) -> gboolean>;
pub type GHookMarshaller =
    ::core::option::Option<unsafe extern "C" fn(hook: *mut GHook, marshal_data: gpointer)>;
pub type GHookCheckMarshaller = ::core::option::Option<
    unsafe extern "C" fn(hook: *mut GHook, marshal_data: gpointer) -> gboolean,
>;
pub type GHookFunc = ::core::option::Option<unsafe extern "C" fn(data: gpointer)>;
pub type GHookCheckFunc = ::core::option::Option<unsafe extern "C" fn(data: gpointer) -> gboolean>;
pub type GHookFinalizeFunc =
    ::core::option::Option<unsafe extern "C" fn(hook_list: *mut GHookList, hook: *mut GHook)>;
pub const GHookFlagMask_G_HOOK_FLAG_ACTIVE: GHookFlagMask = 1;
pub const GHookFlagMask_G_HOOK_FLAG_IN_CALL: GHookFlagMask = 2;
pub const GHookFlagMask_G_HOOK_FLAG_MASK: GHookFlagMask = 15;
pub type GHookFlagMask = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHookList {
    pub seq_id: gulong,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub hooks: *mut GHook,
    pub dummy3: gpointer,
    pub finalize_hook: GHookFinalizeFunc,
    pub dummy: [gpointer; 2usize],
}
#[test]
fn bindgen_test_layout__GHookList() {
    assert_eq!(
        ::core::mem::size_of::<_GHookList>(),
        56usize,
        concat!("Size of: ", stringify!(_GHookList))
    );
    assert_eq!(
        ::core::mem::align_of::<_GHookList>(),
        8usize,
        concat!("Alignment of ", stringify!(_GHookList))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GHookList>())).seq_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHookList),
            "::",
            stringify!(seq_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GHookList>())).hooks as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHookList),
            "::",
            stringify!(hooks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GHookList>())).dummy3 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHookList),
            "::",
            stringify!(dummy3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GHookList>())).finalize_hook as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHookList),
            "::",
            stringify!(finalize_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GHookList>())).dummy as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHookList),
            "::",
            stringify!(dummy)
        )
    );
}
impl _GHookList {
    #[inline]
    pub fn hook_size(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_hook_size(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn is_setup(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_setup(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hook_size: guint,
        is_setup: guint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let hook_size: u32 = unsafe { ::core::mem::transmute(hook_size) };
            hook_size as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let is_setup: u32 = unsafe { ::core::mem::transmute(is_setup) };
            is_setup as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHook {
    pub data: gpointer,
    pub next: *mut GHook,
    pub prev: *mut GHook,
    pub ref_count: guint,
    pub hook_id: gulong,
    pub flags: guint,
    pub func: gpointer,
    pub destroy: GDestroyNotify,
}
#[test]
fn bindgen_test_layout__GHook() {
    assert_eq!(
        ::core::mem::size_of::<_GHook>(),
        64usize,
        concat!("Size of: ", stringify!(_GHook))
    );
    assert_eq!(
        ::core::mem::align_of::<_GHook>(),
        8usize,
        concat!("Alignment of ", stringify!(_GHook))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GHook>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GHook>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GHook>())).prev as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GHook>())).ref_count as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GHook>())).hook_id as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(hook_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GHook>())).flags as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GHook>())).func as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GHook>())).destroy as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(destroy)
        )
    );
}
extern "C" {
    pub fn g_hook_list_init(hook_list: *mut GHookList, hook_size: guint);
}
extern "C" {
    pub fn g_hook_list_clear(hook_list: *mut GHookList);
}
extern "C" {
    pub fn g_hook_alloc(hook_list: *mut GHookList) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_free(hook_list: *mut GHookList, hook: *mut GHook);
}
extern "C" {
    pub fn g_hook_ref(hook_list: *mut GHookList, hook: *mut GHook) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_unref(hook_list: *mut GHookList, hook: *mut GHook);
}
extern "C" {
    pub fn g_hook_destroy(hook_list: *mut GHookList, hook_id: gulong) -> gboolean;
}
extern "C" {
    pub fn g_hook_destroy_link(hook_list: *mut GHookList, hook: *mut GHook);
}
extern "C" {
    pub fn g_hook_prepend(hook_list: *mut GHookList, hook: *mut GHook);
}
extern "C" {
    pub fn g_hook_insert_before(hook_list: *mut GHookList, sibling: *mut GHook, hook: *mut GHook);
}
extern "C" {
    pub fn g_hook_insert_sorted(
        hook_list: *mut GHookList,
        hook: *mut GHook,
        func: GHookCompareFunc,
    );
}
extern "C" {
    pub fn g_hook_get(hook_list: *mut GHookList, hook_id: gulong) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_find(
        hook_list: *mut GHookList,
        need_valids: gboolean,
        func: GHookFindFunc,
        data: gpointer,
    ) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_find_data(
        hook_list: *mut GHookList,
        need_valids: gboolean,
        data: gpointer,
    ) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_find_func(
        hook_list: *mut GHookList,
        need_valids: gboolean,
        func: gpointer,
    ) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_find_func_data(
        hook_list: *mut GHookList,
        need_valids: gboolean,
        func: gpointer,
        data: gpointer,
    ) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_first_valid(hook_list: *mut GHookList, may_be_in_call: gboolean) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_next_valid(
        hook_list: *mut GHookList,
        hook: *mut GHook,
        may_be_in_call: gboolean,
    ) -> *mut GHook;
}
extern "C" {
    pub fn g_hook_compare_ids(new_hook: *mut GHook, sibling: *mut GHook) -> gint;
}
extern "C" {
    pub fn g_hook_list_invoke(hook_list: *mut GHookList, may_recurse: gboolean);
}
extern "C" {
    pub fn g_hook_list_invoke_check(hook_list: *mut GHookList, may_recurse: gboolean);
}
extern "C" {
    pub fn g_hook_list_marshal(
        hook_list: *mut GHookList,
        may_recurse: gboolean,
        marshaller: GHookMarshaller,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_hook_list_marshal_check(
        hook_list: *mut GHookList,
        may_recurse: gboolean,
        marshaller: GHookCheckMarshaller,
        marshal_data: gpointer,
    );
}
extern "C" {
    pub fn g_hostname_is_non_ascii(hostname: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_hostname_is_ascii_encoded(hostname: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_hostname_is_ip_address(hostname: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_hostname_to_ascii(hostname: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_hostname_to_unicode(hostname: *const gchar) -> *mut gchar;
}
pub type GPollFD = _GPollFD;
#[doc = " GPollFunc:"]
#[doc = " @ufds: an array of #GPollFD elements"]
#[doc = " @nfsd: the number of elements in @ufds"]
#[doc = " @timeout_: the maximum time to wait for an event of the file descriptors."]
#[doc = "     A negative value indicates an infinite timeout."]
#[doc = ""]
#[doc = " Specifies the type of function passed to g_main_context_set_poll_func()."]
#[doc = " The semantics of the function should match those of the poll() system call."]
#[doc = ""]
#[doc = " Returns: the number of #GPollFD elements which have events or errors"]
#[doc = "     reported, or -1 if an error occurred."]
pub type GPollFunc = ::core::option::Option<
    unsafe extern "C" fn(ufds: *mut GPollFD, nfsd: guint, timeout_: gint) -> gint,
>;
#[doc = " GPollFD:"]
#[doc = " @fd: the file descriptor to poll (or a HANDLE on Win32)"]
#[doc = " @events: a bitwise combination from #GIOCondition, specifying which"]
#[doc = "     events should be polled for. Typically for reading from a file"]
#[doc = "     descriptor you would use %G_IO_IN | %G_IO_HUP | %G_IO_ERR, and"]
#[doc = "     for writing you would use %G_IO_OUT | %G_IO_ERR."]
#[doc = " @revents: a bitwise combination of flags from #GIOCondition, returned"]
#[doc = "     from the poll() function to indicate which events occurred."]
#[doc = ""]
#[doc = " Represents a file descriptor, which events to poll for, and which events"]
#[doc = " occurred."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPollFD {
    pub fd: gint,
    pub events: gushort,
    pub revents: gushort,
}
#[test]
fn bindgen_test_layout__GPollFD() {
    assert_eq!(
        ::core::mem::size_of::<_GPollFD>(),
        8usize,
        concat!("Size of: ", stringify!(_GPollFD))
    );
    assert_eq!(
        ::core::mem::align_of::<_GPollFD>(),
        4usize,
        concat!("Alignment of ", stringify!(_GPollFD))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GPollFD>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPollFD),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GPollFD>())).events as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPollFD),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GPollFD>())).revents as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPollFD),
            "::",
            stringify!(revents)
        )
    );
}
extern "C" {
    #[doc = " G_POLLFD_FORMAT:"]
    #[doc = ""]
    #[doc = " A format specifier that can be used in printf()-style format strings"]
    #[doc = " when printing the @fd member of a #GPollFD."]
    pub fn g_poll(fds: *mut GPollFD, nfds: guint, timeout: gint) -> gint;
}
pub type GSList = _GSList;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSList {
    pub data: gpointer,
    pub next: *mut GSList,
}
#[test]
fn bindgen_test_layout__GSList() {
    assert_eq!(
        ::core::mem::size_of::<_GSList>(),
        16usize,
        concat!("Size of: ", stringify!(_GSList))
    );
    assert_eq!(
        ::core::mem::align_of::<_GSList>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSList))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GSList>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSList),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GSList>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSList),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    pub fn g_slist_alloc() -> *mut GSList;
}
extern "C" {
    pub fn g_slist_free(list: *mut GSList);
}
extern "C" {
    pub fn g_slist_free_1(list: *mut GSList);
}
extern "C" {
    pub fn g_slist_free_full(list: *mut GSList, free_func: GDestroyNotify);
}
extern "C" {
    pub fn g_slist_append(list: *mut GSList, data: gpointer) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_prepend(list: *mut GSList, data: gpointer) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_insert(list: *mut GSList, data: gpointer, position: gint) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_insert_sorted(
        list: *mut GSList,
        data: gpointer,
        func: GCompareFunc,
    ) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_insert_sorted_with_data(
        list: *mut GSList,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_insert_before(
        slist: *mut GSList,
        sibling: *mut GSList,
        data: gpointer,
    ) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_concat(list1: *mut GSList, list2: *mut GSList) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_remove(list: *mut GSList, data: gconstpointer) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_remove_all(list: *mut GSList, data: gconstpointer) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_remove_link(list: *mut GSList, link_: *mut GSList) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_delete_link(list: *mut GSList, link_: *mut GSList) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_reverse(list: *mut GSList) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_copy(list: *mut GSList) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_copy_deep(
        list: *mut GSList,
        func: GCopyFunc,
        user_data: gpointer,
    ) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_nth(list: *mut GSList, n: guint) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_find(list: *mut GSList, data: gconstpointer) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_find_custom(
        list: *mut GSList,
        data: gconstpointer,
        func: GCompareFunc,
    ) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_position(list: *mut GSList, llink: *mut GSList) -> gint;
}
extern "C" {
    pub fn g_slist_index(list: *mut GSList, data: gconstpointer) -> gint;
}
extern "C" {
    pub fn g_slist_last(list: *mut GSList) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_length(list: *mut GSList) -> guint;
}
extern "C" {
    pub fn g_slist_foreach(list: *mut GSList, func: GFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_slist_sort(list: *mut GSList, compare_func: GCompareFunc) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_sort_with_data(
        list: *mut GSList,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GSList;
}
extern "C" {
    pub fn g_slist_nth_data(list: *mut GSList, n: guint) -> gpointer;
}
extern "C" {
    pub fn g_clear_slist(slist_ptr: *mut *mut GSList, destroy: GDestroyNotify);
}
pub const GIOCondition_G_IO_IN: GIOCondition = 1;
pub const GIOCondition_G_IO_OUT: GIOCondition = 4;
pub const GIOCondition_G_IO_PRI: GIOCondition = 2;
pub const GIOCondition_G_IO_ERR: GIOCondition = 8;
pub const GIOCondition_G_IO_HUP: GIOCondition = 16;
pub const GIOCondition_G_IO_NVAL: GIOCondition = 32;
pub type GIOCondition = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMainContext {
    _unused: [u8; 0],
}
#[doc = " GMainContext:"]
#[doc = ""]
#[doc = " The `GMainContext` struct is an opaque data"]
#[doc = " type representing a set of sources to be handled in a main loop."]
pub type GMainContext = _GMainContext;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMainLoop {
    _unused: [u8; 0],
}
#[doc = " GMainLoop:"]
#[doc = ""]
#[doc = " The `GMainLoop` struct is an opaque data type"]
#[doc = " representing the main event loop of a GLib or GTK+ application."]
pub type GMainLoop = _GMainLoop;
#[doc = " GSource:"]
#[doc = ""]
#[doc = " The `GSource` struct is an opaque data type"]
#[doc = " representing an event source."]
pub type GSource = _GSource;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSourcePrivate {
    _unused: [u8; 0],
}
pub type GSourcePrivate = _GSourcePrivate;
#[doc = " GSourceCallbackFuncs:"]
#[doc = " @ref: Called when a reference is added to the callback object"]
#[doc = " @unref: Called when a reference to the callback object is dropped"]
#[doc = " @get: Called to extract the callback function and data from the"]
#[doc = "     callback object."]
#[doc = ""]
#[doc = " The `GSourceCallbackFuncs` struct contains"]
#[doc = " functions for managing callback objects."]
pub type GSourceCallbackFuncs = _GSourceCallbackFuncs;
#[doc = " GSourceFuncs:"]
#[doc = " @prepare: Called before all the file descriptors are polled. If the"]
#[doc = "     source can determine that it is ready here (without waiting for the"]
#[doc = "     results of the poll() call) it should return %TRUE. It can also return"]
#[doc = "     a @timeout_ value which should be the maximum timeout (in milliseconds)"]
#[doc = "     which should be passed to the poll() call. The actual timeout used will"]
#[doc = "     be -1 if all sources returned -1, or it will be the minimum of all"]
#[doc = "     the @timeout_ values returned which were >= 0.  Since 2.36 this may"]
#[doc = "     be %NULL, in which case the effect is as if the function always returns"]
#[doc = "     %FALSE with a timeout of -1.  If @prepare returns a"]
#[doc = "     timeout and the source also has a ready time set, then the"]
#[doc = "     lower of the two will be used."]
#[doc = " @check: Called after all the file descriptors are polled. The source"]
#[doc = "     should return %TRUE if it is ready to be dispatched. Note that some"]
#[doc = "     time may have passed since the previous prepare function was called,"]
#[doc = "     so the source should be checked again here.  Since 2.36 this may"]
#[doc = "     be %NULL, in which case the effect is as if the function always returns"]
#[doc = "     %FALSE."]
#[doc = " @dispatch: Called to dispatch the event source, after it has returned"]
#[doc = "     %TRUE in either its @prepare or its @check function, or if a ready time"]
#[doc = "     has been reached. The @dispatch function receives a callback function and"]
#[doc = "     user data. The callback function may be %NULL if the source was never"]
#[doc = "     connected to a callback using g_source_set_callback(). The @dispatch"]
#[doc = "     function should call the callback function with @user_data and whatever"]
#[doc = "     additional parameters are needed for this type of event source. The"]
#[doc = "     return value of the @dispatch function should be #G_SOURCE_REMOVE if the"]
#[doc = "     source should be removed or #G_SOURCE_CONTINUE to keep it."]
#[doc = " @finalize: Called when the source is finalized. At this point, the source"]
#[doc = "     will have been destroyed, had its callback cleared, and have been removed"]
#[doc = "     from its #GMainContext, but it will still have its final reference count,"]
#[doc = "     so methods can be called on it from within this function."]
#[doc = ""]
#[doc = " The `GSourceFuncs` struct contains a table of"]
#[doc = " functions used to handle event sources in a generic manner."]
#[doc = ""]
#[doc = " For idle sources, the prepare and check functions always return %TRUE"]
#[doc = " to indicate that the source is always ready to be processed. The prepare"]
#[doc = " function also returns a timeout value of 0 to ensure that the poll() call"]
#[doc = " doesn't block (since that would be time wasted which could have been spent"]
#[doc = " running the idle function)."]
#[doc = ""]
#[doc = " For timeout sources, the prepare and check functions both return %TRUE"]
#[doc = " if the timeout interval has expired. The prepare function also returns"]
#[doc = " a timeout value to ensure that the poll() call doesn't block too long"]
#[doc = " and miss the next timeout."]
#[doc = ""]
#[doc = " For file descriptor sources, the prepare function typically returns %FALSE,"]
#[doc = " since it must wait until poll() has been called before it knows whether"]
#[doc = " any events need to be processed. It sets the returned timeout to -1 to"]
#[doc = " indicate that it doesn't mind how long the poll() call blocks. In the"]
#[doc = " check function, it tests the results of the poll() call to see if the"]
#[doc = " required condition has been met, and returns %TRUE if so."]
pub type GSourceFuncs = _GSourceFuncs;
#[doc = " GSourceFunc:"]
#[doc = " @user_data: data passed to the function, set when the source was"]
#[doc = "     created with one of the above functions"]
#[doc = ""]
#[doc = " Specifies the type of function passed to g_timeout_add(),"]
#[doc = " g_timeout_add_full(), g_idle_add(), and g_idle_add_full()."]
#[doc = ""]
#[doc = " When calling g_source_set_callback(), you may need to cast a function of a"]
#[doc = " different type to this type. Use G_SOURCE_FUNC() to avoid warnings about"]
#[doc = " incompatible function types."]
#[doc = ""]
#[doc = " Returns: %FALSE if the source should be removed. #G_SOURCE_CONTINUE and"]
#[doc = " #G_SOURCE_REMOVE are more memorable names for the return value."]
pub type GSourceFunc =
    ::core::option::Option<unsafe extern "C" fn(user_data: gpointer) -> gboolean>;
#[doc = " GChildWatchFunc:"]
#[doc = " @pid: the process id of the child process"]
#[doc = " @status: Status information about the child process, encoded"]
#[doc = "     in a platform-specific manner"]
#[doc = " @user_data: user data passed to g_child_watch_add()"]
#[doc = ""]
#[doc = " Prototype of a #GChildWatchSource callback, called when a child"]
#[doc = " process has exited.  To interpret @status, see the documentation"]
#[doc = " for g_spawn_check_exit_status()."]
pub type GChildWatchFunc =
    ::core::option::Option<unsafe extern "C" fn(pid: GPid, status: gint, user_data: gpointer)>;
#[doc = " GSourceDisposeFunc:"]
#[doc = " @source: #GSource that is currently being disposed"]
#[doc = ""]
#[doc = " Dispose function for @source. See g_source_set_dispose_function() for"]
#[doc = " details."]
#[doc = ""]
#[doc = " Since: 2.64"]
pub type GSourceDisposeFunc = ::core::option::Option<unsafe extern "C" fn(source: *mut GSource)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSource {
    pub callback_data: gpointer,
    pub callback_funcs: *mut GSourceCallbackFuncs,
    pub source_funcs: *const GSourceFuncs,
    pub ref_count: guint,
    pub context: *mut GMainContext,
    pub priority: gint,
    pub flags: guint,
    pub source_id: guint,
    pub poll_fds: *mut GSList,
    pub prev: *mut GSource,
    pub next: *mut GSource,
    pub name: *mut cty::c_char,
    pub priv_: *mut GSourcePrivate,
}
#[test]
fn bindgen_test_layout__GSource() {
    assert_eq!(
        ::core::mem::size_of::<_GSource>(),
        96usize,
        concat!("Size of: ", stringify!(_GSource))
    );
    assert_eq!(
        ::core::mem::align_of::<_GSource>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSource))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GSource>())).callback_data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(callback_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GSource>())).callback_funcs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(callback_funcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GSource>())).source_funcs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(source_funcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GSource>())).ref_count as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GSource>())).context as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GSource>())).priority as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GSource>())).flags as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GSource>())).source_id as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(source_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GSource>())).poll_fds as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(poll_fds)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GSource>())).prev as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GSource>())).next as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GSource>())).name as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GSource>())).priv_ as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSourceCallbackFuncs {
    pub ref_: ::core::option::Option<unsafe extern "C" fn(cb_data: gpointer)>,
    pub unref: ::core::option::Option<unsafe extern "C" fn(cb_data: gpointer)>,
    pub get: ::core::option::Option<
        unsafe extern "C" fn(
            cb_data: gpointer,
            source: *mut GSource,
            func: *mut GSourceFunc,
            data: *mut gpointer,
        ),
    >,
}
#[test]
fn bindgen_test_layout__GSourceCallbackFuncs() {
    assert_eq!(
        ::core::mem::size_of::<_GSourceCallbackFuncs>(),
        24usize,
        concat!("Size of: ", stringify!(_GSourceCallbackFuncs))
    );
    assert_eq!(
        ::core::mem::align_of::<_GSourceCallbackFuncs>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSourceCallbackFuncs))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GSourceCallbackFuncs>())).ref_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceCallbackFuncs),
            "::",
            stringify!(ref_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GSourceCallbackFuncs>())).unref as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceCallbackFuncs),
            "::",
            stringify!(unref)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GSourceCallbackFuncs>())).get as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceCallbackFuncs),
            "::",
            stringify!(get)
        )
    );
}
#[doc = " GSourceDummyMarshal:"]
#[doc = ""]
#[doc = " This is just a placeholder for #GClosureMarshal,"]
#[doc = " which cannot be used here for dependency reasons."]
pub type GSourceDummyMarshal = ::core::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSourceFuncs {
    pub prepare: ::core::option::Option<
        unsafe extern "C" fn(source: *mut GSource, timeout_: *mut gint) -> gboolean,
    >,
    pub check: ::core::option::Option<unsafe extern "C" fn(source: *mut GSource) -> gboolean>,
    pub dispatch: ::core::option::Option<
        unsafe extern "C" fn(
            source: *mut GSource,
            callback: GSourceFunc,
            user_data: gpointer,
        ) -> gboolean,
    >,
    pub finalize: ::core::option::Option<unsafe extern "C" fn(source: *mut GSource)>,
    pub closure_callback: GSourceFunc,
    pub closure_marshal: GSourceDummyMarshal,
}
#[test]
fn bindgen_test_layout__GSourceFuncs() {
    assert_eq!(
        ::core::mem::size_of::<_GSourceFuncs>(),
        48usize,
        concat!("Size of: ", stringify!(_GSourceFuncs))
    );
    assert_eq!(
        ::core::mem::align_of::<_GSourceFuncs>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSourceFuncs))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GSourceFuncs>())).prepare as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceFuncs),
            "::",
            stringify!(prepare)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GSourceFuncs>())).check as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceFuncs),
            "::",
            stringify!(check)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GSourceFuncs>())).dispatch as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceFuncs),
            "::",
            stringify!(dispatch)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GSourceFuncs>())).finalize as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceFuncs),
            "::",
            stringify!(finalize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GSourceFuncs>())).closure_callback as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceFuncs),
            "::",
            stringify!(closure_callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GSourceFuncs>())).closure_marshal as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceFuncs),
            "::",
            stringify!(closure_marshal)
        )
    );
}
extern "C" {
    pub fn g_main_context_new() -> *mut GMainContext;
}
extern "C" {
    pub fn g_main_context_ref(context: *mut GMainContext) -> *mut GMainContext;
}
extern "C" {
    pub fn g_main_context_unref(context: *mut GMainContext);
}
extern "C" {
    pub fn g_main_context_default() -> *mut GMainContext;
}
extern "C" {
    pub fn g_main_context_iteration(context: *mut GMainContext, may_block: gboolean) -> gboolean;
}
extern "C" {
    pub fn g_main_context_pending(context: *mut GMainContext) -> gboolean;
}
extern "C" {
    pub fn g_main_context_find_source_by_id(
        context: *mut GMainContext,
        source_id: guint,
    ) -> *mut GSource;
}
extern "C" {
    pub fn g_main_context_find_source_by_user_data(
        context: *mut GMainContext,
        user_data: gpointer,
    ) -> *mut GSource;
}
extern "C" {
    pub fn g_main_context_find_source_by_funcs_user_data(
        context: *mut GMainContext,
        funcs: *mut GSourceFuncs,
        user_data: gpointer,
    ) -> *mut GSource;
}
extern "C" {
    pub fn g_main_context_wakeup(context: *mut GMainContext);
}
extern "C" {
    pub fn g_main_context_acquire(context: *mut GMainContext) -> gboolean;
}
extern "C" {
    pub fn g_main_context_release(context: *mut GMainContext);
}
extern "C" {
    pub fn g_main_context_is_owner(context: *mut GMainContext) -> gboolean;
}
extern "C" {
    pub fn g_main_context_wait(
        context: *mut GMainContext,
        cond: *mut GCond,
        mutex: *mut GMutex,
    ) -> gboolean;
}
extern "C" {
    pub fn g_main_context_prepare(context: *mut GMainContext, priority: *mut gint) -> gboolean;
}
extern "C" {
    pub fn g_main_context_query(
        context: *mut GMainContext,
        max_priority: gint,
        timeout_: *mut gint,
        fds: *mut GPollFD,
        n_fds: gint,
    ) -> gint;
}
extern "C" {
    pub fn g_main_context_check(
        context: *mut GMainContext,
        max_priority: gint,
        fds: *mut GPollFD,
        n_fds: gint,
    ) -> gboolean;
}
extern "C" {
    pub fn g_main_context_dispatch(context: *mut GMainContext);
}
extern "C" {
    pub fn g_main_context_set_poll_func(context: *mut GMainContext, func: GPollFunc);
}
extern "C" {
    pub fn g_main_context_get_poll_func(context: *mut GMainContext) -> GPollFunc;
}
extern "C" {
    pub fn g_main_context_add_poll(context: *mut GMainContext, fd: *mut GPollFD, priority: gint);
}
extern "C" {
    pub fn g_main_context_remove_poll(context: *mut GMainContext, fd: *mut GPollFD);
}
extern "C" {
    pub fn g_main_depth() -> gint;
}
extern "C" {
    pub fn g_main_current_source() -> *mut GSource;
}
extern "C" {
    pub fn g_main_context_push_thread_default(context: *mut GMainContext);
}
extern "C" {
    pub fn g_main_context_pop_thread_default(context: *mut GMainContext);
}
extern "C" {
    pub fn g_main_context_get_thread_default() -> *mut GMainContext;
}
extern "C" {
    pub fn g_main_context_ref_thread_default() -> *mut GMainContext;
}
#[doc = " GMainContextPusher:"]
#[doc = ""]
#[doc = " Opaque type. See g_main_context_pusher_new() for details."]
#[doc = ""]
#[doc = " Since: 2.64"]
pub type GMainContextPusher = cty::c_void;
extern "C" {
    pub fn g_main_loop_new(context: *mut GMainContext, is_running: gboolean) -> *mut GMainLoop;
}
extern "C" {
    pub fn g_main_loop_run(loop_: *mut GMainLoop);
}
extern "C" {
    pub fn g_main_loop_quit(loop_: *mut GMainLoop);
}
extern "C" {
    pub fn g_main_loop_ref(loop_: *mut GMainLoop) -> *mut GMainLoop;
}
extern "C" {
    pub fn g_main_loop_unref(loop_: *mut GMainLoop);
}
extern "C" {
    pub fn g_main_loop_is_running(loop_: *mut GMainLoop) -> gboolean;
}
extern "C" {
    pub fn g_main_loop_get_context(loop_: *mut GMainLoop) -> *mut GMainContext;
}
extern "C" {
    pub fn g_source_new(source_funcs: *mut GSourceFuncs, struct_size: guint) -> *mut GSource;
}
extern "C" {
    pub fn g_source_set_dispose_function(source: *mut GSource, dispose: GSourceDisposeFunc);
}
extern "C" {
    pub fn g_source_ref(source: *mut GSource) -> *mut GSource;
}
extern "C" {
    pub fn g_source_unref(source: *mut GSource);
}
extern "C" {
    pub fn g_source_attach(source: *mut GSource, context: *mut GMainContext) -> guint;
}
extern "C" {
    pub fn g_source_destroy(source: *mut GSource);
}
extern "C" {
    pub fn g_source_set_priority(source: *mut GSource, priority: gint);
}
extern "C" {
    pub fn g_source_get_priority(source: *mut GSource) -> gint;
}
extern "C" {
    pub fn g_source_set_can_recurse(source: *mut GSource, can_recurse: gboolean);
}
extern "C" {
    pub fn g_source_get_can_recurse(source: *mut GSource) -> gboolean;
}
extern "C" {
    pub fn g_source_get_id(source: *mut GSource) -> guint;
}
extern "C" {
    pub fn g_source_get_context(source: *mut GSource) -> *mut GMainContext;
}
extern "C" {
    pub fn g_source_set_callback(
        source: *mut GSource,
        func: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_source_set_funcs(source: *mut GSource, funcs: *mut GSourceFuncs);
}
extern "C" {
    pub fn g_source_is_destroyed(source: *mut GSource) -> gboolean;
}
extern "C" {
    pub fn g_source_set_name(source: *mut GSource, name: *const cty::c_char);
}
extern "C" {
    pub fn g_source_get_name(source: *mut GSource) -> *const cty::c_char;
}
extern "C" {
    pub fn g_source_set_name_by_id(tag: guint, name: *const cty::c_char);
}
extern "C" {
    pub fn g_source_set_ready_time(source: *mut GSource, ready_time: gint64);
}
extern "C" {
    pub fn g_source_get_ready_time(source: *mut GSource) -> gint64;
}
extern "C" {
    pub fn g_source_add_unix_fd(source: *mut GSource, fd: gint, events: GIOCondition) -> gpointer;
}
extern "C" {
    pub fn g_source_modify_unix_fd(source: *mut GSource, tag: gpointer, new_events: GIOCondition);
}
extern "C" {
    pub fn g_source_remove_unix_fd(source: *mut GSource, tag: gpointer);
}
extern "C" {
    pub fn g_source_query_unix_fd(source: *mut GSource, tag: gpointer) -> GIOCondition;
}
extern "C" {
    pub fn g_source_set_callback_indirect(
        source: *mut GSource,
        callback_data: gpointer,
        callback_funcs: *mut GSourceCallbackFuncs,
    );
}
extern "C" {
    pub fn g_source_add_poll(source: *mut GSource, fd: *mut GPollFD);
}
extern "C" {
    pub fn g_source_remove_poll(source: *mut GSource, fd: *mut GPollFD);
}
extern "C" {
    pub fn g_source_add_child_source(source: *mut GSource, child_source: *mut GSource);
}
extern "C" {
    pub fn g_source_remove_child_source(source: *mut GSource, child_source: *mut GSource);
}
extern "C" {
    pub fn g_source_get_current_time(source: *mut GSource, timeval: *mut GTimeVal);
}
extern "C" {
    pub fn g_source_get_time(source: *mut GSource) -> gint64;
}
extern "C" {
    pub fn g_idle_source_new() -> *mut GSource;
}
extern "C" {
    pub fn g_child_watch_source_new(pid: GPid) -> *mut GSource;
}
extern "C" {
    pub fn g_timeout_source_new(interval: guint) -> *mut GSource;
}
extern "C" {
    pub fn g_timeout_source_new_seconds(interval: guint) -> *mut GSource;
}
extern "C" {
    pub fn g_get_current_time(result: *mut GTimeVal);
}
extern "C" {
    pub fn g_get_monotonic_time() -> gint64;
}
extern "C" {
    pub fn g_get_real_time() -> gint64;
}
extern "C" {
    pub fn g_source_remove(tag: guint) -> gboolean;
}
extern "C" {
    pub fn g_source_remove_by_user_data(user_data: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_source_remove_by_funcs_user_data(
        funcs: *mut GSourceFuncs,
        user_data: gpointer,
    ) -> gboolean;
}
#[doc = " GClearHandleFunc:"]
#[doc = " @handle_id: the handle ID to clear"]
#[doc = ""]
#[doc = " Specifies the type of function passed to g_clear_handle_id()."]
#[doc = " The implementation is expected to free the resource identified"]
#[doc = " by @handle_id; for instance, if @handle_id is a #GSource ID,"]
#[doc = " g_source_remove() can be used."]
#[doc = ""]
#[doc = " Since: 2.56"]
pub type GClearHandleFunc = ::core::option::Option<unsafe extern "C" fn(handle_id: guint)>;
extern "C" {
    pub fn g_clear_handle_id(tag_ptr: *mut guint, clear_func: GClearHandleFunc);
}
extern "C" {
    pub fn g_timeout_add_full(
        priority: gint,
        interval: guint,
        function: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    pub fn g_timeout_add(interval: guint, function: GSourceFunc, data: gpointer) -> guint;
}
extern "C" {
    pub fn g_timeout_add_seconds_full(
        priority: gint,
        interval: guint,
        function: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    pub fn g_timeout_add_seconds(interval: guint, function: GSourceFunc, data: gpointer) -> guint;
}
extern "C" {
    pub fn g_child_watch_add_full(
        priority: gint,
        pid: GPid,
        function: GChildWatchFunc,
        data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    pub fn g_child_watch_add(pid: GPid, function: GChildWatchFunc, data: gpointer) -> guint;
}
extern "C" {
    pub fn g_idle_add(function: GSourceFunc, data: gpointer) -> guint;
}
extern "C" {
    pub fn g_idle_add_full(
        priority: gint,
        function: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    pub fn g_idle_remove_by_data(data: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_main_context_invoke_full(
        context: *mut GMainContext,
        priority: gint,
        function: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_main_context_invoke(context: *mut GMainContext, function: GSourceFunc, data: gpointer);
}
extern "C" {
    pub static mut g_timeout_funcs: GSourceFuncs;
}
extern "C" {
    pub static mut g_child_watch_funcs: GSourceFuncs;
}
extern "C" {
    pub static mut g_idle_funcs: GSourceFuncs;
}
extern "C" {
    pub static mut g_unix_signal_funcs: GSourceFuncs;
}
extern "C" {
    pub static mut g_unix_fd_source_funcs: GSourceFuncs;
}
#[doc = " gunichar:"]
#[doc = ""]
#[doc = " A type which can hold any UTF-32 or UCS-4 character code,"]
#[doc = " also known as a Unicode code point."]
#[doc = ""]
#[doc = " If you want to produce the UTF-8 representation of a #gunichar,"]
#[doc = " use g_ucs4_to_utf8(). See also g_utf8_to_ucs4() for the reverse"]
#[doc = " process."]
#[doc = ""]
#[doc = " To print/scan values of this type as integer, use"]
#[doc = " %G_GINT32_MODIFIER and/or %G_GUINT32_FORMAT."]
#[doc = ""]
#[doc = " The notation to express a Unicode code point in running text is"]
#[doc = " as a hexadecimal number with four to six digits and uppercase"]
#[doc = " letters, prefixed by the string \"U+\". Leading zeros are omitted,"]
#[doc = " unless the code point would have fewer than four hexadecimal digits."]
#[doc = " For example, \"U+0041 LATIN CAPITAL LETTER A\". To print a code point"]
#[doc = " in the U+-notation, use the format string \"U+\\%04\"G_GINT32_FORMAT\"X\"."]
#[doc = " To scan, use the format string \"U+\\%06\"G_GINT32_FORMAT\"X\"."]
#[doc = ""]
#[doc = " |["]
#[doc = " gunichar c;"]
#[doc = " sscanf (\"U+0041\", \"U+%06\"G_GINT32_FORMAT\"X\", &amp;c)"]
#[doc = " g_print (\"Read U+%04\"G_GINT32_FORMAT\"X\", c);"]
#[doc = " ]|"]
pub type gunichar = guint32;
#[doc = " gunichar2:"]
#[doc = ""]
#[doc = " A type which can hold any UTF-16 code"]
#[doc = " point<footnote id=\"utf16_surrogate_pairs\">UTF-16 also has so called"]
#[doc = " <firstterm>surrogate pairs</firstterm> to encode characters beyond"]
#[doc = " the BMP as pairs of 16bit numbers. Surrogate pairs cannot be stored"]
#[doc = " in a single gunichar2 field, but all GLib functions accepting gunichar2"]
#[doc = " arrays will correctly interpret surrogate pairs.</footnote>."]
#[doc = ""]
#[doc = " To print/scan values of this type to/from text you need to convert"]
#[doc = " to/from UTF-8, using g_utf16_to_utf8()/g_utf8_to_utf16()."]
#[doc = ""]
#[doc = " To print/scan values of this type as integer, use"]
#[doc = " %G_GINT16_MODIFIER and/or %G_GUINT16_FORMAT."]
pub type gunichar2 = guint16;
pub const GUnicodeType_G_UNICODE_CONTROL: GUnicodeType = 0;
pub const GUnicodeType_G_UNICODE_FORMAT: GUnicodeType = 1;
pub const GUnicodeType_G_UNICODE_UNASSIGNED: GUnicodeType = 2;
pub const GUnicodeType_G_UNICODE_PRIVATE_USE: GUnicodeType = 3;
pub const GUnicodeType_G_UNICODE_SURROGATE: GUnicodeType = 4;
pub const GUnicodeType_G_UNICODE_LOWERCASE_LETTER: GUnicodeType = 5;
pub const GUnicodeType_G_UNICODE_MODIFIER_LETTER: GUnicodeType = 6;
pub const GUnicodeType_G_UNICODE_OTHER_LETTER: GUnicodeType = 7;
pub const GUnicodeType_G_UNICODE_TITLECASE_LETTER: GUnicodeType = 8;
pub const GUnicodeType_G_UNICODE_UPPERCASE_LETTER: GUnicodeType = 9;
pub const GUnicodeType_G_UNICODE_SPACING_MARK: GUnicodeType = 10;
pub const GUnicodeType_G_UNICODE_ENCLOSING_MARK: GUnicodeType = 11;
pub const GUnicodeType_G_UNICODE_NON_SPACING_MARK: GUnicodeType = 12;
pub const GUnicodeType_G_UNICODE_DECIMAL_NUMBER: GUnicodeType = 13;
pub const GUnicodeType_G_UNICODE_LETTER_NUMBER: GUnicodeType = 14;
pub const GUnicodeType_G_UNICODE_OTHER_NUMBER: GUnicodeType = 15;
pub const GUnicodeType_G_UNICODE_CONNECT_PUNCTUATION: GUnicodeType = 16;
pub const GUnicodeType_G_UNICODE_DASH_PUNCTUATION: GUnicodeType = 17;
pub const GUnicodeType_G_UNICODE_CLOSE_PUNCTUATION: GUnicodeType = 18;
pub const GUnicodeType_G_UNICODE_FINAL_PUNCTUATION: GUnicodeType = 19;
pub const GUnicodeType_G_UNICODE_INITIAL_PUNCTUATION: GUnicodeType = 20;
pub const GUnicodeType_G_UNICODE_OTHER_PUNCTUATION: GUnicodeType = 21;
pub const GUnicodeType_G_UNICODE_OPEN_PUNCTUATION: GUnicodeType = 22;
pub const GUnicodeType_G_UNICODE_CURRENCY_SYMBOL: GUnicodeType = 23;
pub const GUnicodeType_G_UNICODE_MODIFIER_SYMBOL: GUnicodeType = 24;
pub const GUnicodeType_G_UNICODE_MATH_SYMBOL: GUnicodeType = 25;
pub const GUnicodeType_G_UNICODE_OTHER_SYMBOL: GUnicodeType = 26;
pub const GUnicodeType_G_UNICODE_LINE_SEPARATOR: GUnicodeType = 27;
pub const GUnicodeType_G_UNICODE_PARAGRAPH_SEPARATOR: GUnicodeType = 28;
pub const GUnicodeType_G_UNICODE_SPACE_SEPARATOR: GUnicodeType = 29;
#[doc = " GUnicodeType:"]
#[doc = " @G_UNICODE_CONTROL: General category \"Other, Control\" (Cc)"]
#[doc = " @G_UNICODE_FORMAT: General category \"Other, Format\" (Cf)"]
#[doc = " @G_UNICODE_UNASSIGNED: General category \"Other, Not Assigned\" (Cn)"]
#[doc = " @G_UNICODE_PRIVATE_USE: General category \"Other, Private Use\" (Co)"]
#[doc = " @G_UNICODE_SURROGATE: General category \"Other, Surrogate\" (Cs)"]
#[doc = " @G_UNICODE_LOWERCASE_LETTER: General category \"Letter, Lowercase\" (Ll)"]
#[doc = " @G_UNICODE_MODIFIER_LETTER: General category \"Letter, Modifier\" (Lm)"]
#[doc = " @G_UNICODE_OTHER_LETTER: General category \"Letter, Other\" (Lo)"]
#[doc = " @G_UNICODE_TITLECASE_LETTER: General category \"Letter, Titlecase\" (Lt)"]
#[doc = " @G_UNICODE_UPPERCASE_LETTER: General category \"Letter, Uppercase\" (Lu)"]
#[doc = " @G_UNICODE_SPACING_MARK: General category \"Mark, Spacing\" (Mc)"]
#[doc = " @G_UNICODE_ENCLOSING_MARK: General category \"Mark, Enclosing\" (Me)"]
#[doc = " @G_UNICODE_NON_SPACING_MARK: General category \"Mark, Nonspacing\" (Mn)"]
#[doc = " @G_UNICODE_DECIMAL_NUMBER: General category \"Number, Decimal Digit\" (Nd)"]
#[doc = " @G_UNICODE_LETTER_NUMBER: General category \"Number, Letter\" (Nl)"]
#[doc = " @G_UNICODE_OTHER_NUMBER: General category \"Number, Other\" (No)"]
#[doc = " @G_UNICODE_CONNECT_PUNCTUATION: General category \"Punctuation, Connector\" (Pc)"]
#[doc = " @G_UNICODE_DASH_PUNCTUATION: General category \"Punctuation, Dash\" (Pd)"]
#[doc = " @G_UNICODE_CLOSE_PUNCTUATION: General category \"Punctuation, Close\" (Pe)"]
#[doc = " @G_UNICODE_FINAL_PUNCTUATION: General category \"Punctuation, Final quote\" (Pf)"]
#[doc = " @G_UNICODE_INITIAL_PUNCTUATION: General category \"Punctuation, Initial quote\" (Pi)"]
#[doc = " @G_UNICODE_OTHER_PUNCTUATION: General category \"Punctuation, Other\" (Po)"]
#[doc = " @G_UNICODE_OPEN_PUNCTUATION: General category \"Punctuation, Open\" (Ps)"]
#[doc = " @G_UNICODE_CURRENCY_SYMBOL: General category \"Symbol, Currency\" (Sc)"]
#[doc = " @G_UNICODE_MODIFIER_SYMBOL: General category \"Symbol, Modifier\" (Sk)"]
#[doc = " @G_UNICODE_MATH_SYMBOL: General category \"Symbol, Math\" (Sm)"]
#[doc = " @G_UNICODE_OTHER_SYMBOL: General category \"Symbol, Other\" (So)"]
#[doc = " @G_UNICODE_LINE_SEPARATOR: General category \"Separator, Line\" (Zl)"]
#[doc = " @G_UNICODE_PARAGRAPH_SEPARATOR: General category \"Separator, Paragraph\" (Zp)"]
#[doc = " @G_UNICODE_SPACE_SEPARATOR: General category \"Separator, Space\" (Zs)"]
#[doc = ""]
#[doc = " These are the possible character classifications from the"]
#[doc = " Unicode specification."]
#[doc = " See [Unicode Character Database](http://www.unicode.org/reports/tr44/#General_Category_Values)."]
pub type GUnicodeType = u32;
pub const GUnicodeBreakType_G_UNICODE_BREAK_MANDATORY: GUnicodeBreakType = 0;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CARRIAGE_RETURN: GUnicodeBreakType = 1;
pub const GUnicodeBreakType_G_UNICODE_BREAK_LINE_FEED: GUnicodeBreakType = 2;
pub const GUnicodeBreakType_G_UNICODE_BREAK_COMBINING_MARK: GUnicodeBreakType = 3;
pub const GUnicodeBreakType_G_UNICODE_BREAK_SURROGATE: GUnicodeBreakType = 4;
pub const GUnicodeBreakType_G_UNICODE_BREAK_ZERO_WIDTH_SPACE: GUnicodeBreakType = 5;
pub const GUnicodeBreakType_G_UNICODE_BREAK_INSEPARABLE: GUnicodeBreakType = 6;
pub const GUnicodeBreakType_G_UNICODE_BREAK_NON_BREAKING_GLUE: GUnicodeBreakType = 7;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CONTINGENT: GUnicodeBreakType = 8;
pub const GUnicodeBreakType_G_UNICODE_BREAK_SPACE: GUnicodeBreakType = 9;
pub const GUnicodeBreakType_G_UNICODE_BREAK_AFTER: GUnicodeBreakType = 10;
pub const GUnicodeBreakType_G_UNICODE_BREAK_BEFORE: GUnicodeBreakType = 11;
pub const GUnicodeBreakType_G_UNICODE_BREAK_BEFORE_AND_AFTER: GUnicodeBreakType = 12;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HYPHEN: GUnicodeBreakType = 13;
pub const GUnicodeBreakType_G_UNICODE_BREAK_NON_STARTER: GUnicodeBreakType = 14;
pub const GUnicodeBreakType_G_UNICODE_BREAK_OPEN_PUNCTUATION: GUnicodeBreakType = 15;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CLOSE_PUNCTUATION: GUnicodeBreakType = 16;
pub const GUnicodeBreakType_G_UNICODE_BREAK_QUOTATION: GUnicodeBreakType = 17;
pub const GUnicodeBreakType_G_UNICODE_BREAK_EXCLAMATION: GUnicodeBreakType = 18;
pub const GUnicodeBreakType_G_UNICODE_BREAK_IDEOGRAPHIC: GUnicodeBreakType = 19;
pub const GUnicodeBreakType_G_UNICODE_BREAK_NUMERIC: GUnicodeBreakType = 20;
pub const GUnicodeBreakType_G_UNICODE_BREAK_INFIX_SEPARATOR: GUnicodeBreakType = 21;
pub const GUnicodeBreakType_G_UNICODE_BREAK_SYMBOL: GUnicodeBreakType = 22;
pub const GUnicodeBreakType_G_UNICODE_BREAK_ALPHABETIC: GUnicodeBreakType = 23;
pub const GUnicodeBreakType_G_UNICODE_BREAK_PREFIX: GUnicodeBreakType = 24;
pub const GUnicodeBreakType_G_UNICODE_BREAK_POSTFIX: GUnicodeBreakType = 25;
pub const GUnicodeBreakType_G_UNICODE_BREAK_COMPLEX_CONTEXT: GUnicodeBreakType = 26;
pub const GUnicodeBreakType_G_UNICODE_BREAK_AMBIGUOUS: GUnicodeBreakType = 27;
pub const GUnicodeBreakType_G_UNICODE_BREAK_UNKNOWN: GUnicodeBreakType = 28;
pub const GUnicodeBreakType_G_UNICODE_BREAK_NEXT_LINE: GUnicodeBreakType = 29;
pub const GUnicodeBreakType_G_UNICODE_BREAK_WORD_JOINER: GUnicodeBreakType = 30;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_L_JAMO: GUnicodeBreakType = 31;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_V_JAMO: GUnicodeBreakType = 32;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_T_JAMO: GUnicodeBreakType = 33;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_LV_SYLLABLE: GUnicodeBreakType = 34;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE: GUnicodeBreakType = 35;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CLOSE_PARANTHESIS: GUnicodeBreakType = 36;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER: GUnicodeBreakType = 37;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HEBREW_LETTER: GUnicodeBreakType = 38;
pub const GUnicodeBreakType_G_UNICODE_BREAK_REGIONAL_INDICATOR: GUnicodeBreakType = 39;
pub const GUnicodeBreakType_G_UNICODE_BREAK_EMOJI_BASE: GUnicodeBreakType = 40;
pub const GUnicodeBreakType_G_UNICODE_BREAK_EMOJI_MODIFIER: GUnicodeBreakType = 41;
pub const GUnicodeBreakType_G_UNICODE_BREAK_ZERO_WIDTH_JOINER: GUnicodeBreakType = 42;
#[doc = " GUnicodeBreakType:"]
#[doc = " @G_UNICODE_BREAK_MANDATORY: Mandatory Break (BK)"]
#[doc = " @G_UNICODE_BREAK_CARRIAGE_RETURN: Carriage Return (CR)"]
#[doc = " @G_UNICODE_BREAK_LINE_FEED: Line Feed (LF)"]
#[doc = " @G_UNICODE_BREAK_COMBINING_MARK: Attached Characters and Combining Marks (CM)"]
#[doc = " @G_UNICODE_BREAK_SURROGATE: Surrogates (SG)"]
#[doc = " @G_UNICODE_BREAK_ZERO_WIDTH_SPACE: Zero Width Space (ZW)"]
#[doc = " @G_UNICODE_BREAK_INSEPARABLE: Inseparable (IN)"]
#[doc = " @G_UNICODE_BREAK_NON_BREAKING_GLUE: Non-breaking (\"Glue\") (GL)"]
#[doc = " @G_UNICODE_BREAK_CONTINGENT: Contingent Break Opportunity (CB)"]
#[doc = " @G_UNICODE_BREAK_SPACE: Space (SP)"]
#[doc = " @G_UNICODE_BREAK_AFTER: Break Opportunity After (BA)"]
#[doc = " @G_UNICODE_BREAK_BEFORE: Break Opportunity Before (BB)"]
#[doc = " @G_UNICODE_BREAK_BEFORE_AND_AFTER: Break Opportunity Before and After (B2)"]
#[doc = " @G_UNICODE_BREAK_HYPHEN: Hyphen (HY)"]
#[doc = " @G_UNICODE_BREAK_NON_STARTER: Nonstarter (NS)"]
#[doc = " @G_UNICODE_BREAK_OPEN_PUNCTUATION: Opening Punctuation (OP)"]
#[doc = " @G_UNICODE_BREAK_CLOSE_PUNCTUATION: Closing Punctuation (CL)"]
#[doc = " @G_UNICODE_BREAK_QUOTATION: Ambiguous Quotation (QU)"]
#[doc = " @G_UNICODE_BREAK_EXCLAMATION: Exclamation/Interrogation (EX)"]
#[doc = " @G_UNICODE_BREAK_IDEOGRAPHIC: Ideographic (ID)"]
#[doc = " @G_UNICODE_BREAK_NUMERIC: Numeric (NU)"]
#[doc = " @G_UNICODE_BREAK_INFIX_SEPARATOR: Infix Separator (Numeric) (IS)"]
#[doc = " @G_UNICODE_BREAK_SYMBOL: Symbols Allowing Break After (SY)"]
#[doc = " @G_UNICODE_BREAK_ALPHABETIC: Ordinary Alphabetic and Symbol Characters (AL)"]
#[doc = " @G_UNICODE_BREAK_PREFIX: Prefix (Numeric) (PR)"]
#[doc = " @G_UNICODE_BREAK_POSTFIX: Postfix (Numeric) (PO)"]
#[doc = " @G_UNICODE_BREAK_COMPLEX_CONTEXT: Complex Content Dependent (South East Asian) (SA)"]
#[doc = " @G_UNICODE_BREAK_AMBIGUOUS: Ambiguous (Alphabetic or Ideographic) (AI)"]
#[doc = " @G_UNICODE_BREAK_UNKNOWN: Unknown (XX)"]
#[doc = " @G_UNICODE_BREAK_NEXT_LINE: Next Line (NL)"]
#[doc = " @G_UNICODE_BREAK_WORD_JOINER: Word Joiner (WJ)"]
#[doc = " @G_UNICODE_BREAK_HANGUL_L_JAMO: Hangul L Jamo (JL)"]
#[doc = " @G_UNICODE_BREAK_HANGUL_V_JAMO: Hangul V Jamo (JV)"]
#[doc = " @G_UNICODE_BREAK_HANGUL_T_JAMO: Hangul T Jamo (JT)"]
#[doc = " @G_UNICODE_BREAK_HANGUL_LV_SYLLABLE: Hangul LV Syllable (H2)"]
#[doc = " @G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE: Hangul LVT Syllable (H3)"]
#[doc = " @G_UNICODE_BREAK_CLOSE_PARANTHESIS: Closing Parenthesis (CP). Since 2.28"]
#[doc = " @G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER: Conditional Japanese Starter (CJ). Since: 2.32"]
#[doc = " @G_UNICODE_BREAK_HEBREW_LETTER: Hebrew Letter (HL). Since: 2.32"]
#[doc = " @G_UNICODE_BREAK_REGIONAL_INDICATOR: Regional Indicator (RI). Since: 2.36"]
#[doc = " @G_UNICODE_BREAK_EMOJI_BASE: Emoji Base (EB). Since: 2.50"]
#[doc = " @G_UNICODE_BREAK_EMOJI_MODIFIER: Emoji Modifier (EM). Since: 2.50"]
#[doc = " @G_UNICODE_BREAK_ZERO_WIDTH_JOINER: Zero Width Joiner (ZWJ). Since: 2.50"]
#[doc = ""]
#[doc = " These are the possible line break classifications."]
#[doc = ""]
#[doc = " Since new unicode versions may add new types here, applications should be ready"]
#[doc = " to handle unknown values. They may be regarded as %G_UNICODE_BREAK_UNKNOWN."]
#[doc = ""]
#[doc = " See [Unicode Line Breaking Algorithm](http://www.unicode.org/unicode/reports/tr14/)."]
pub type GUnicodeBreakType = u32;
pub const GUnicodeScript_G_UNICODE_SCRIPT_INVALID_CODE: GUnicodeScript = -1;
pub const GUnicodeScript_G_UNICODE_SCRIPT_COMMON: GUnicodeScript = 0;
pub const GUnicodeScript_G_UNICODE_SCRIPT_INHERITED: GUnicodeScript = 1;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ARABIC: GUnicodeScript = 2;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ARMENIAN: GUnicodeScript = 3;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BENGALI: GUnicodeScript = 4;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BOPOMOFO: GUnicodeScript = 5;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CHEROKEE: GUnicodeScript = 6;
pub const GUnicodeScript_G_UNICODE_SCRIPT_COPTIC: GUnicodeScript = 7;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CYRILLIC: GUnicodeScript = 8;
pub const GUnicodeScript_G_UNICODE_SCRIPT_DESERET: GUnicodeScript = 9;
pub const GUnicodeScript_G_UNICODE_SCRIPT_DEVANAGARI: GUnicodeScript = 10;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ETHIOPIC: GUnicodeScript = 11;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GEORGIAN: GUnicodeScript = 12;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GOTHIC: GUnicodeScript = 13;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GREEK: GUnicodeScript = 14;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GUJARATI: GUnicodeScript = 15;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GURMUKHI: GUnicodeScript = 16;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HAN: GUnicodeScript = 17;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HANGUL: GUnicodeScript = 18;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HEBREW: GUnicodeScript = 19;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HIRAGANA: GUnicodeScript = 20;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KANNADA: GUnicodeScript = 21;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KATAKANA: GUnicodeScript = 22;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KHMER: GUnicodeScript = 23;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LAO: GUnicodeScript = 24;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LATIN: GUnicodeScript = 25;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MALAYALAM: GUnicodeScript = 26;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MONGOLIAN: GUnicodeScript = 27;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MYANMAR: GUnicodeScript = 28;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OGHAM: GUnicodeScript = 29;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_ITALIC: GUnicodeScript = 30;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ORIYA: GUnicodeScript = 31;
pub const GUnicodeScript_G_UNICODE_SCRIPT_RUNIC: GUnicodeScript = 32;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SINHALA: GUnicodeScript = 33;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SYRIAC: GUnicodeScript = 34;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAMIL: GUnicodeScript = 35;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TELUGU: GUnicodeScript = 36;
pub const GUnicodeScript_G_UNICODE_SCRIPT_THAANA: GUnicodeScript = 37;
pub const GUnicodeScript_G_UNICODE_SCRIPT_THAI: GUnicodeScript = 38;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TIBETAN: GUnicodeScript = 39;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL: GUnicodeScript = 40;
pub const GUnicodeScript_G_UNICODE_SCRIPT_YI: GUnicodeScript = 41;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAGALOG: GUnicodeScript = 42;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HANUNOO: GUnicodeScript = 43;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BUHID: GUnicodeScript = 44;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAGBANWA: GUnicodeScript = 45;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BRAILLE: GUnicodeScript = 46;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CYPRIOT: GUnicodeScript = 47;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LIMBU: GUnicodeScript = 48;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OSMANYA: GUnicodeScript = 49;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SHAVIAN: GUnicodeScript = 50;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LINEAR_B: GUnicodeScript = 51;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAI_LE: GUnicodeScript = 52;
pub const GUnicodeScript_G_UNICODE_SCRIPT_UGARITIC: GUnicodeScript = 53;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NEW_TAI_LUE: GUnicodeScript = 54;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BUGINESE: GUnicodeScript = 55;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GLAGOLITIC: GUnicodeScript = 56;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TIFINAGH: GUnicodeScript = 57;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SYLOTI_NAGRI: GUnicodeScript = 58;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_PERSIAN: GUnicodeScript = 59;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KHAROSHTHI: GUnicodeScript = 60;
pub const GUnicodeScript_G_UNICODE_SCRIPT_UNKNOWN: GUnicodeScript = 61;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BALINESE: GUnicodeScript = 62;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CUNEIFORM: GUnicodeScript = 63;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PHOENICIAN: GUnicodeScript = 64;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PHAGS_PA: GUnicodeScript = 65;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NKO: GUnicodeScript = 66;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KAYAH_LI: GUnicodeScript = 67;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LEPCHA: GUnicodeScript = 68;
pub const GUnicodeScript_G_UNICODE_SCRIPT_REJANG: GUnicodeScript = 69;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SUNDANESE: GUnicodeScript = 70;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SAURASHTRA: GUnicodeScript = 71;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CHAM: GUnicodeScript = 72;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OL_CHIKI: GUnicodeScript = 73;
pub const GUnicodeScript_G_UNICODE_SCRIPT_VAI: GUnicodeScript = 74;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CARIAN: GUnicodeScript = 75;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LYCIAN: GUnicodeScript = 76;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LYDIAN: GUnicodeScript = 77;
pub const GUnicodeScript_G_UNICODE_SCRIPT_AVESTAN: GUnicodeScript = 78;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BAMUM: GUnicodeScript = 79;
pub const GUnicodeScript_G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS: GUnicodeScript = 80;
pub const GUnicodeScript_G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC: GUnicodeScript = 81;
pub const GUnicodeScript_G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI: GUnicodeScript = 82;
pub const GUnicodeScript_G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN: GUnicodeScript = 83;
pub const GUnicodeScript_G_UNICODE_SCRIPT_JAVANESE: GUnicodeScript = 84;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KAITHI: GUnicodeScript = 85;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LISU: GUnicodeScript = 86;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MEETEI_MAYEK: GUnicodeScript = 87;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN: GUnicodeScript = 88;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_TURKIC: GUnicodeScript = 89;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SAMARITAN: GUnicodeScript = 90;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAI_THAM: GUnicodeScript = 91;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAI_VIET: GUnicodeScript = 92;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BATAK: GUnicodeScript = 93;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BRAHMI: GUnicodeScript = 94;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MANDAIC: GUnicodeScript = 95;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CHAKMA: GUnicodeScript = 96;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MEROITIC_CURSIVE: GUnicodeScript = 97;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS: GUnicodeScript = 98;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MIAO: GUnicodeScript = 99;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SHARADA: GUnicodeScript = 100;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SORA_SOMPENG: GUnicodeScript = 101;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAKRI: GUnicodeScript = 102;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BASSA_VAH: GUnicodeScript = 103;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN: GUnicodeScript = 104;
pub const GUnicodeScript_G_UNICODE_SCRIPT_DUPLOYAN: GUnicodeScript = 105;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ELBASAN: GUnicodeScript = 106;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GRANTHA: GUnicodeScript = 107;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KHOJKI: GUnicodeScript = 108;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KHUDAWADI: GUnicodeScript = 109;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LINEAR_A: GUnicodeScript = 110;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MAHAJANI: GUnicodeScript = 111;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MANICHAEAN: GUnicodeScript = 112;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MENDE_KIKAKUI: GUnicodeScript = 113;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MODI: GUnicodeScript = 114;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MRO: GUnicodeScript = 115;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NABATAEAN: GUnicodeScript = 116;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN: GUnicodeScript = 117;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_PERMIC: GUnicodeScript = 118;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PAHAWH_HMONG: GUnicodeScript = 119;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PALMYRENE: GUnicodeScript = 120;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PAU_CIN_HAU: GUnicodeScript = 121;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PSALTER_PAHLAVI: GUnicodeScript = 122;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SIDDHAM: GUnicodeScript = 123;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TIRHUTA: GUnicodeScript = 124;
pub const GUnicodeScript_G_UNICODE_SCRIPT_WARANG_CITI: GUnicodeScript = 125;
pub const GUnicodeScript_G_UNICODE_SCRIPT_AHOM: GUnicodeScript = 126;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS: GUnicodeScript = 127;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HATRAN: GUnicodeScript = 128;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MULTANI: GUnicodeScript = 129;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_HUNGARIAN: GUnicodeScript = 130;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SIGNWRITING: GUnicodeScript = 131;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ADLAM: GUnicodeScript = 132;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BHAIKSUKI: GUnicodeScript = 133;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MARCHEN: GUnicodeScript = 134;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NEWA: GUnicodeScript = 135;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OSAGE: GUnicodeScript = 136;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TANGUT: GUnicodeScript = 137;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MASARAM_GONDI: GUnicodeScript = 138;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NUSHU: GUnicodeScript = 139;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SOYOMBO: GUnicodeScript = 140;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ZANABAZAR_SQUARE: GUnicodeScript = 141;
pub const GUnicodeScript_G_UNICODE_SCRIPT_DOGRA: GUnicodeScript = 142;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GUNJALA_GONDI: GUnicodeScript = 143;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HANIFI_ROHINGYA: GUnicodeScript = 144;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MAKASAR: GUnicodeScript = 145;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MEDEFAIDRIN: GUnicodeScript = 146;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_SOGDIAN: GUnicodeScript = 147;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SOGDIAN: GUnicodeScript = 148;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ELYMAIC: GUnicodeScript = 149;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NANDINAGARI: GUnicodeScript = 150;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NYIAKENG_PUACHUE_HMONG: GUnicodeScript = 151;
pub const GUnicodeScript_G_UNICODE_SCRIPT_WANCHO: GUnicodeScript = 152;
#[doc = " GUnicodeScript:"]
#[doc = " @G_UNICODE_SCRIPT_INVALID_CODE:"]
#[doc = "                               a value never returned from g_unichar_get_script()"]
#[doc = " @G_UNICODE_SCRIPT_COMMON:     a character used by multiple different scripts"]
#[doc = " @G_UNICODE_SCRIPT_INHERITED:  a mark glyph that takes its script from the"]
#[doc = "                               base glyph to which it is attached"]
#[doc = " @G_UNICODE_SCRIPT_ARABIC:     Arabic"]
#[doc = " @G_UNICODE_SCRIPT_ARMENIAN:   Armenian"]
#[doc = " @G_UNICODE_SCRIPT_BENGALI:    Bengali"]
#[doc = " @G_UNICODE_SCRIPT_BOPOMOFO:   Bopomofo"]
#[doc = " @G_UNICODE_SCRIPT_CHEROKEE:   Cherokee"]
#[doc = " @G_UNICODE_SCRIPT_COPTIC:     Coptic"]
#[doc = " @G_UNICODE_SCRIPT_CYRILLIC:   Cyrillic"]
#[doc = " @G_UNICODE_SCRIPT_DESERET:    Deseret"]
#[doc = " @G_UNICODE_SCRIPT_DEVANAGARI: Devanagari"]
#[doc = " @G_UNICODE_SCRIPT_ETHIOPIC:   Ethiopic"]
#[doc = " @G_UNICODE_SCRIPT_GEORGIAN:   Georgian"]
#[doc = " @G_UNICODE_SCRIPT_GOTHIC:     Gothic"]
#[doc = " @G_UNICODE_SCRIPT_GREEK:      Greek"]
#[doc = " @G_UNICODE_SCRIPT_GUJARATI:   Gujarati"]
#[doc = " @G_UNICODE_SCRIPT_GURMUKHI:   Gurmukhi"]
#[doc = " @G_UNICODE_SCRIPT_HAN:        Han"]
#[doc = " @G_UNICODE_SCRIPT_HANGUL:     Hangul"]
#[doc = " @G_UNICODE_SCRIPT_HEBREW:     Hebrew"]
#[doc = " @G_UNICODE_SCRIPT_HIRAGANA:   Hiragana"]
#[doc = " @G_UNICODE_SCRIPT_KANNADA:    Kannada"]
#[doc = " @G_UNICODE_SCRIPT_KATAKANA:   Katakana"]
#[doc = " @G_UNICODE_SCRIPT_KHMER:      Khmer"]
#[doc = " @G_UNICODE_SCRIPT_LAO:        Lao"]
#[doc = " @G_UNICODE_SCRIPT_LATIN:      Latin"]
#[doc = " @G_UNICODE_SCRIPT_MALAYALAM:  Malayalam"]
#[doc = " @G_UNICODE_SCRIPT_MONGOLIAN:  Mongolian"]
#[doc = " @G_UNICODE_SCRIPT_MYANMAR:    Myanmar"]
#[doc = " @G_UNICODE_SCRIPT_OGHAM:      Ogham"]
#[doc = " @G_UNICODE_SCRIPT_OLD_ITALIC: Old Italic"]
#[doc = " @G_UNICODE_SCRIPT_ORIYA:      Oriya"]
#[doc = " @G_UNICODE_SCRIPT_RUNIC:      Runic"]
#[doc = " @G_UNICODE_SCRIPT_SINHALA:    Sinhala"]
#[doc = " @G_UNICODE_SCRIPT_SYRIAC:     Syriac"]
#[doc = " @G_UNICODE_SCRIPT_TAMIL:      Tamil"]
#[doc = " @G_UNICODE_SCRIPT_TELUGU:     Telugu"]
#[doc = " @G_UNICODE_SCRIPT_THAANA:     Thaana"]
#[doc = " @G_UNICODE_SCRIPT_THAI:       Thai"]
#[doc = " @G_UNICODE_SCRIPT_TIBETAN:    Tibetan"]
#[doc = " @G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL:"]
#[doc = "                               Canadian Aboriginal"]
#[doc = " @G_UNICODE_SCRIPT_YI:         Yi"]
#[doc = " @G_UNICODE_SCRIPT_TAGALOG:    Tagalog"]
#[doc = " @G_UNICODE_SCRIPT_HANUNOO:    Hanunoo"]
#[doc = " @G_UNICODE_SCRIPT_BUHID:      Buhid"]
#[doc = " @G_UNICODE_SCRIPT_TAGBANWA:   Tagbanwa"]
#[doc = " @G_UNICODE_SCRIPT_BRAILLE:    Braille"]
#[doc = " @G_UNICODE_SCRIPT_CYPRIOT:    Cypriot"]
#[doc = " @G_UNICODE_SCRIPT_LIMBU:      Limbu"]
#[doc = " @G_UNICODE_SCRIPT_OSMANYA:    Osmanya"]
#[doc = " @G_UNICODE_SCRIPT_SHAVIAN:    Shavian"]
#[doc = " @G_UNICODE_SCRIPT_LINEAR_B:   Linear B"]
#[doc = " @G_UNICODE_SCRIPT_TAI_LE:     Tai Le"]
#[doc = " @G_UNICODE_SCRIPT_UGARITIC:   Ugaritic"]
#[doc = " @G_UNICODE_SCRIPT_NEW_TAI_LUE:"]
#[doc = "                               New Tai Lue"]
#[doc = " @G_UNICODE_SCRIPT_BUGINESE:   Buginese"]
#[doc = " @G_UNICODE_SCRIPT_GLAGOLITIC: Glagolitic"]
#[doc = " @G_UNICODE_SCRIPT_TIFINAGH:   Tifinagh"]
#[doc = " @G_UNICODE_SCRIPT_SYLOTI_NAGRI:"]
#[doc = "                               Syloti Nagri"]
#[doc = " @G_UNICODE_SCRIPT_OLD_PERSIAN:"]
#[doc = "                               Old Persian"]
#[doc = " @G_UNICODE_SCRIPT_KHAROSHTHI: Kharoshthi"]
#[doc = " @G_UNICODE_SCRIPT_UNKNOWN:    an unassigned code point"]
#[doc = " @G_UNICODE_SCRIPT_BALINESE:   Balinese"]
#[doc = " @G_UNICODE_SCRIPT_CUNEIFORM:  Cuneiform"]
#[doc = " @G_UNICODE_SCRIPT_PHOENICIAN: Phoenician"]
#[doc = " @G_UNICODE_SCRIPT_PHAGS_PA:   Phags-pa"]
#[doc = " @G_UNICODE_SCRIPT_NKO:        N'Ko"]
#[doc = " @G_UNICODE_SCRIPT_KAYAH_LI:   Kayah Li. Since 2.16.3"]
#[doc = " @G_UNICODE_SCRIPT_LEPCHA:     Lepcha. Since 2.16.3"]
#[doc = " @G_UNICODE_SCRIPT_REJANG:     Rejang. Since 2.16.3"]
#[doc = " @G_UNICODE_SCRIPT_SUNDANESE:  Sundanese. Since 2.16.3"]
#[doc = " @G_UNICODE_SCRIPT_SAURASHTRA: Saurashtra. Since 2.16.3"]
#[doc = " @G_UNICODE_SCRIPT_CHAM:       Cham. Since 2.16.3"]
#[doc = " @G_UNICODE_SCRIPT_OL_CHIKI:   Ol Chiki. Since 2.16.3"]
#[doc = " @G_UNICODE_SCRIPT_VAI:        Vai. Since 2.16.3"]
#[doc = " @G_UNICODE_SCRIPT_CARIAN:     Carian. Since 2.16.3"]
#[doc = " @G_UNICODE_SCRIPT_LYCIAN:     Lycian. Since 2.16.3"]
#[doc = " @G_UNICODE_SCRIPT_LYDIAN:     Lydian. Since 2.16.3"]
#[doc = " @G_UNICODE_SCRIPT_AVESTAN:    Avestan. Since 2.26"]
#[doc = " @G_UNICODE_SCRIPT_BAMUM:      Bamum. Since 2.26"]
#[doc = " @G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS:"]
#[doc = "                               Egyptian Hieroglpyhs. Since 2.26"]
#[doc = " @G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC:"]
#[doc = "                               Imperial Aramaic. Since 2.26"]
#[doc = " @G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI:"]
#[doc = "                               Inscriptional Pahlavi. Since 2.26"]
#[doc = " @G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN:"]
#[doc = "                               Inscriptional Parthian. Since 2.26"]
#[doc = " @G_UNICODE_SCRIPT_JAVANESE:   Javanese. Since 2.26"]
#[doc = " @G_UNICODE_SCRIPT_KAITHI:     Kaithi. Since 2.26"]
#[doc = " @G_UNICODE_SCRIPT_LISU:       Lisu. Since 2.26"]
#[doc = " @G_UNICODE_SCRIPT_MEETEI_MAYEK:"]
#[doc = "                               Meetei Mayek. Since 2.26"]
#[doc = " @G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN:"]
#[doc = "                               Old South Arabian. Since 2.26"]
#[doc = " @G_UNICODE_SCRIPT_OLD_TURKIC: Old Turkic. Since 2.28"]
#[doc = " @G_UNICODE_SCRIPT_SAMARITAN:  Samaritan. Since 2.26"]
#[doc = " @G_UNICODE_SCRIPT_TAI_THAM:   Tai Tham. Since 2.26"]
#[doc = " @G_UNICODE_SCRIPT_TAI_VIET:   Tai Viet. Since 2.26"]
#[doc = " @G_UNICODE_SCRIPT_BATAK:      Batak. Since 2.28"]
#[doc = " @G_UNICODE_SCRIPT_BRAHMI:     Brahmi. Since 2.28"]
#[doc = " @G_UNICODE_SCRIPT_MANDAIC:    Mandaic. Since 2.28"]
#[doc = " @G_UNICODE_SCRIPT_CHAKMA:               Chakma. Since: 2.32"]
#[doc = " @G_UNICODE_SCRIPT_MEROITIC_CURSIVE:     Meroitic Cursive. Since: 2.32"]
#[doc = " @G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS: Meroitic Hieroglyphs. Since: 2.32"]
#[doc = " @G_UNICODE_SCRIPT_MIAO:                 Miao. Since: 2.32"]
#[doc = " @G_UNICODE_SCRIPT_SHARADA:              Sharada. Since: 2.32"]
#[doc = " @G_UNICODE_SCRIPT_SORA_SOMPENG:         Sora Sompeng. Since: 2.32"]
#[doc = " @G_UNICODE_SCRIPT_TAKRI:                Takri. Since: 2.32"]
#[doc = " @G_UNICODE_SCRIPT_BASSA_VAH:            Bassa. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN:   Caucasian Albanian. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_DUPLOYAN:             Duployan. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_ELBASAN:              Elbasan. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_GRANTHA:              Grantha. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_KHOJKI:               Kjohki. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_KHUDAWADI:            Khudawadi, Sindhi. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_LINEAR_A:             Linear A. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_MAHAJANI:             Mahajani. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_MANICHAEAN:           Manichaean. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_MENDE_KIKAKUI:        Mende Kikakui. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_MODI:                 Modi. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_MRO:                  Mro. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_NABATAEAN:            Nabataean. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN:    Old North Arabian. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_OLD_PERMIC:           Old Permic. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_PAHAWH_HMONG:         Pahawh Hmong. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_PALMYRENE:            Palmyrene. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_PAU_CIN_HAU:          Pau Cin Hau. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_PSALTER_PAHLAVI:      Psalter Pahlavi. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_SIDDHAM:              Siddham. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_TIRHUTA:              Tirhuta. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_WARANG_CITI:          Warang Citi. Since: 2.42"]
#[doc = " @G_UNICODE_SCRIPT_AHOM:                 Ahom. Since: 2.48"]
#[doc = " @G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS: Anatolian Hieroglyphs. Since: 2.48"]
#[doc = " @G_UNICODE_SCRIPT_HATRAN:               Hatran. Since: 2.48"]
#[doc = " @G_UNICODE_SCRIPT_MULTANI:              Multani. Since: 2.48"]
#[doc = " @G_UNICODE_SCRIPT_OLD_HUNGARIAN:        Old Hungarian. Since: 2.48"]
#[doc = " @G_UNICODE_SCRIPT_SIGNWRITING:          Signwriting. Since: 2.48"]
#[doc = " @G_UNICODE_SCRIPT_ADLAM:                Adlam. Since: 2.50"]
#[doc = " @G_UNICODE_SCRIPT_BHAIKSUKI:            Bhaiksuki. Since: 2.50"]
#[doc = " @G_UNICODE_SCRIPT_MARCHEN:              Marchen. Since: 2.50"]
#[doc = " @G_UNICODE_SCRIPT_NEWA:                 Newa. Since: 2.50"]
#[doc = " @G_UNICODE_SCRIPT_OSAGE:                Osage. Since: 2.50"]
#[doc = " @G_UNICODE_SCRIPT_TANGUT:               Tangut. Since: 2.50"]
#[doc = " @G_UNICODE_SCRIPT_MASARAM_GONDI:        Masaram Gondi. Since: 2.54"]
#[doc = " @G_UNICODE_SCRIPT_NUSHU:                Nushu. Since: 2.54"]
#[doc = " @G_UNICODE_SCRIPT_SOYOMBO:              Soyombo. Since: 2.54"]
#[doc = " @G_UNICODE_SCRIPT_ZANABAZAR_SQUARE:     Zanabazar Square. Since: 2.54"]
#[doc = " @G_UNICODE_SCRIPT_DOGRA:                Dogra. Since: 2.58"]
#[doc = " @G_UNICODE_SCRIPT_GUNJALA_GONDI:        Gunjala Gondi. Since: 2.58"]
#[doc = " @G_UNICODE_SCRIPT_HANIFI_ROHINGYA:      Hanifi Rohingya. Since: 2.58"]
#[doc = " @G_UNICODE_SCRIPT_MAKASAR:              Makasar. Since: 2.58"]
#[doc = " @G_UNICODE_SCRIPT_MEDEFAIDRIN:          Medefaidrin. Since: 2.58"]
#[doc = " @G_UNICODE_SCRIPT_OLD_SOGDIAN:          Old Sogdian. Since: 2.58"]
#[doc = " @G_UNICODE_SCRIPT_SOGDIAN:              Sogdian. Since: 2.58"]
#[doc = " @G_UNICODE_SCRIPT_ELYMAIC:              Elym. Since: 2.62"]
#[doc = " @G_UNICODE_SCRIPT_NANDINAGARI:          Nand. Since: 2.62"]
#[doc = " @G_UNICODE_SCRIPT_NYIAKENG_PUACHUE_HMONG: Rohg. Since: 2.62"]
#[doc = " @G_UNICODE_SCRIPT_WANCHO:               Wcho. Since: 2.62"]
#[doc = ""]
#[doc = " The #GUnicodeScript enumeration identifies different writing"]
#[doc = " systems. The values correspond to the names as defined in the"]
#[doc = " Unicode standard. The enumeration has been added in GLib 2.14,"]
#[doc = " and is interchangeable with #PangoScript."]
#[doc = ""]
#[doc = " Note that new types may be added in the future. Applications"]
#[doc = " should be ready to handle unknown values."]
#[doc = " See [Unicode Standard Annex #24: Script names](http://www.unicode.org/reports/tr24/)."]
pub type GUnicodeScript = i32;
extern "C" {
    pub fn g_unicode_script_to_iso15924(script: GUnicodeScript) -> guint32;
}
extern "C" {
    pub fn g_unicode_script_from_iso15924(iso15924: guint32) -> GUnicodeScript;
}
extern "C" {
    pub fn g_unichar_isalnum(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_isalpha(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_iscntrl(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_isdigit(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_isgraph(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_islower(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_isprint(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_ispunct(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_isspace(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_isupper(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_isxdigit(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_istitle(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_isdefined(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_iswide(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_iswide_cjk(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_iszerowidth(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_ismark(c: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_toupper(c: gunichar) -> gunichar;
}
extern "C" {
    pub fn g_unichar_tolower(c: gunichar) -> gunichar;
}
extern "C" {
    pub fn g_unichar_totitle(c: gunichar) -> gunichar;
}
extern "C" {
    pub fn g_unichar_digit_value(c: gunichar) -> gint;
}
extern "C" {
    pub fn g_unichar_xdigit_value(c: gunichar) -> gint;
}
extern "C" {
    pub fn g_unichar_type(c: gunichar) -> GUnicodeType;
}
extern "C" {
    pub fn g_unichar_break_type(c: gunichar) -> GUnicodeBreakType;
}
extern "C" {
    pub fn g_unichar_combining_class(uc: gunichar) -> gint;
}
extern "C" {
    pub fn g_unichar_get_mirror_char(ch: gunichar, mirrored_ch: *mut gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_get_script(ch: gunichar) -> GUnicodeScript;
}
extern "C" {
    pub fn g_unichar_validate(ch: gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_compose(a: gunichar, b: gunichar, ch: *mut gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_decompose(ch: gunichar, a: *mut gunichar, b: *mut gunichar) -> gboolean;
}
extern "C" {
    pub fn g_unichar_fully_decompose(
        ch: gunichar,
        compat: gboolean,
        result: *mut gunichar,
        result_len: gsize,
    ) -> gsize;
}
extern "C" {
    pub fn g_unicode_canonical_ordering(string: *mut gunichar, len: gsize);
}
extern "C" {
    pub fn g_unicode_canonical_decomposition(ch: gunichar, result_len: *mut gsize)
        -> *mut gunichar;
}
extern "C" {
    pub static g_utf8_skip: *const gchar;
}
extern "C" {
    pub fn g_utf8_get_char(p: *const gchar) -> gunichar;
}
extern "C" {
    pub fn g_utf8_get_char_validated(p: *const gchar, max_len: gssize) -> gunichar;
}
extern "C" {
    pub fn g_utf8_offset_to_pointer(str_: *const gchar, offset: glong) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_pointer_to_offset(str_: *const gchar, pos: *const gchar) -> glong;
}
extern "C" {
    pub fn g_utf8_prev_char(p: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_find_next_char(p: *const gchar, end: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_find_prev_char(str_: *const gchar, p: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_strlen(p: *const gchar, max: gssize) -> glong;
}
extern "C" {
    pub fn g_utf8_substring(str_: *const gchar, start_pos: glong, end_pos: glong) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_strncpy(dest: *mut gchar, src: *const gchar, n: gsize) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_strchr(p: *const gchar, len: gssize, c: gunichar) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_strrchr(p: *const gchar, len: gssize, c: gunichar) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_strreverse(str_: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_to_utf16(
        str_: *const gchar,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gunichar2;
}
extern "C" {
    pub fn g_utf8_to_ucs4(
        str_: *const gchar,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gunichar;
}
extern "C" {
    pub fn g_utf8_to_ucs4_fast(
        str_: *const gchar,
        len: glong,
        items_written: *mut glong,
    ) -> *mut gunichar;
}
extern "C" {
    pub fn g_utf16_to_ucs4(
        str_: *const gunichar2,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gunichar;
}
extern "C" {
    pub fn g_utf16_to_utf8(
        str_: *const gunichar2,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_ucs4_to_utf16(
        str_: *const gunichar,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gunichar2;
}
extern "C" {
    pub fn g_ucs4_to_utf8(
        str_: *const gunichar,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_unichar_to_utf8(c: gunichar, outbuf: *mut gchar) -> gint;
}
extern "C" {
    pub fn g_utf8_validate(str_: *const gchar, max_len: gssize, end: *mut *const gchar)
        -> gboolean;
}
extern "C" {
    pub fn g_utf8_validate_len(
        str_: *const gchar,
        max_len: gsize,
        end: *mut *const gchar,
    ) -> gboolean;
}
extern "C" {
    pub fn g_utf8_strup(str_: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_strdown(str_: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_casefold(str_: *const gchar, len: gssize) -> *mut gchar;
}
pub const GNormalizeMode_G_NORMALIZE_DEFAULT: GNormalizeMode = 0;
pub const GNormalizeMode_G_NORMALIZE_NFD: GNormalizeMode = 0;
pub const GNormalizeMode_G_NORMALIZE_DEFAULT_COMPOSE: GNormalizeMode = 1;
pub const GNormalizeMode_G_NORMALIZE_NFC: GNormalizeMode = 1;
pub const GNormalizeMode_G_NORMALIZE_ALL: GNormalizeMode = 2;
pub const GNormalizeMode_G_NORMALIZE_NFKD: GNormalizeMode = 2;
pub const GNormalizeMode_G_NORMALIZE_ALL_COMPOSE: GNormalizeMode = 3;
pub const GNormalizeMode_G_NORMALIZE_NFKC: GNormalizeMode = 3;
#[doc = " GNormalizeMode:"]
#[doc = " @G_NORMALIZE_DEFAULT: standardize differences that do not affect the"]
#[doc = "     text content, such as the above-mentioned accent representation"]
#[doc = " @G_NORMALIZE_NFD: another name for %G_NORMALIZE_DEFAULT"]
#[doc = " @G_NORMALIZE_DEFAULT_COMPOSE: like %G_NORMALIZE_DEFAULT, but with"]
#[doc = "     composed forms rather than a maximally decomposed form"]
#[doc = " @G_NORMALIZE_NFC: another name for %G_NORMALIZE_DEFAULT_COMPOSE"]
#[doc = " @G_NORMALIZE_ALL: beyond %G_NORMALIZE_DEFAULT also standardize the"]
#[doc = "     \"compatibility\" characters in Unicode, such as SUPERSCRIPT THREE"]
#[doc = "     to the standard forms (in this case DIGIT THREE). Formatting"]
#[doc = "     information may be lost but for most text operations such"]
#[doc = "     characters should be considered the same"]
#[doc = " @G_NORMALIZE_NFKD: another name for %G_NORMALIZE_ALL"]
#[doc = " @G_NORMALIZE_ALL_COMPOSE: like %G_NORMALIZE_ALL, but with composed"]
#[doc = "     forms rather than a maximally decomposed form"]
#[doc = " @G_NORMALIZE_NFKC: another name for %G_NORMALIZE_ALL_COMPOSE"]
#[doc = ""]
#[doc = " Defines how a Unicode string is transformed in a canonical"]
#[doc = " form, standardizing such issues as whether a character with"]
#[doc = " an accent is represented as a base character and combining"]
#[doc = " accent or as a single precomposed character. Unicode strings"]
#[doc = " should generally be normalized before comparing them."]
pub type GNormalizeMode = u32;
extern "C" {
    pub fn g_utf8_normalize(str_: *const gchar, len: gssize, mode: GNormalizeMode) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_collate(str1: *const gchar, str2: *const gchar) -> gint;
}
extern "C" {
    pub fn g_utf8_collate_key(str_: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_collate_key_for_filename(str_: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    pub fn g_utf8_make_valid(str_: *const gchar, len: gssize) -> *mut gchar;
}
pub type GString = _GString;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GString {
    pub str_: *mut gchar,
    pub len: gsize,
    pub allocated_len: gsize,
}
#[test]
fn bindgen_test_layout__GString() {
    assert_eq!(
        ::core::mem::size_of::<_GString>(),
        24usize,
        concat!("Size of: ", stringify!(_GString))
    );
    assert_eq!(
        ::core::mem::align_of::<_GString>(),
        8usize,
        concat!("Alignment of ", stringify!(_GString))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GString>())).str_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GString),
            "::",
            stringify!(str_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GString>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GString),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GString>())).allocated_len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GString),
            "::",
            stringify!(allocated_len)
        )
    );
}
extern "C" {
    pub fn g_string_new(init: *const gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_new_len(init: *const gchar, len: gssize) -> *mut GString;
}
extern "C" {
    pub fn g_string_sized_new(dfl_size: gsize) -> *mut GString;
}
extern "C" {
    pub fn g_string_free(string: *mut GString, free_segment: gboolean) -> *mut gchar;
}
extern "C" {
    pub fn g_string_free_to_bytes(string: *mut GString) -> *mut GBytes;
}
extern "C" {
    pub fn g_string_equal(v: *const GString, v2: *const GString) -> gboolean;
}
extern "C" {
    pub fn g_string_hash(str_: *const GString) -> guint;
}
extern "C" {
    pub fn g_string_assign(string: *mut GString, rval: *const gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_truncate(string: *mut GString, len: gsize) -> *mut GString;
}
extern "C" {
    pub fn g_string_set_size(string: *mut GString, len: gsize) -> *mut GString;
}
extern "C" {
    pub fn g_string_insert_len(
        string: *mut GString,
        pos: gssize,
        val: *const gchar,
        len: gssize,
    ) -> *mut GString;
}
extern "C" {
    pub fn g_string_append(string: *mut GString, val: *const gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_append_len(
        string: *mut GString,
        val: *const gchar,
        len: gssize,
    ) -> *mut GString;
}
extern "C" {
    pub fn g_string_append_c(string: *mut GString, c: gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_append_unichar(string: *mut GString, wc: gunichar) -> *mut GString;
}
extern "C" {
    pub fn g_string_prepend(string: *mut GString, val: *const gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_prepend_c(string: *mut GString, c: gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_prepend_unichar(string: *mut GString, wc: gunichar) -> *mut GString;
}
extern "C" {
    pub fn g_string_prepend_len(
        string: *mut GString,
        val: *const gchar,
        len: gssize,
    ) -> *mut GString;
}
extern "C" {
    pub fn g_string_insert(string: *mut GString, pos: gssize, val: *const gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_insert_c(string: *mut GString, pos: gssize, c: gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_insert_unichar(string: *mut GString, pos: gssize, wc: gunichar)
        -> *mut GString;
}
extern "C" {
    pub fn g_string_overwrite(string: *mut GString, pos: gsize, val: *const gchar) -> *mut GString;
}
extern "C" {
    pub fn g_string_overwrite_len(
        string: *mut GString,
        pos: gsize,
        val: *const gchar,
        len: gssize,
    ) -> *mut GString;
}
extern "C" {
    pub fn g_string_erase(string: *mut GString, pos: gssize, len: gssize) -> *mut GString;
}
extern "C" {
    pub fn g_string_ascii_down(string: *mut GString) -> *mut GString;
}
extern "C" {
    pub fn g_string_ascii_up(string: *mut GString) -> *mut GString;
}
extern "C" {
    pub fn g_string_vprintf(string: *mut GString, format: *const gchar, args: *mut __va_list_tag);
}
extern "C" {
    pub fn g_string_printf(string: *mut GString, format: *const gchar, ...);
}
extern "C" {
    pub fn g_string_append_vprintf(
        string: *mut GString,
        format: *const gchar,
        args: *mut __va_list_tag,
    );
}
extern "C" {
    pub fn g_string_append_printf(string: *mut GString, format: *const gchar, ...);
}
extern "C" {
    pub fn g_string_append_uri_escaped(
        string: *mut GString,
        unescaped: *const gchar,
        reserved_chars_allowed: *const gchar,
        allow_utf8: gboolean,
    ) -> *mut GString;
}
extern "C" {
    pub fn g_string_down(string: *mut GString) -> *mut GString;
}
extern "C" {
    pub fn g_string_up(string: *mut GString) -> *mut GString;
}
pub type GIOChannel = _GIOChannel;
pub type GIOFuncs = _GIOFuncs;
pub const GIOError_G_IO_ERROR_NONE: GIOError = 0;
pub const GIOError_G_IO_ERROR_AGAIN: GIOError = 1;
pub const GIOError_G_IO_ERROR_INVAL: GIOError = 2;
pub const GIOError_G_IO_ERROR_UNKNOWN: GIOError = 3;
pub type GIOError = u32;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_FBIG: GIOChannelError = 0;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_INVAL: GIOChannelError = 1;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_IO: GIOChannelError = 2;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_ISDIR: GIOChannelError = 3;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_NOSPC: GIOChannelError = 4;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_NXIO: GIOChannelError = 5;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_OVERFLOW: GIOChannelError = 6;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_PIPE: GIOChannelError = 7;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_FAILED: GIOChannelError = 8;
pub type GIOChannelError = u32;
pub const GIOStatus_G_IO_STATUS_ERROR: GIOStatus = 0;
pub const GIOStatus_G_IO_STATUS_NORMAL: GIOStatus = 1;
pub const GIOStatus_G_IO_STATUS_EOF: GIOStatus = 2;
pub const GIOStatus_G_IO_STATUS_AGAIN: GIOStatus = 3;
pub type GIOStatus = u32;
pub const GSeekType_G_SEEK_CUR: GSeekType = 0;
pub const GSeekType_G_SEEK_SET: GSeekType = 1;
pub const GSeekType_G_SEEK_END: GSeekType = 2;
pub type GSeekType = u32;
pub const GIOFlags_G_IO_FLAG_APPEND: GIOFlags = 1;
pub const GIOFlags_G_IO_FLAG_NONBLOCK: GIOFlags = 2;
pub const GIOFlags_G_IO_FLAG_IS_READABLE: GIOFlags = 4;
pub const GIOFlags_G_IO_FLAG_IS_WRITABLE: GIOFlags = 8;
pub const GIOFlags_G_IO_FLAG_IS_WRITEABLE: GIOFlags = 8;
pub const GIOFlags_G_IO_FLAG_IS_SEEKABLE: GIOFlags = 16;
pub const GIOFlags_G_IO_FLAG_MASK: GIOFlags = 31;
pub const GIOFlags_G_IO_FLAG_GET_MASK: GIOFlags = 31;
pub const GIOFlags_G_IO_FLAG_SET_MASK: GIOFlags = 3;
pub type GIOFlags = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOChannel {
    pub ref_count: gint,
    pub funcs: *mut GIOFuncs,
    pub encoding: *mut gchar,
    pub read_cd: GIConv,
    pub write_cd: GIConv,
    pub line_term: *mut gchar,
    pub line_term_len: guint,
    pub buf_size: gsize,
    pub read_buf: *mut GString,
    pub encoded_read_buf: *mut GString,
    pub write_buf: *mut GString,
    pub partial_write_buf: [gchar; 6usize],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub reserved1: gpointer,
    pub reserved2: gpointer,
}
#[test]
fn bindgen_test_layout__GIOChannel() {
    assert_eq!(
        ::core::mem::size_of::<_GIOChannel>(),
        112usize,
        concat!("Size of: ", stringify!(_GIOChannel))
    );
    assert_eq!(
        ::core::mem::align_of::<_GIOChannel>(),
        8usize,
        concat!("Alignment of ", stringify!(_GIOChannel))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GIOChannel>())).ref_count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GIOChannel>())).funcs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(funcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GIOChannel>())).encoding as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(encoding)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GIOChannel>())).read_cd as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(read_cd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GIOChannel>())).write_cd as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(write_cd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GIOChannel>())).line_term as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(line_term)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GIOChannel>())).line_term_len as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(line_term_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GIOChannel>())).buf_size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(buf_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GIOChannel>())).read_buf as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(read_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GIOChannel>())).encoded_read_buf as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(encoded_read_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GIOChannel>())).write_buf as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(write_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GIOChannel>())).partial_write_buf as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(partial_write_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GIOChannel>())).reserved1 as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GIOChannel>())).reserved2 as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(reserved2)
        )
    );
}
impl _GIOChannel {
    #[inline]
    pub fn use_buffer(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_buffer(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn do_encode(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_do_encode(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn close_on_unref(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_close_on_unref(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_readable(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_readable(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_writeable(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_writeable(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_seekable(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_seekable(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        use_buffer: guint,
        do_encode: guint,
        close_on_unref: guint,
        is_readable: guint,
        is_writeable: guint,
        is_seekable: guint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let use_buffer: u32 = unsafe { ::core::mem::transmute(use_buffer) };
            use_buffer as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let do_encode: u32 = unsafe { ::core::mem::transmute(do_encode) };
            do_encode as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let close_on_unref: u32 = unsafe { ::core::mem::transmute(close_on_unref) };
            close_on_unref as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let is_readable: u32 = unsafe { ::core::mem::transmute(is_readable) };
            is_readable as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let is_writeable: u32 = unsafe { ::core::mem::transmute(is_writeable) };
            is_writeable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let is_seekable: u32 = unsafe { ::core::mem::transmute(is_seekable) };
            is_seekable as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type GIOFunc = ::core::option::Option<
    unsafe extern "C" fn(
        source: *mut GIOChannel,
        condition: GIOCondition,
        data: gpointer,
    ) -> gboolean,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOFuncs {
    pub io_read: ::core::option::Option<
        unsafe extern "C" fn(
            channel: *mut GIOChannel,
            buf: *mut gchar,
            count: gsize,
            bytes_read: *mut gsize,
            err: *mut *mut GError,
        ) -> GIOStatus,
    >,
    pub io_write: ::core::option::Option<
        unsafe extern "C" fn(
            channel: *mut GIOChannel,
            buf: *const gchar,
            count: gsize,
            bytes_written: *mut gsize,
            err: *mut *mut GError,
        ) -> GIOStatus,
    >,
    pub io_seek: ::core::option::Option<
        unsafe extern "C" fn(
            channel: *mut GIOChannel,
            offset: gint64,
            type_: GSeekType,
            err: *mut *mut GError,
        ) -> GIOStatus,
    >,
    pub io_close: ::core::option::Option<
        unsafe extern "C" fn(channel: *mut GIOChannel, err: *mut *mut GError) -> GIOStatus,
    >,
    pub io_create_watch: ::core::option::Option<
        unsafe extern "C" fn(channel: *mut GIOChannel, condition: GIOCondition) -> *mut GSource,
    >,
    pub io_free: ::core::option::Option<unsafe extern "C" fn(channel: *mut GIOChannel)>,
    pub io_set_flags: ::core::option::Option<
        unsafe extern "C" fn(
            channel: *mut GIOChannel,
            flags: GIOFlags,
            err: *mut *mut GError,
        ) -> GIOStatus,
    >,
    pub io_get_flags:
        ::core::option::Option<unsafe extern "C" fn(channel: *mut GIOChannel) -> GIOFlags>,
}
#[test]
fn bindgen_test_layout__GIOFuncs() {
    assert_eq!(
        ::core::mem::size_of::<_GIOFuncs>(),
        64usize,
        concat!("Size of: ", stringify!(_GIOFuncs))
    );
    assert_eq!(
        ::core::mem::align_of::<_GIOFuncs>(),
        8usize,
        concat!("Alignment of ", stringify!(_GIOFuncs))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GIOFuncs>())).io_read as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GIOFuncs>())).io_write as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_write)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GIOFuncs>())).io_seek as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_seek)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GIOFuncs>())).io_close as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_close)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GIOFuncs>())).io_create_watch as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_create_watch)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GIOFuncs>())).io_free as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_free)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GIOFuncs>())).io_set_flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_set_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GIOFuncs>())).io_get_flags as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_get_flags)
        )
    );
}
extern "C" {
    pub fn g_io_channel_init(channel: *mut GIOChannel);
}
extern "C" {
    pub fn g_io_channel_ref(channel: *mut GIOChannel) -> *mut GIOChannel;
}
extern "C" {
    pub fn g_io_channel_unref(channel: *mut GIOChannel);
}
extern "C" {
    pub fn g_io_channel_read(
        channel: *mut GIOChannel,
        buf: *mut gchar,
        count: gsize,
        bytes_read: *mut gsize,
    ) -> GIOError;
}
extern "C" {
    pub fn g_io_channel_write(
        channel: *mut GIOChannel,
        buf: *const gchar,
        count: gsize,
        bytes_written: *mut gsize,
    ) -> GIOError;
}
extern "C" {
    pub fn g_io_channel_seek(
        channel: *mut GIOChannel,
        offset: gint64,
        type_: GSeekType,
    ) -> GIOError;
}
extern "C" {
    pub fn g_io_channel_close(channel: *mut GIOChannel);
}
extern "C" {
    pub fn g_io_channel_shutdown(
        channel: *mut GIOChannel,
        flush: gboolean,
        err: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_add_watch_full(
        channel: *mut GIOChannel,
        priority: gint,
        condition: GIOCondition,
        func: GIOFunc,
        user_data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    pub fn g_io_create_watch(channel: *mut GIOChannel, condition: GIOCondition) -> *mut GSource;
}
extern "C" {
    pub fn g_io_add_watch(
        channel: *mut GIOChannel,
        condition: GIOCondition,
        func: GIOFunc,
        user_data: gpointer,
    ) -> guint;
}
extern "C" {
    pub fn g_io_channel_set_buffer_size(channel: *mut GIOChannel, size: gsize);
}
extern "C" {
    pub fn g_io_channel_get_buffer_size(channel: *mut GIOChannel) -> gsize;
}
extern "C" {
    pub fn g_io_channel_get_buffer_condition(channel: *mut GIOChannel) -> GIOCondition;
}
extern "C" {
    pub fn g_io_channel_set_flags(
        channel: *mut GIOChannel,
        flags: GIOFlags,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_get_flags(channel: *mut GIOChannel) -> GIOFlags;
}
extern "C" {
    pub fn g_io_channel_set_line_term(
        channel: *mut GIOChannel,
        line_term: *const gchar,
        length: gint,
    );
}
extern "C" {
    pub fn g_io_channel_get_line_term(channel: *mut GIOChannel, length: *mut gint) -> *const gchar;
}
extern "C" {
    pub fn g_io_channel_set_buffered(channel: *mut GIOChannel, buffered: gboolean);
}
extern "C" {
    pub fn g_io_channel_get_buffered(channel: *mut GIOChannel) -> gboolean;
}
extern "C" {
    pub fn g_io_channel_set_encoding(
        channel: *mut GIOChannel,
        encoding: *const gchar,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_get_encoding(channel: *mut GIOChannel) -> *const gchar;
}
extern "C" {
    pub fn g_io_channel_set_close_on_unref(channel: *mut GIOChannel, do_close: gboolean);
}
extern "C" {
    pub fn g_io_channel_get_close_on_unref(channel: *mut GIOChannel) -> gboolean;
}
extern "C" {
    pub fn g_io_channel_flush(channel: *mut GIOChannel, error: *mut *mut GError) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_read_line(
        channel: *mut GIOChannel,
        str_return: *mut *mut gchar,
        length: *mut gsize,
        terminator_pos: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_read_line_string(
        channel: *mut GIOChannel,
        buffer: *mut GString,
        terminator_pos: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_read_to_end(
        channel: *mut GIOChannel,
        str_return: *mut *mut gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_read_chars(
        channel: *mut GIOChannel,
        buf: *mut gchar,
        count: gsize,
        bytes_read: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_read_unichar(
        channel: *mut GIOChannel,
        thechar: *mut gunichar,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_write_chars(
        channel: *mut GIOChannel,
        buf: *const gchar,
        count: gssize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_write_unichar(
        channel: *mut GIOChannel,
        thechar: gunichar,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_seek_position(
        channel: *mut GIOChannel,
        offset: gint64,
        type_: GSeekType,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    pub fn g_io_channel_new_file(
        filename: *const gchar,
        mode: *const gchar,
        error: *mut *mut GError,
    ) -> *mut GIOChannel;
}
extern "C" {
    pub fn g_io_channel_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_io_channel_error_from_errno(en: gint) -> GIOChannelError;
}
extern "C" {
    pub fn g_io_channel_unix_new(fd: cty::c_int) -> *mut GIOChannel;
}
extern "C" {
    pub fn g_io_channel_unix_get_fd(channel: *mut GIOChannel) -> gint;
}
extern "C" {
    pub static mut g_io_watch_funcs: GSourceFuncs;
}
pub const GKeyFileError_G_KEY_FILE_ERROR_UNKNOWN_ENCODING: GKeyFileError = 0;
pub const GKeyFileError_G_KEY_FILE_ERROR_PARSE: GKeyFileError = 1;
pub const GKeyFileError_G_KEY_FILE_ERROR_NOT_FOUND: GKeyFileError = 2;
pub const GKeyFileError_G_KEY_FILE_ERROR_KEY_NOT_FOUND: GKeyFileError = 3;
pub const GKeyFileError_G_KEY_FILE_ERROR_GROUP_NOT_FOUND: GKeyFileError = 4;
pub const GKeyFileError_G_KEY_FILE_ERROR_INVALID_VALUE: GKeyFileError = 5;
pub type GKeyFileError = u32;
extern "C" {
    pub fn g_key_file_error_quark() -> GQuark;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GKeyFile {
    _unused: [u8; 0],
}
pub type GKeyFile = _GKeyFile;
pub const GKeyFileFlags_G_KEY_FILE_NONE: GKeyFileFlags = 0;
pub const GKeyFileFlags_G_KEY_FILE_KEEP_COMMENTS: GKeyFileFlags = 1;
pub const GKeyFileFlags_G_KEY_FILE_KEEP_TRANSLATIONS: GKeyFileFlags = 2;
pub type GKeyFileFlags = u32;
extern "C" {
    pub fn g_key_file_new() -> *mut GKeyFile;
}
extern "C" {
    pub fn g_key_file_ref(key_file: *mut GKeyFile) -> *mut GKeyFile;
}
extern "C" {
    pub fn g_key_file_unref(key_file: *mut GKeyFile);
}
extern "C" {
    pub fn g_key_file_free(key_file: *mut GKeyFile);
}
extern "C" {
    pub fn g_key_file_set_list_separator(key_file: *mut GKeyFile, separator: gchar);
}
extern "C" {
    pub fn g_key_file_load_from_file(
        key_file: *mut GKeyFile,
        file: *const gchar,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_load_from_data(
        key_file: *mut GKeyFile,
        data: *const gchar,
        length: gsize,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_load_from_bytes(
        key_file: *mut GKeyFile,
        bytes: *mut GBytes,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_load_from_dirs(
        key_file: *mut GKeyFile,
        file: *const gchar,
        search_dirs: *mut *const gchar,
        full_path: *mut *mut gchar,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_load_from_data_dirs(
        key_file: *mut GKeyFile,
        file: *const gchar,
        full_path: *mut *mut gchar,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_to_data(
        key_file: *mut GKeyFile,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_key_file_save_to_file(
        key_file: *mut GKeyFile,
        filename: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_get_start_group(key_file: *mut GKeyFile) -> *mut gchar;
}
extern "C" {
    pub fn g_key_file_get_groups(key_file: *mut GKeyFile, length: *mut gsize) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_key_file_get_keys(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_key_file_has_group(key_file: *mut GKeyFile, group_name: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_key_file_has_key(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_get_value(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_key_file_set_value(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: *const gchar,
    );
}
extern "C" {
    pub fn g_key_file_get_string(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_key_file_set_string(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        string: *const gchar,
    );
}
extern "C" {
    pub fn g_key_file_get_locale_string(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_key_file_get_locale_for_key(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_key_file_set_locale_string(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
        string: *const gchar,
    );
}
extern "C" {
    pub fn g_key_file_get_boolean(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_set_boolean(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: gboolean,
    );
}
extern "C" {
    pub fn g_key_file_get_integer(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gint;
}
extern "C" {
    pub fn g_key_file_set_integer(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: gint,
    );
}
extern "C" {
    pub fn g_key_file_get_int64(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gint64;
}
extern "C" {
    pub fn g_key_file_set_int64(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: gint64,
    );
}
extern "C" {
    pub fn g_key_file_get_uint64(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> guint64;
}
extern "C" {
    pub fn g_key_file_set_uint64(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: guint64,
    );
}
extern "C" {
    pub fn g_key_file_get_double(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gdouble;
}
extern "C" {
    pub fn g_key_file_set_double(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: gdouble,
    );
}
extern "C" {
    pub fn g_key_file_get_string_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_key_file_set_string_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        list: *const *const gchar,
        length: gsize,
    );
}
extern "C" {
    pub fn g_key_file_get_locale_string_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_key_file_set_locale_string_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
        list: *const *const gchar,
        length: gsize,
    );
}
extern "C" {
    pub fn g_key_file_get_boolean_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gboolean;
}
extern "C" {
    pub fn g_key_file_set_boolean_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        list: *mut gboolean,
        length: gsize,
    );
}
extern "C" {
    pub fn g_key_file_get_integer_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gint;
}
extern "C" {
    pub fn g_key_file_set_double_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        list: *mut gdouble,
        length: gsize,
    );
}
extern "C" {
    pub fn g_key_file_get_double_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gdouble;
}
extern "C" {
    pub fn g_key_file_set_integer_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        list: *mut gint,
        length: gsize,
    );
}
extern "C" {
    pub fn g_key_file_set_comment(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        comment: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_get_comment(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_key_file_remove_comment(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_remove_key(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_key_file_remove_group(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMappedFile {
    _unused: [u8; 0],
}
pub type GMappedFile = _GMappedFile;
extern "C" {
    pub fn g_mapped_file_new(
        filename: *const gchar,
        writable: gboolean,
        error: *mut *mut GError,
    ) -> *mut GMappedFile;
}
extern "C" {
    pub fn g_mapped_file_new_from_fd(
        fd: gint,
        writable: gboolean,
        error: *mut *mut GError,
    ) -> *mut GMappedFile;
}
extern "C" {
    pub fn g_mapped_file_get_length(file: *mut GMappedFile) -> gsize;
}
extern "C" {
    pub fn g_mapped_file_get_contents(file: *mut GMappedFile) -> *mut gchar;
}
extern "C" {
    pub fn g_mapped_file_get_bytes(file: *mut GMappedFile) -> *mut GBytes;
}
extern "C" {
    pub fn g_mapped_file_ref(file: *mut GMappedFile) -> *mut GMappedFile;
}
extern "C" {
    pub fn g_mapped_file_unref(file: *mut GMappedFile);
}
extern "C" {
    pub fn g_mapped_file_free(file: *mut GMappedFile);
}
pub const GMarkupError_G_MARKUP_ERROR_BAD_UTF8: GMarkupError = 0;
pub const GMarkupError_G_MARKUP_ERROR_EMPTY: GMarkupError = 1;
pub const GMarkupError_G_MARKUP_ERROR_PARSE: GMarkupError = 2;
pub const GMarkupError_G_MARKUP_ERROR_UNKNOWN_ELEMENT: GMarkupError = 3;
pub const GMarkupError_G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE: GMarkupError = 4;
pub const GMarkupError_G_MARKUP_ERROR_INVALID_CONTENT: GMarkupError = 5;
pub const GMarkupError_G_MARKUP_ERROR_MISSING_ATTRIBUTE: GMarkupError = 6;
#[doc = " GMarkupError:"]
#[doc = " @G_MARKUP_ERROR_BAD_UTF8: text being parsed was not valid UTF-8"]
#[doc = " @G_MARKUP_ERROR_EMPTY: document contained nothing, or only whitespace"]
#[doc = " @G_MARKUP_ERROR_PARSE: document was ill-formed"]
#[doc = " @G_MARKUP_ERROR_UNKNOWN_ELEMENT: error should be set by #GMarkupParser"]
#[doc = "     functions; element wasn't known"]
#[doc = " @G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE: error should be set by #GMarkupParser"]
#[doc = "     functions; attribute wasn't known"]
#[doc = " @G_MARKUP_ERROR_INVALID_CONTENT: error should be set by #GMarkupParser"]
#[doc = "     functions; content was invalid"]
#[doc = " @G_MARKUP_ERROR_MISSING_ATTRIBUTE: error should be set by #GMarkupParser"]
#[doc = "     functions; a required attribute was missing"]
#[doc = ""]
#[doc = " Error codes returned by markup parsing."]
pub type GMarkupError = u32;
extern "C" {
    pub fn g_markup_error_quark() -> GQuark;
}
pub const GMarkupParseFlags_G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG: GMarkupParseFlags = 1;
pub const GMarkupParseFlags_G_MARKUP_TREAT_CDATA_AS_TEXT: GMarkupParseFlags = 2;
pub const GMarkupParseFlags_G_MARKUP_PREFIX_ERROR_POSITION: GMarkupParseFlags = 4;
pub const GMarkupParseFlags_G_MARKUP_IGNORE_QUALIFIED: GMarkupParseFlags = 8;
#[doc = " GMarkupParseFlags:"]
#[doc = " @G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG: flag you should not use"]
#[doc = " @G_MARKUP_TREAT_CDATA_AS_TEXT: When this flag is set, CDATA marked"]
#[doc = "     sections are not passed literally to the @passthrough function of"]
#[doc = "     the parser. Instead, the content of the section (without the"]
#[doc = "     `<![CDATA[` and `]]>`) is"]
#[doc = "     passed to the @text function. This flag was added in GLib 2.12"]
#[doc = " @G_MARKUP_PREFIX_ERROR_POSITION: Normally errors caught by GMarkup"]
#[doc = "     itself have line/column information prefixed to them to let the"]
#[doc = "     caller know the location of the error. When this flag is set the"]
#[doc = "     location information is also prefixed to errors generated by the"]
#[doc = "     #GMarkupParser implementation functions"]
#[doc = " @G_MARKUP_IGNORE_QUALIFIED: Ignore (don't report) qualified"]
#[doc = "     attributes and tags, along with their contents.  A qualified"]
#[doc = "     attribute or tag is one that contains ':' in its name (ie: is in"]
#[doc = "     another namespace).  Since: 2.40."]
#[doc = ""]
#[doc = " Flags that affect the behaviour of the parser."]
pub type GMarkupParseFlags = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMarkupParseContext {
    _unused: [u8; 0],
}
#[doc = " GMarkupParseContext:"]
#[doc = ""]
#[doc = " A parse context is used to parse a stream of bytes that"]
#[doc = " you expect to contain marked-up text."]
#[doc = ""]
#[doc = " See g_markup_parse_context_new(), #GMarkupParser, and so"]
#[doc = " on for more details."]
pub type GMarkupParseContext = _GMarkupParseContext;
pub type GMarkupParser = _GMarkupParser;
#[doc = " GMarkupParser:"]
#[doc = " @start_element: Callback to invoke when the opening tag of an element"]
#[doc = "     is seen. The callback's @attribute_names and @attribute_values parameters"]
#[doc = "     are %NULL-terminated."]
#[doc = " @end_element: Callback to invoke when the closing tag of an element"]
#[doc = "     is seen. Note that this is also called for empty tags like"]
#[doc = "     `<empty/>`."]
#[doc = " @text: Callback to invoke when some text is seen (text is always"]
#[doc = "     inside an element). Note that the text of an element may be spread"]
#[doc = "     over multiple calls of this function. If the"]
#[doc = "     %G_MARKUP_TREAT_CDATA_AS_TEXT flag is set, this function is also"]
#[doc = "     called for the content of CDATA marked sections."]
#[doc = " @passthrough: Callback to invoke for comments, processing instructions"]
#[doc = "     and doctype declarations; if you're re-writing the parsed document,"]
#[doc = "     write the passthrough text back out in the same position. If the"]
#[doc = "     %G_MARKUP_TREAT_CDATA_AS_TEXT flag is not set, this function is also"]
#[doc = "     called for CDATA marked sections."]
#[doc = " @error: Callback to invoke when an error occurs."]
#[doc = ""]
#[doc = " Any of the fields in #GMarkupParser can be %NULL, in which case they"]
#[doc = " will be ignored. Except for the @error function, any of these callbacks"]
#[doc = " can set an error; in particular the %G_MARKUP_ERROR_UNKNOWN_ELEMENT,"]
#[doc = " %G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE, and %G_MARKUP_ERROR_INVALID_CONTENT"]
#[doc = " errors are intended to be set from these callbacks. If you set an error"]
#[doc = " from a callback, g_markup_parse_context_parse() will report that error"]
#[doc = " back to its caller."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMarkupParser {
    pub start_element: ::core::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            element_name: *const gchar,
            attribute_names: *mut *const gchar,
            attribute_values: *mut *const gchar,
            user_data: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub end_element: ::core::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            element_name: *const gchar,
            user_data: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub text: ::core::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            text: *const gchar,
            text_len: gsize,
            user_data: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub passthrough: ::core::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            passthrough_text: *const gchar,
            text_len: gsize,
            user_data: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub error: ::core::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            error: *mut GError,
            user_data: gpointer,
        ),
    >,
}
#[test]
fn bindgen_test_layout__GMarkupParser() {
    assert_eq!(
        ::core::mem::size_of::<_GMarkupParser>(),
        40usize,
        concat!("Size of: ", stringify!(_GMarkupParser))
    );
    assert_eq!(
        ::core::mem::align_of::<_GMarkupParser>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMarkupParser))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GMarkupParser>())).start_element as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMarkupParser),
            "::",
            stringify!(start_element)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GMarkupParser>())).end_element as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMarkupParser),
            "::",
            stringify!(end_element)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GMarkupParser>())).text as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMarkupParser),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GMarkupParser>())).passthrough as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMarkupParser),
            "::",
            stringify!(passthrough)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GMarkupParser>())).error as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMarkupParser),
            "::",
            stringify!(error)
        )
    );
}
extern "C" {
    pub fn g_markup_parse_context_new(
        parser: *const GMarkupParser,
        flags: GMarkupParseFlags,
        user_data: gpointer,
        user_data_dnotify: GDestroyNotify,
    ) -> *mut GMarkupParseContext;
}
extern "C" {
    pub fn g_markup_parse_context_ref(
        context: *mut GMarkupParseContext,
    ) -> *mut GMarkupParseContext;
}
extern "C" {
    pub fn g_markup_parse_context_unref(context: *mut GMarkupParseContext);
}
extern "C" {
    pub fn g_markup_parse_context_free(context: *mut GMarkupParseContext);
}
extern "C" {
    pub fn g_markup_parse_context_parse(
        context: *mut GMarkupParseContext,
        text: *const gchar,
        text_len: gssize,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_markup_parse_context_push(
        context: *mut GMarkupParseContext,
        parser: *const GMarkupParser,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_markup_parse_context_pop(context: *mut GMarkupParseContext) -> gpointer;
}
extern "C" {
    pub fn g_markup_parse_context_end_parse(
        context: *mut GMarkupParseContext,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_markup_parse_context_get_element(context: *mut GMarkupParseContext) -> *const gchar;
}
extern "C" {
    pub fn g_markup_parse_context_get_element_stack(
        context: *mut GMarkupParseContext,
    ) -> *const GSList;
}
extern "C" {
    pub fn g_markup_parse_context_get_position(
        context: *mut GMarkupParseContext,
        line_number: *mut gint,
        char_number: *mut gint,
    );
}
extern "C" {
    pub fn g_markup_parse_context_get_user_data(context: *mut GMarkupParseContext) -> gpointer;
}
extern "C" {
    pub fn g_markup_escape_text(text: *const gchar, length: gssize) -> *mut gchar;
}
extern "C" {
    pub fn g_markup_printf_escaped(format: *const cty::c_char, ...) -> *mut gchar;
}
extern "C" {
    pub fn g_markup_vprintf_escaped(
        format: *const cty::c_char,
        args: *mut __va_list_tag,
    ) -> *mut gchar;
}
pub const GMarkupCollectType_G_MARKUP_COLLECT_INVALID: GMarkupCollectType = 0;
pub const GMarkupCollectType_G_MARKUP_COLLECT_STRING: GMarkupCollectType = 1;
pub const GMarkupCollectType_G_MARKUP_COLLECT_STRDUP: GMarkupCollectType = 2;
pub const GMarkupCollectType_G_MARKUP_COLLECT_BOOLEAN: GMarkupCollectType = 3;
pub const GMarkupCollectType_G_MARKUP_COLLECT_TRISTATE: GMarkupCollectType = 4;
pub const GMarkupCollectType_G_MARKUP_COLLECT_OPTIONAL: GMarkupCollectType = 65536;
pub type GMarkupCollectType = u32;
extern "C" {
    pub fn g_markup_collect_attributes(
        element_name: *const gchar,
        attribute_names: *mut *const gchar,
        attribute_values: *mut *const gchar,
        error: *mut *mut GError,
        first_type: GMarkupCollectType,
        first_attr: *const gchar,
        ...
    ) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariantType {
    _unused: [u8; 0],
}
#[doc = " GVariantType:"]
#[doc = ""]
#[doc = " A type in the GVariant type system."]
#[doc = ""]
#[doc = " Two types may not be compared by value; use g_variant_type_equal() or"]
#[doc = " g_variant_type_is_subtype_of().  May be copied using"]
#[doc = " g_variant_type_copy() and freed using g_variant_type_free()."]
pub type GVariantType = _GVariantType;
extern "C" {
    pub fn g_variant_type_string_is_valid(type_string: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_string_scan(
        string: *const gchar,
        limit: *const gchar,
        endptr: *mut *const gchar,
    ) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_free(type_: *mut GVariantType);
}
extern "C" {
    pub fn g_variant_type_copy(type_: *const GVariantType) -> *mut GVariantType;
}
extern "C" {
    pub fn g_variant_type_new(type_string: *const gchar) -> *mut GVariantType;
}
extern "C" {
    pub fn g_variant_type_get_string_length(type_: *const GVariantType) -> gsize;
}
extern "C" {
    pub fn g_variant_type_peek_string(type_: *const GVariantType) -> *const gchar;
}
extern "C" {
    pub fn g_variant_type_dup_string(type_: *const GVariantType) -> *mut gchar;
}
extern "C" {
    pub fn g_variant_type_is_definite(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_is_container(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_is_basic(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_is_maybe(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_is_array(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_is_tuple(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_is_dict_entry(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_is_variant(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_hash(type_: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_variant_type_equal(type1: gconstpointer, type2: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_is_subtype_of(
        type_: *const GVariantType,
        supertype: *const GVariantType,
    ) -> gboolean;
}
extern "C" {
    pub fn g_variant_type_element(type_: *const GVariantType) -> *const GVariantType;
}
extern "C" {
    pub fn g_variant_type_first(type_: *const GVariantType) -> *const GVariantType;
}
extern "C" {
    pub fn g_variant_type_next(type_: *const GVariantType) -> *const GVariantType;
}
extern "C" {
    pub fn g_variant_type_n_items(type_: *const GVariantType) -> gsize;
}
extern "C" {
    pub fn g_variant_type_key(type_: *const GVariantType) -> *const GVariantType;
}
extern "C" {
    pub fn g_variant_type_value(type_: *const GVariantType) -> *const GVariantType;
}
extern "C" {
    pub fn g_variant_type_new_array(element: *const GVariantType) -> *mut GVariantType;
}
extern "C" {
    pub fn g_variant_type_new_maybe(element: *const GVariantType) -> *mut GVariantType;
}
extern "C" {
    pub fn g_variant_type_new_tuple(
        items: *const *const GVariantType,
        length: gint,
    ) -> *mut GVariantType;
}
extern "C" {
    pub fn g_variant_type_new_dict_entry(
        key: *const GVariantType,
        value: *const GVariantType,
    ) -> *mut GVariantType;
}
extern "C" {
    pub fn g_variant_type_checked_(arg1: *const gchar) -> *const GVariantType;
}
extern "C" {
    pub fn g_variant_type_string_get_depth_(type_string: *const gchar) -> gsize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariant {
    _unused: [u8; 0],
}
pub type GVariant = _GVariant;
pub const GVariantClass_G_VARIANT_CLASS_BOOLEAN: GVariantClass = 98;
pub const GVariantClass_G_VARIANT_CLASS_BYTE: GVariantClass = 121;
pub const GVariantClass_G_VARIANT_CLASS_INT16: GVariantClass = 110;
pub const GVariantClass_G_VARIANT_CLASS_UINT16: GVariantClass = 113;
pub const GVariantClass_G_VARIANT_CLASS_INT32: GVariantClass = 105;
pub const GVariantClass_G_VARIANT_CLASS_UINT32: GVariantClass = 117;
pub const GVariantClass_G_VARIANT_CLASS_INT64: GVariantClass = 120;
pub const GVariantClass_G_VARIANT_CLASS_UINT64: GVariantClass = 116;
pub const GVariantClass_G_VARIANT_CLASS_HANDLE: GVariantClass = 104;
pub const GVariantClass_G_VARIANT_CLASS_DOUBLE: GVariantClass = 100;
pub const GVariantClass_G_VARIANT_CLASS_STRING: GVariantClass = 115;
pub const GVariantClass_G_VARIANT_CLASS_OBJECT_PATH: GVariantClass = 111;
pub const GVariantClass_G_VARIANT_CLASS_SIGNATURE: GVariantClass = 103;
pub const GVariantClass_G_VARIANT_CLASS_VARIANT: GVariantClass = 118;
pub const GVariantClass_G_VARIANT_CLASS_MAYBE: GVariantClass = 109;
pub const GVariantClass_G_VARIANT_CLASS_ARRAY: GVariantClass = 97;
pub const GVariantClass_G_VARIANT_CLASS_TUPLE: GVariantClass = 40;
pub const GVariantClass_G_VARIANT_CLASS_DICT_ENTRY: GVariantClass = 123;
pub type GVariantClass = u32;
extern "C" {
    pub fn g_variant_unref(value: *mut GVariant);
}
extern "C" {
    pub fn g_variant_ref(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_ref_sink(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_is_floating(value: *mut GVariant) -> gboolean;
}
extern "C" {
    pub fn g_variant_take_ref(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_get_type(value: *mut GVariant) -> *const GVariantType;
}
extern "C" {
    pub fn g_variant_get_type_string(value: *mut GVariant) -> *const gchar;
}
extern "C" {
    pub fn g_variant_is_of_type(value: *mut GVariant, type_: *const GVariantType) -> gboolean;
}
extern "C" {
    pub fn g_variant_is_container(value: *mut GVariant) -> gboolean;
}
extern "C" {
    pub fn g_variant_classify(value: *mut GVariant) -> GVariantClass;
}
extern "C" {
    pub fn g_variant_new_boolean(value: gboolean) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_byte(value: guint8) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_int16(value: gint16) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_uint16(value: guint16) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_int32(value: gint32) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_uint32(value: guint32) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_int64(value: gint64) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_uint64(value: guint64) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_handle(value: gint32) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_double(value: gdouble) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_string(string: *const gchar) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_take_string(string: *mut gchar) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_printf(format_string: *const gchar, ...) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_object_path(object_path: *const gchar) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_is_object_path(string: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_variant_new_signature(signature: *const gchar) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_is_signature(string: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_variant_new_variant(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_strv(strv: *const *const gchar, length: gssize) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_objv(strv: *const *const gchar, length: gssize) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_bytestring(string: *const gchar) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_bytestring_array(
        strv: *const *const gchar,
        length: gssize,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_fixed_array(
        element_type: *const GVariantType,
        elements: gconstpointer,
        n_elements: gsize,
        element_size: gsize,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_get_boolean(value: *mut GVariant) -> gboolean;
}
extern "C" {
    pub fn g_variant_get_byte(value: *mut GVariant) -> guint8;
}
extern "C" {
    pub fn g_variant_get_int16(value: *mut GVariant) -> gint16;
}
extern "C" {
    pub fn g_variant_get_uint16(value: *mut GVariant) -> guint16;
}
extern "C" {
    pub fn g_variant_get_int32(value: *mut GVariant) -> gint32;
}
extern "C" {
    pub fn g_variant_get_uint32(value: *mut GVariant) -> guint32;
}
extern "C" {
    pub fn g_variant_get_int64(value: *mut GVariant) -> gint64;
}
extern "C" {
    pub fn g_variant_get_uint64(value: *mut GVariant) -> guint64;
}
extern "C" {
    pub fn g_variant_get_handle(value: *mut GVariant) -> gint32;
}
extern "C" {
    pub fn g_variant_get_double(value: *mut GVariant) -> gdouble;
}
extern "C" {
    pub fn g_variant_get_variant(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_get_string(value: *mut GVariant, length: *mut gsize) -> *const gchar;
}
extern "C" {
    pub fn g_variant_dup_string(value: *mut GVariant, length: *mut gsize) -> *mut gchar;
}
extern "C" {
    pub fn g_variant_get_strv(value: *mut GVariant, length: *mut gsize) -> *mut *const gchar;
}
extern "C" {
    pub fn g_variant_dup_strv(value: *mut GVariant, length: *mut gsize) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_variant_get_objv(value: *mut GVariant, length: *mut gsize) -> *mut *const gchar;
}
extern "C" {
    pub fn g_variant_dup_objv(value: *mut GVariant, length: *mut gsize) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_variant_get_bytestring(value: *mut GVariant) -> *const gchar;
}
extern "C" {
    pub fn g_variant_dup_bytestring(value: *mut GVariant, length: *mut gsize) -> *mut gchar;
}
extern "C" {
    pub fn g_variant_get_bytestring_array(
        value: *mut GVariant,
        length: *mut gsize,
    ) -> *mut *const gchar;
}
extern "C" {
    pub fn g_variant_dup_bytestring_array(
        value: *mut GVariant,
        length: *mut gsize,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_variant_new_maybe(
        child_type: *const GVariantType,
        child: *mut GVariant,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_array(
        child_type: *const GVariantType,
        children: *const *mut GVariant,
        n_children: gsize,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_tuple(children: *const *mut GVariant, n_children: gsize) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_dict_entry(key: *mut GVariant, value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_get_maybe(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_n_children(value: *mut GVariant) -> gsize;
}
extern "C" {
    pub fn g_variant_get_child(
        value: *mut GVariant,
        index_: gsize,
        format_string: *const gchar,
        ...
    );
}
extern "C" {
    pub fn g_variant_get_child_value(value: *mut GVariant, index_: gsize) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_lookup(
        dictionary: *mut GVariant,
        key: *const gchar,
        format_string: *const gchar,
        ...
    ) -> gboolean;
}
extern "C" {
    pub fn g_variant_lookup_value(
        dictionary: *mut GVariant,
        key: *const gchar,
        expected_type: *const GVariantType,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_get_fixed_array(
        value: *mut GVariant,
        n_elements: *mut gsize,
        element_size: gsize,
    ) -> gconstpointer;
}
extern "C" {
    pub fn g_variant_get_size(value: *mut GVariant) -> gsize;
}
extern "C" {
    pub fn g_variant_get_data(value: *mut GVariant) -> gconstpointer;
}
extern "C" {
    pub fn g_variant_get_data_as_bytes(value: *mut GVariant) -> *mut GBytes;
}
extern "C" {
    pub fn g_variant_store(value: *mut GVariant, data: gpointer);
}
extern "C" {
    pub fn g_variant_print(value: *mut GVariant, type_annotate: gboolean) -> *mut gchar;
}
extern "C" {
    pub fn g_variant_print_string(
        value: *mut GVariant,
        string: *mut GString,
        type_annotate: gboolean,
    ) -> *mut GString;
}
extern "C" {
    pub fn g_variant_hash(value: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_variant_equal(one: gconstpointer, two: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_variant_get_normal_form(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_is_normal_form(value: *mut GVariant) -> gboolean;
}
extern "C" {
    pub fn g_variant_byteswap(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_from_bytes(
        type_: *const GVariantType,
        bytes: *mut GBytes,
        trusted: gboolean,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_from_data(
        type_: *const GVariantType,
        data: gconstpointer,
        size: gsize,
        trusted: gboolean,
        notify: GDestroyNotify,
        user_data: gpointer,
    ) -> *mut GVariant;
}
pub type GVariantIter = _GVariantIter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariantIter {
    pub x: [gsize; 16usize],
}
#[test]
fn bindgen_test_layout__GVariantIter() {
    assert_eq!(
        ::core::mem::size_of::<_GVariantIter>(),
        128usize,
        concat!("Size of: ", stringify!(_GVariantIter))
    );
    assert_eq!(
        ::core::mem::align_of::<_GVariantIter>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVariantIter))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GVariantIter>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantIter),
            "::",
            stringify!(x)
        )
    );
}
extern "C" {
    pub fn g_variant_iter_new(value: *mut GVariant) -> *mut GVariantIter;
}
extern "C" {
    pub fn g_variant_iter_init(iter: *mut GVariantIter, value: *mut GVariant) -> gsize;
}
extern "C" {
    pub fn g_variant_iter_copy(iter: *mut GVariantIter) -> *mut GVariantIter;
}
extern "C" {
    pub fn g_variant_iter_n_children(iter: *mut GVariantIter) -> gsize;
}
extern "C" {
    pub fn g_variant_iter_free(iter: *mut GVariantIter);
}
extern "C" {
    pub fn g_variant_iter_next_value(iter: *mut GVariantIter) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_iter_next(
        iter: *mut GVariantIter,
        format_string: *const gchar,
        ...
    ) -> gboolean;
}
extern "C" {
    pub fn g_variant_iter_loop(
        iter: *mut GVariantIter,
        format_string: *const gchar,
        ...
    ) -> gboolean;
}
pub type GVariantBuilder = _GVariantBuilder;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GVariantBuilder {
    pub u: _GVariantBuilder__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GVariantBuilder__bindgen_ty_1 {
    pub s: _GVariantBuilder__bindgen_ty_1__bindgen_ty_1,
    pub x: [gsize; 16usize],
    _bindgen_union_align: [u64; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariantBuilder__bindgen_ty_1__bindgen_ty_1 {
    pub partial_magic: gsize,
    pub type_: *const GVariantType,
    pub y: [gsize; 14usize],
}
#[test]
fn bindgen_test_layout__GVariantBuilder__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_GVariantBuilder__bindgen_ty_1__bindgen_ty_1>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(_GVariantBuilder__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_GVariantBuilder__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_GVariantBuilder__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_GVariantBuilder__bindgen_ty_1__bindgen_ty_1>())).partial_magic
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantBuilder__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(partial_magic)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_GVariantBuilder__bindgen_ty_1__bindgen_ty_1>())).type_
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantBuilder__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_GVariantBuilder__bindgen_ty_1__bindgen_ty_1>())).y as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantBuilder__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(y)
        )
    );
}
#[test]
fn bindgen_test_layout__GVariantBuilder__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_GVariantBuilder__bindgen_ty_1>(),
        128usize,
        concat!("Size of: ", stringify!(_GVariantBuilder__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_GVariantBuilder__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVariantBuilder__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_GVariantBuilder__bindgen_ty_1>())).s as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantBuilder__bindgen_ty_1),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_GVariantBuilder__bindgen_ty_1>())).x as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantBuilder__bindgen_ty_1),
            "::",
            stringify!(x)
        )
    );
}
#[test]
fn bindgen_test_layout__GVariantBuilder() {
    assert_eq!(
        ::core::mem::size_of::<_GVariantBuilder>(),
        128usize,
        concat!("Size of: ", stringify!(_GVariantBuilder))
    );
    assert_eq!(
        ::core::mem::align_of::<_GVariantBuilder>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVariantBuilder))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GVariantBuilder>())).u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantBuilder),
            "::",
            stringify!(u)
        )
    );
}
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_FAILED: GVariantParseError = 0;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_BASIC_TYPE_EXPECTED: GVariantParseError = 1;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_CANNOT_INFER_TYPE: GVariantParseError = 2;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_DEFINITE_TYPE_EXPECTED: GVariantParseError = 3;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INPUT_NOT_AT_END: GVariantParseError = 4;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_CHARACTER: GVariantParseError = 5;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_FORMAT_STRING: GVariantParseError = 6;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_OBJECT_PATH: GVariantParseError = 7;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_SIGNATURE: GVariantParseError = 8;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_TYPE_STRING: GVariantParseError = 9;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_NO_COMMON_TYPE: GVariantParseError = 10;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_NUMBER_OUT_OF_RANGE: GVariantParseError = 11;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_NUMBER_TOO_BIG: GVariantParseError = 12;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_TYPE_ERROR: GVariantParseError = 13;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_UNEXPECTED_TOKEN: GVariantParseError = 14;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_UNKNOWN_KEYWORD: GVariantParseError = 15;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_UNTERMINATED_STRING_CONSTANT:
    GVariantParseError = 16;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_VALUE_EXPECTED: GVariantParseError = 17;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_RECURSION: GVariantParseError = 18;
pub type GVariantParseError = u32;
extern "C" {
    pub fn g_variant_parser_get_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_variant_parse_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_variant_builder_new(type_: *const GVariantType) -> *mut GVariantBuilder;
}
extern "C" {
    pub fn g_variant_builder_unref(builder: *mut GVariantBuilder);
}
extern "C" {
    pub fn g_variant_builder_ref(builder: *mut GVariantBuilder) -> *mut GVariantBuilder;
}
extern "C" {
    pub fn g_variant_builder_init(builder: *mut GVariantBuilder, type_: *const GVariantType);
}
extern "C" {
    pub fn g_variant_builder_end(builder: *mut GVariantBuilder) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_builder_clear(builder: *mut GVariantBuilder);
}
extern "C" {
    pub fn g_variant_builder_open(builder: *mut GVariantBuilder, type_: *const GVariantType);
}
extern "C" {
    pub fn g_variant_builder_close(builder: *mut GVariantBuilder);
}
extern "C" {
    pub fn g_variant_builder_add_value(builder: *mut GVariantBuilder, value: *mut GVariant);
}
extern "C" {
    pub fn g_variant_builder_add(builder: *mut GVariantBuilder, format_string: *const gchar, ...);
}
extern "C" {
    pub fn g_variant_builder_add_parsed(builder: *mut GVariantBuilder, format: *const gchar, ...);
}
extern "C" {
    pub fn g_variant_new(format_string: *const gchar, ...) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_get(value: *mut GVariant, format_string: *const gchar, ...);
}
extern "C" {
    pub fn g_variant_new_va(
        format_string: *const gchar,
        endptr: *mut *const gchar,
        app: *mut va_list,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_get_va(
        value: *mut GVariant,
        format_string: *const gchar,
        endptr: *mut *const gchar,
        app: *mut va_list,
    );
}
extern "C" {
    pub fn g_variant_check_format_string(
        value: *mut GVariant,
        format_string: *const gchar,
        copy_only: gboolean,
    ) -> gboolean;
}
extern "C" {
    pub fn g_variant_parse(
        type_: *const GVariantType,
        text: *const gchar,
        limit: *const gchar,
        endptr: *mut *const gchar,
        error: *mut *mut GError,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_parsed(format: *const gchar, ...) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_new_parsed_va(format: *const gchar, app: *mut va_list) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_parse_error_print_context(
        error: *mut GError,
        source_str: *const gchar,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_variant_compare(one: gconstpointer, two: gconstpointer) -> gint;
}
pub type GVariantDict = _GVariantDict;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GVariantDict {
    pub u: _GVariantDict__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GVariantDict__bindgen_ty_1 {
    pub s: _GVariantDict__bindgen_ty_1__bindgen_ty_1,
    pub x: [gsize; 16usize],
    _bindgen_union_align: [u64; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariantDict__bindgen_ty_1__bindgen_ty_1 {
    pub asv: *mut GVariant,
    pub partial_magic: gsize,
    pub y: [gsize; 14usize],
}
#[test]
fn bindgen_test_layout__GVariantDict__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_GVariantDict__bindgen_ty_1__bindgen_ty_1>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(_GVariantDict__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_GVariantDict__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_GVariantDict__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_GVariantDict__bindgen_ty_1__bindgen_ty_1>())).asv as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantDict__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(asv)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_GVariantDict__bindgen_ty_1__bindgen_ty_1>())).partial_magic
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantDict__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(partial_magic)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_GVariantDict__bindgen_ty_1__bindgen_ty_1>())).y as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantDict__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(y)
        )
    );
}
#[test]
fn bindgen_test_layout__GVariantDict__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_GVariantDict__bindgen_ty_1>(),
        128usize,
        concat!("Size of: ", stringify!(_GVariantDict__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_GVariantDict__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVariantDict__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GVariantDict__bindgen_ty_1>())).s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantDict__bindgen_ty_1),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GVariantDict__bindgen_ty_1>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantDict__bindgen_ty_1),
            "::",
            stringify!(x)
        )
    );
}
#[test]
fn bindgen_test_layout__GVariantDict() {
    assert_eq!(
        ::core::mem::size_of::<_GVariantDict>(),
        128usize,
        concat!("Size of: ", stringify!(_GVariantDict))
    );
    assert_eq!(
        ::core::mem::align_of::<_GVariantDict>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVariantDict))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GVariantDict>())).u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantDict),
            "::",
            stringify!(u)
        )
    );
}
extern "C" {
    pub fn g_variant_dict_new(from_asv: *mut GVariant) -> *mut GVariantDict;
}
extern "C" {
    pub fn g_variant_dict_init(dict: *mut GVariantDict, from_asv: *mut GVariant);
}
extern "C" {
    pub fn g_variant_dict_lookup(
        dict: *mut GVariantDict,
        key: *const gchar,
        format_string: *const gchar,
        ...
    ) -> gboolean;
}
extern "C" {
    pub fn g_variant_dict_lookup_value(
        dict: *mut GVariantDict,
        key: *const gchar,
        expected_type: *const GVariantType,
    ) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_dict_contains(dict: *mut GVariantDict, key: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_variant_dict_insert(
        dict: *mut GVariantDict,
        key: *const gchar,
        format_string: *const gchar,
        ...
    );
}
extern "C" {
    pub fn g_variant_dict_insert_value(
        dict: *mut GVariantDict,
        key: *const gchar,
        value: *mut GVariant,
    );
}
extern "C" {
    pub fn g_variant_dict_remove(dict: *mut GVariantDict, key: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_variant_dict_clear(dict: *mut GVariantDict);
}
extern "C" {
    pub fn g_variant_dict_end(dict: *mut GVariantDict) -> *mut GVariant;
}
extern "C" {
    pub fn g_variant_dict_ref(dict: *mut GVariantDict) -> *mut GVariantDict;
}
extern "C" {
    pub fn g_variant_dict_unref(dict: *mut GVariantDict);
}
extern "C" {
    pub fn g_printf_string_upper_bound(format: *const gchar, args: *mut __va_list_tag) -> gsize;
}
pub const GLogLevelFlags_G_LOG_FLAG_RECURSION: GLogLevelFlags = 1;
pub const GLogLevelFlags_G_LOG_FLAG_FATAL: GLogLevelFlags = 2;
pub const GLogLevelFlags_G_LOG_LEVEL_ERROR: GLogLevelFlags = 4;
pub const GLogLevelFlags_G_LOG_LEVEL_CRITICAL: GLogLevelFlags = 8;
pub const GLogLevelFlags_G_LOG_LEVEL_WARNING: GLogLevelFlags = 16;
pub const GLogLevelFlags_G_LOG_LEVEL_MESSAGE: GLogLevelFlags = 32;
pub const GLogLevelFlags_G_LOG_LEVEL_INFO: GLogLevelFlags = 64;
pub const GLogLevelFlags_G_LOG_LEVEL_DEBUG: GLogLevelFlags = 128;
pub const GLogLevelFlags_G_LOG_LEVEL_MASK: GLogLevelFlags = -4;
pub type GLogLevelFlags = i32;
pub type GLogFunc = ::core::option::Option<
    unsafe extern "C" fn(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        message: *const gchar,
        user_data: gpointer,
    ),
>;
extern "C" {
    pub fn g_log_set_handler(
        log_domain: *const gchar,
        log_levels: GLogLevelFlags,
        log_func: GLogFunc,
        user_data: gpointer,
    ) -> guint;
}
extern "C" {
    pub fn g_log_set_handler_full(
        log_domain: *const gchar,
        log_levels: GLogLevelFlags,
        log_func: GLogFunc,
        user_data: gpointer,
        destroy: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    pub fn g_log_remove_handler(log_domain: *const gchar, handler_id: guint);
}
extern "C" {
    pub fn g_log_default_handler(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        message: *const gchar,
        unused_data: gpointer,
    );
}
extern "C" {
    pub fn g_log_set_default_handler(log_func: GLogFunc, user_data: gpointer) -> GLogFunc;
}
extern "C" {
    pub fn g_log(log_domain: *const gchar, log_level: GLogLevelFlags, format: *const gchar, ...);
}
extern "C" {
    pub fn g_logv(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        format: *const gchar,
        args: *mut __va_list_tag,
    );
}
extern "C" {
    pub fn g_log_set_fatal_mask(
        log_domain: *const gchar,
        fatal_mask: GLogLevelFlags,
    ) -> GLogLevelFlags;
}
extern "C" {
    pub fn g_log_set_always_fatal(fatal_mask: GLogLevelFlags) -> GLogLevelFlags;
}
pub const GLogWriterOutput_G_LOG_WRITER_HANDLED: GLogWriterOutput = 1;
pub const GLogWriterOutput_G_LOG_WRITER_UNHANDLED: GLogWriterOutput = 0;
#[doc = " GLogWriterOutput:"]
#[doc = " @G_LOG_WRITER_HANDLED: Log writer has handled the log entry."]
#[doc = " @G_LOG_WRITER_UNHANDLED: Log writer could not handle the log entry."]
#[doc = ""]
#[doc = " Return values from #GLogWriterFuncs to indicate whether the given log entry"]
#[doc = " was successfully handled by the writer, or whether there was an error in"]
#[doc = " handling it (and hence a fallback writer should be used)."]
#[doc = ""]
#[doc = " If a #GLogWriterFunc ignores a log entry, it should return"]
#[doc = " %G_LOG_WRITER_HANDLED."]
#[doc = ""]
#[doc = " Since: 2.50"]
pub type GLogWriterOutput = u32;
#[doc = " GLogField:"]
#[doc = " @key: field name (UTF-8 string)"]
#[doc = " @value: field value (arbitrary bytes)"]
#[doc = " @length: length of @value, in bytes, or -1 if it is nul-terminated"]
#[doc = ""]
#[doc = " Structure representing a single field in a structured log entry. See"]
#[doc = " g_log_structured() for details."]
#[doc = ""]
#[doc = " Log fields may contain arbitrary values, including binary with embedded nul"]
#[doc = " bytes. If the field contains a string, the string must be UTF-8 encoded and"]
#[doc = " have a trailing nul byte. Otherwise, @length must be set to a non-negative"]
#[doc = " value."]
#[doc = ""]
#[doc = " Since: 2.50"]
pub type GLogField = _GLogField;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GLogField {
    pub key: *const gchar,
    pub value: gconstpointer,
    pub length: gssize,
}
#[test]
fn bindgen_test_layout__GLogField() {
    assert_eq!(
        ::core::mem::size_of::<_GLogField>(),
        24usize,
        concat!("Size of: ", stringify!(_GLogField))
    );
    assert_eq!(
        ::core::mem::align_of::<_GLogField>(),
        8usize,
        concat!("Alignment of ", stringify!(_GLogField))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GLogField>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GLogField),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GLogField>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GLogField),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GLogField>())).length as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GLogField),
            "::",
            stringify!(length)
        )
    );
}
#[doc = " GLogWriterFunc:"]
#[doc = " @log_level: log level of the message"]
#[doc = " @fields: (array length=n_fields): fields forming the message"]
#[doc = " @n_fields: number of @fields"]
#[doc = " @user_data: user data passed to g_log_set_writer_func()"]
#[doc = ""]
#[doc = " Writer function for log entries. A log entry is a collection of one or more"]
#[doc = " #GLogFields, using the standard [field names from journal"]
#[doc = " specification](https://www.freedesktop.org/software/systemd/man/systemd.journal-fields.html)."]
#[doc = " See g_log_structured() for more information."]
#[doc = ""]
#[doc = " Writer functions must ignore fields which they do not recognise, unless they"]
#[doc = " can write arbitrary binary output, as field values may be arbitrary binary."]
#[doc = ""]
#[doc = " @log_level is guaranteed to be included in @fields as the `PRIORITY` field,"]
#[doc = " but is provided separately for convenience of deciding whether or where to"]
#[doc = " output the log entry."]
#[doc = ""]
#[doc = " Writer functions should return %G_LOG_WRITER_HANDLED if they handled the log"]
#[doc = " message successfully or if they deliberately ignored it. If there was an"]
#[doc = " error handling the message (for example, if the writer function is meant to"]
#[doc = " send messages to a remote logging server and there is a network error), it"]
#[doc = " should return %G_LOG_WRITER_UNHANDLED. This allows writer functions to be"]
#[doc = " chained and fall back to simpler handlers in case of failure."]
#[doc = ""]
#[doc = " Returns: %G_LOG_WRITER_HANDLED if the log entry was handled successfully;"]
#[doc = "    %G_LOG_WRITER_UNHANDLED otherwise"]
#[doc = " Since: 2.50"]
pub type GLogWriterFunc = ::core::option::Option<
    unsafe extern "C" fn(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        user_data: gpointer,
    ) -> GLogWriterOutput,
>;
extern "C" {
    pub fn g_log_structured(log_domain: *const gchar, log_level: GLogLevelFlags, ...);
}
extern "C" {
    pub fn g_log_structured_array(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
    );
}
extern "C" {
    pub fn g_log_variant(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        fields: *mut GVariant,
    );
}
extern "C" {
    pub fn g_log_set_writer_func(
        func: GLogWriterFunc,
        user_data: gpointer,
        user_data_free: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_log_writer_supports_color(output_fd: gint) -> gboolean;
}
extern "C" {
    pub fn g_log_writer_is_journald(output_fd: gint) -> gboolean;
}
extern "C" {
    pub fn g_log_writer_format_fields(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        use_color: gboolean,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_log_writer_journald(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        user_data: gpointer,
    ) -> GLogWriterOutput;
}
extern "C" {
    pub fn g_log_writer_standard_streams(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        user_data: gpointer,
    ) -> GLogWriterOutput;
}
extern "C" {
    pub fn g_log_writer_default(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        user_data: gpointer,
    ) -> GLogWriterOutput;
}
extern "C" {
    pub fn _g_log_fallback_handler(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        message: *const gchar,
        unused_data: gpointer,
    );
}
extern "C" {
    pub fn g_return_if_fail_warning(
        log_domain: *const cty::c_char,
        pretty_function: *const cty::c_char,
        expression: *const cty::c_char,
    );
}
extern "C" {
    pub fn g_warn_message(
        domain: *const cty::c_char,
        file: *const cty::c_char,
        line: cty::c_int,
        func: *const cty::c_char,
        warnexpr: *const cty::c_char,
    );
}
extern "C" {
    pub fn g_assert_warning(
        log_domain: *const cty::c_char,
        file: *const cty::c_char,
        line: cty::c_int,
        pretty_function: *const cty::c_char,
        expression: *const cty::c_char,
    );
}
extern "C" {
    pub fn g_log_structured_standard(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        file: *const gchar,
        line: *const gchar,
        func: *const gchar,
        message_format: *const gchar,
        ...
    );
}
#[doc = " GPrintFunc:"]
#[doc = " @string: the message to output"]
#[doc = ""]
#[doc = " Specifies the type of the print handler functions."]
#[doc = " These are called with the complete formatted string to output."]
pub type GPrintFunc = ::core::option::Option<unsafe extern "C" fn(string: *const gchar)>;
extern "C" {
    pub fn g_print(format: *const gchar, ...);
}
extern "C" {
    pub fn g_set_print_handler(func: GPrintFunc) -> GPrintFunc;
}
extern "C" {
    pub fn g_printerr(format: *const gchar, ...);
}
extern "C" {
    pub fn g_set_printerr_handler(func: GPrintFunc) -> GPrintFunc;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOptionContext {
    _unused: [u8; 0],
}
#[doc = " GOptionContext:"]
#[doc = ""]
#[doc = " A `GOptionContext` struct defines which options"]
#[doc = " are accepted by the commandline option parser. The struct has only private"]
#[doc = " fields and should not be directly accessed."]
pub type GOptionContext = _GOptionContext;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOptionGroup {
    _unused: [u8; 0],
}
#[doc = " GOptionGroup:"]
#[doc = ""]
#[doc = " A `GOptionGroup` struct defines the options in a single"]
#[doc = " group. The struct has only private fields and should not be directly accessed."]
#[doc = ""]
#[doc = " All options in a group share the same translation function. Libraries which"]
#[doc = " need to parse commandline options are expected to provide a function for"]
#[doc = " getting a `GOptionGroup` holding their options, which"]
#[doc = " the application can then add to its #GOptionContext."]
pub type GOptionGroup = _GOptionGroup;
pub type GOptionEntry = _GOptionEntry;
pub const GOptionFlags_G_OPTION_FLAG_NONE: GOptionFlags = 0;
pub const GOptionFlags_G_OPTION_FLAG_HIDDEN: GOptionFlags = 1;
pub const GOptionFlags_G_OPTION_FLAG_IN_MAIN: GOptionFlags = 2;
pub const GOptionFlags_G_OPTION_FLAG_REVERSE: GOptionFlags = 4;
pub const GOptionFlags_G_OPTION_FLAG_NO_ARG: GOptionFlags = 8;
pub const GOptionFlags_G_OPTION_FLAG_FILENAME: GOptionFlags = 16;
pub const GOptionFlags_G_OPTION_FLAG_OPTIONAL_ARG: GOptionFlags = 32;
pub const GOptionFlags_G_OPTION_FLAG_NOALIAS: GOptionFlags = 64;
#[doc = " GOptionFlags:"]
#[doc = " @G_OPTION_FLAG_NONE: No flags. Since: 2.42."]
#[doc = " @G_OPTION_FLAG_HIDDEN: The option doesn't appear in `--help` output."]
#[doc = " @G_OPTION_FLAG_IN_MAIN: The option appears in the main section of the"]
#[doc = "     `--help` output, even if it is defined in a group."]
#[doc = " @G_OPTION_FLAG_REVERSE: For options of the %G_OPTION_ARG_NONE kind, this"]
#[doc = "     flag indicates that the sense of the option is reversed."]
#[doc = " @G_OPTION_FLAG_NO_ARG: For options of the %G_OPTION_ARG_CALLBACK kind,"]
#[doc = "     this flag indicates that the callback does not take any argument"]
#[doc = "     (like a %G_OPTION_ARG_NONE option). Since 2.8"]
#[doc = " @G_OPTION_FLAG_FILENAME: For options of the %G_OPTION_ARG_CALLBACK"]
#[doc = "     kind, this flag indicates that the argument should be passed to the"]
#[doc = "     callback in the GLib filename encoding rather than UTF-8. Since 2.8"]
#[doc = " @G_OPTION_FLAG_OPTIONAL_ARG: For options of the %G_OPTION_ARG_CALLBACK"]
#[doc = "     kind, this flag indicates that the argument supply is optional."]
#[doc = "     If no argument is given then data of %GOptionParseFunc will be"]
#[doc = "     set to NULL. Since 2.8"]
#[doc = " @G_OPTION_FLAG_NOALIAS: This flag turns off the automatic conflict"]
#[doc = "     resolution which prefixes long option names with `groupname-` if"]
#[doc = "     there is a conflict. This option should only be used in situations"]
#[doc = "     where aliasing is necessary to model some legacy commandline interface."]
#[doc = "     It is not safe to use this option, unless all option groups are under"]
#[doc = "     your direct control. Since 2.8."]
#[doc = ""]
#[doc = " Flags which modify individual options."]
pub type GOptionFlags = u32;
pub const GOptionArg_G_OPTION_ARG_NONE: GOptionArg = 0;
pub const GOptionArg_G_OPTION_ARG_STRING: GOptionArg = 1;
pub const GOptionArg_G_OPTION_ARG_INT: GOptionArg = 2;
pub const GOptionArg_G_OPTION_ARG_CALLBACK: GOptionArg = 3;
pub const GOptionArg_G_OPTION_ARG_FILENAME: GOptionArg = 4;
pub const GOptionArg_G_OPTION_ARG_STRING_ARRAY: GOptionArg = 5;
pub const GOptionArg_G_OPTION_ARG_FILENAME_ARRAY: GOptionArg = 6;
pub const GOptionArg_G_OPTION_ARG_DOUBLE: GOptionArg = 7;
pub const GOptionArg_G_OPTION_ARG_INT64: GOptionArg = 8;
#[doc = " GOptionArg:"]
#[doc = " @G_OPTION_ARG_NONE: No extra argument. This is useful for simple flags."]
#[doc = " @G_OPTION_ARG_STRING: The option takes a UTF-8 string argument."]
#[doc = " @G_OPTION_ARG_INT: The option takes an integer argument."]
#[doc = " @G_OPTION_ARG_CALLBACK: The option provides a callback (of type"]
#[doc = "     #GOptionArgFunc) to parse the extra argument."]
#[doc = " @G_OPTION_ARG_FILENAME: The option takes a filename as argument, which will"]
#[doc = "be in the GLib filename encoding rather than UTF-8."]
#[doc = " @G_OPTION_ARG_STRING_ARRAY: The option takes a string argument, multiple"]
#[doc = "     uses of the option are collected into an array of strings."]
#[doc = " @G_OPTION_ARG_FILENAME_ARRAY: The option takes a filename as argument,"]
#[doc = "     multiple uses of the option are collected into an array of strings."]
#[doc = " @G_OPTION_ARG_DOUBLE: The option takes a double argument. The argument"]
#[doc = "     can be formatted either for the user's locale or for the \"C\" locale."]
#[doc = "     Since 2.12"]
#[doc = " @G_OPTION_ARG_INT64: The option takes a 64-bit integer. Like"]
#[doc = "     %G_OPTION_ARG_INT but for larger numbers. The number can be in"]
#[doc = "     decimal base, or in hexadecimal (when prefixed with `0x`, for"]
#[doc = "     example, `0xffffffff`). Since 2.12"]
#[doc = ""]
#[doc = " The #GOptionArg enum values determine which type of extra argument the"]
#[doc = " options expect to find. If an option expects an extra argument, it can"]
#[doc = " be specified in several ways; with a short option: `-x arg`, with a long"]
#[doc = " option: `--name arg` or combined in a single argument: `--name=arg`."]
pub type GOptionArg = u32;
#[doc = " GOptionArgFunc:"]
#[doc = " @option_name: The name of the option being parsed. This will be either a"]
#[doc = "  single dash followed by a single letter (for a short name) or two dashes"]
#[doc = "  followed by a long option name."]
#[doc = " @value: The value to be parsed."]
#[doc = " @data: User data added to the #GOptionGroup containing the option when it"]
#[doc = "  was created with g_option_group_new()"]
#[doc = " @error: A return location for errors. The error code %G_OPTION_ERROR_FAILED"]
#[doc = "  is intended to be used for errors in #GOptionArgFunc callbacks."]
#[doc = ""]
#[doc = " The type of function to be passed as callback for %G_OPTION_ARG_CALLBACK"]
#[doc = " options."]
#[doc = ""]
#[doc = " Returns: %TRUE if the option was successfully parsed, %FALSE if an error"]
#[doc = "  occurred, in which case @error should be set with g_set_error()"]
pub type GOptionArgFunc = ::core::option::Option<
    unsafe extern "C" fn(
        option_name: *const gchar,
        value: *const gchar,
        data: gpointer,
        error: *mut *mut GError,
    ) -> gboolean,
>;
#[doc = " GOptionParseFunc:"]
#[doc = " @context: The active #GOptionContext"]
#[doc = " @group: The group to which the function belongs"]
#[doc = " @data: User data added to the #GOptionGroup containing the option when it"]
#[doc = "  was created with g_option_group_new()"]
#[doc = " @error: A return location for error details"]
#[doc = ""]
#[doc = " The type of function that can be called before and after parsing."]
#[doc = ""]
#[doc = " Returns: %TRUE if the function completed successfully, %FALSE if an error"]
#[doc = "  occurred, in which case @error should be set with g_set_error()"]
pub type GOptionParseFunc = ::core::option::Option<
    unsafe extern "C" fn(
        context: *mut GOptionContext,
        group: *mut GOptionGroup,
        data: gpointer,
        error: *mut *mut GError,
    ) -> gboolean,
>;
#[doc = " GOptionErrorFunc:"]
#[doc = " @context: The active #GOptionContext"]
#[doc = " @group: The group to which the function belongs"]
#[doc = " @data: User data added to the #GOptionGroup containing the option when it"]
#[doc = "  was created with g_option_group_new()"]
#[doc = " @error: The #GError containing details about the parse error"]
#[doc = ""]
#[doc = " The type of function to be used as callback when a parse error occurs."]
pub type GOptionErrorFunc = ::core::option::Option<
    unsafe extern "C" fn(
        context: *mut GOptionContext,
        group: *mut GOptionGroup,
        data: gpointer,
        error: *mut *mut GError,
    ),
>;
pub const GOptionError_G_OPTION_ERROR_UNKNOWN_OPTION: GOptionError = 0;
pub const GOptionError_G_OPTION_ERROR_BAD_VALUE: GOptionError = 1;
pub const GOptionError_G_OPTION_ERROR_FAILED: GOptionError = 2;
#[doc = " GOptionError:"]
#[doc = " @G_OPTION_ERROR_UNKNOWN_OPTION: An option was not known to the parser."]
#[doc = "  This error will only be reported, if the parser hasn't been instructed"]
#[doc = "  to ignore unknown options, see g_option_context_set_ignore_unknown_options()."]
#[doc = " @G_OPTION_ERROR_BAD_VALUE: A value couldn't be parsed."]
#[doc = " @G_OPTION_ERROR_FAILED: A #GOptionArgFunc callback failed."]
#[doc = ""]
#[doc = " Error codes returned by option parsing."]
pub type GOptionError = u32;
extern "C" {
    pub fn g_option_error_quark() -> GQuark;
}
#[doc = " GOptionEntry:"]
#[doc = " @long_name: The long name of an option can be used to specify it"]
#[doc = "     in a commandline as `--long_name`. Every option must have a"]
#[doc = "     long name. To resolve conflicts if multiple option groups contain"]
#[doc = "     the same long name, it is also possible to specify the option as"]
#[doc = "     `--groupname-long_name`."]
#[doc = " @short_name: If an option has a short name, it can be specified"]
#[doc = "     `-short_name` in a commandline. @short_name must be  a printable"]
#[doc = "     ASCII character different from '-', or zero if the option has no"]
#[doc = "     short name."]
#[doc = " @flags: Flags from #GOptionFlags"]
#[doc = " @arg: The type of the option, as a #GOptionArg"]
#[doc = " @arg_data: If the @arg type is %G_OPTION_ARG_CALLBACK, then @arg_data"]
#[doc = "     must point to a #GOptionArgFunc callback function, which will be"]
#[doc = "     called to handle the extra argument. Otherwise, @arg_data is a"]
#[doc = "     pointer to a location to store the value, the required type of"]
#[doc = "     the location depends on the @arg type:"]
#[doc = "     - %G_OPTION_ARG_NONE: %gboolean"]
#[doc = "     - %G_OPTION_ARG_STRING: %gchar*"]
#[doc = "     - %G_OPTION_ARG_INT: %gint"]
#[doc = "     - %G_OPTION_ARG_FILENAME: %gchar*"]
#[doc = "     - %G_OPTION_ARG_STRING_ARRAY: %gchar**"]
#[doc = "     - %G_OPTION_ARG_FILENAME_ARRAY: %gchar**"]
#[doc = "     - %G_OPTION_ARG_DOUBLE: %gdouble"]
#[doc = "     If @arg type is %G_OPTION_ARG_STRING or %G_OPTION_ARG_FILENAME,"]
#[doc = "     the location will contain a newly allocated string if the option"]
#[doc = "     was given. That string needs to be freed by the callee using g_free()."]
#[doc = "     Likewise if @arg type is %G_OPTION_ARG_STRING_ARRAY or"]
#[doc = "     %G_OPTION_ARG_FILENAME_ARRAY, the data should be freed using g_strfreev()."]
#[doc = " @description: the description for the option in `--help`"]
#[doc = "     output. The @description is translated using the @translate_func"]
#[doc = "     of the group, see g_option_group_set_translation_domain()."]
#[doc = " @arg_description: The placeholder to use for the extra argument parsed"]
#[doc = "     by the option in `--help` output. The @arg_description is translated"]
#[doc = "     using the @translate_func of the group, see"]
#[doc = "     g_option_group_set_translation_domain()."]
#[doc = ""]
#[doc = " A GOptionEntry struct defines a single option. To have an effect, they"]
#[doc = " must be added to a #GOptionGroup with g_option_context_add_main_entries()"]
#[doc = " or g_option_group_add_entries()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOptionEntry {
    pub long_name: *const gchar,
    pub short_name: gchar,
    pub flags: gint,
    pub arg: GOptionArg,
    pub arg_data: gpointer,
    pub description: *const gchar,
    pub arg_description: *const gchar,
}
#[test]
fn bindgen_test_layout__GOptionEntry() {
    assert_eq!(
        ::core::mem::size_of::<_GOptionEntry>(),
        48usize,
        concat!("Size of: ", stringify!(_GOptionEntry))
    );
    assert_eq!(
        ::core::mem::align_of::<_GOptionEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(_GOptionEntry))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GOptionEntry>())).long_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOptionEntry),
            "::",
            stringify!(long_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GOptionEntry>())).short_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOptionEntry),
            "::",
            stringify!(short_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GOptionEntry>())).flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOptionEntry),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GOptionEntry>())).arg as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOptionEntry),
            "::",
            stringify!(arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GOptionEntry>())).arg_data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOptionEntry),
            "::",
            stringify!(arg_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GOptionEntry>())).description as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOptionEntry),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GOptionEntry>())).arg_description as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOptionEntry),
            "::",
            stringify!(arg_description)
        )
    );
}
extern "C" {
    pub fn g_option_context_new(parameter_string: *const gchar) -> *mut GOptionContext;
}
extern "C" {
    pub fn g_option_context_set_summary(context: *mut GOptionContext, summary: *const gchar);
}
extern "C" {
    pub fn g_option_context_get_summary(context: *mut GOptionContext) -> *const gchar;
}
extern "C" {
    pub fn g_option_context_set_description(
        context: *mut GOptionContext,
        description: *const gchar,
    );
}
extern "C" {
    pub fn g_option_context_get_description(context: *mut GOptionContext) -> *const gchar;
}
extern "C" {
    pub fn g_option_context_free(context: *mut GOptionContext);
}
extern "C" {
    pub fn g_option_context_set_help_enabled(context: *mut GOptionContext, help_enabled: gboolean);
}
extern "C" {
    pub fn g_option_context_get_help_enabled(context: *mut GOptionContext) -> gboolean;
}
extern "C" {
    pub fn g_option_context_set_ignore_unknown_options(
        context: *mut GOptionContext,
        ignore_unknown: gboolean,
    );
}
extern "C" {
    pub fn g_option_context_get_ignore_unknown_options(context: *mut GOptionContext) -> gboolean;
}
extern "C" {
    pub fn g_option_context_set_strict_posix(context: *mut GOptionContext, strict_posix: gboolean);
}
extern "C" {
    pub fn g_option_context_get_strict_posix(context: *mut GOptionContext) -> gboolean;
}
extern "C" {
    pub fn g_option_context_add_main_entries(
        context: *mut GOptionContext,
        entries: *const GOptionEntry,
        translation_domain: *const gchar,
    );
}
extern "C" {
    pub fn g_option_context_parse(
        context: *mut GOptionContext,
        argc: *mut gint,
        argv: *mut *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_option_context_parse_strv(
        context: *mut GOptionContext,
        arguments: *mut *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_option_context_set_translate_func(
        context: *mut GOptionContext,
        func: GTranslateFunc,
        data: gpointer,
        destroy_notify: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_option_context_set_translation_domain(
        context: *mut GOptionContext,
        domain: *const gchar,
    );
}
extern "C" {
    pub fn g_option_context_add_group(context: *mut GOptionContext, group: *mut GOptionGroup);
}
extern "C" {
    pub fn g_option_context_set_main_group(context: *mut GOptionContext, group: *mut GOptionGroup);
}
extern "C" {
    pub fn g_option_context_get_main_group(context: *mut GOptionContext) -> *mut GOptionGroup;
}
extern "C" {
    pub fn g_option_context_get_help(
        context: *mut GOptionContext,
        main_help: gboolean,
        group: *mut GOptionGroup,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_option_group_new(
        name: *const gchar,
        description: *const gchar,
        help_description: *const gchar,
        user_data: gpointer,
        destroy: GDestroyNotify,
    ) -> *mut GOptionGroup;
}
extern "C" {
    pub fn g_option_group_set_parse_hooks(
        group: *mut GOptionGroup,
        pre_parse_func: GOptionParseFunc,
        post_parse_func: GOptionParseFunc,
    );
}
extern "C" {
    pub fn g_option_group_set_error_hook(group: *mut GOptionGroup, error_func: GOptionErrorFunc);
}
extern "C" {
    pub fn g_option_group_free(group: *mut GOptionGroup);
}
extern "C" {
    pub fn g_option_group_ref(group: *mut GOptionGroup) -> *mut GOptionGroup;
}
extern "C" {
    pub fn g_option_group_unref(group: *mut GOptionGroup);
}
extern "C" {
    pub fn g_option_group_add_entries(group: *mut GOptionGroup, entries: *const GOptionEntry);
}
extern "C" {
    pub fn g_option_group_set_translate_func(
        group: *mut GOptionGroup,
        func: GTranslateFunc,
        data: gpointer,
        destroy_notify: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_option_group_set_translation_domain(group: *mut GOptionGroup, domain: *const gchar);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPatternSpec {
    _unused: [u8; 0],
}
pub type GPatternSpec = _GPatternSpec;
extern "C" {
    pub fn g_pattern_spec_new(pattern: *const gchar) -> *mut GPatternSpec;
}
extern "C" {
    pub fn g_pattern_spec_free(pspec: *mut GPatternSpec);
}
extern "C" {
    pub fn g_pattern_spec_equal(pspec1: *mut GPatternSpec, pspec2: *mut GPatternSpec) -> gboolean;
}
extern "C" {
    pub fn g_pattern_match(
        pspec: *mut GPatternSpec,
        string_length: guint,
        string: *const gchar,
        string_reversed: *const gchar,
    ) -> gboolean;
}
extern "C" {
    pub fn g_pattern_match_string(pspec: *mut GPatternSpec, string: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_pattern_match_simple(pattern: *const gchar, string: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_spaced_primes_closest(num: guint) -> guint;
}
extern "C" {
    pub fn g_qsort_with_data(
        pbase: gconstpointer,
        total_elems: gint,
        size: gsize,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
}
pub type GQueue = _GQueue;
#[doc = " GQueue:"]
#[doc = " @head: a pointer to the first element of the queue"]
#[doc = " @tail: a pointer to the last element of the queue"]
#[doc = " @length: the number of elements in the queue"]
#[doc = ""]
#[doc = " Contains the public fields of a"]
#[doc = " [Queue][glib-Double-ended-Queues]."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GQueue {
    pub head: *mut GList,
    pub tail: *mut GList,
    pub length: guint,
}
#[test]
fn bindgen_test_layout__GQueue() {
    assert_eq!(
        ::core::mem::size_of::<_GQueue>(),
        24usize,
        concat!("Size of: ", stringify!(_GQueue))
    );
    assert_eq!(
        ::core::mem::align_of::<_GQueue>(),
        8usize,
        concat!("Alignment of ", stringify!(_GQueue))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GQueue>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GQueue),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GQueue>())).tail as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GQueue),
            "::",
            stringify!(tail)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GQueue>())).length as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GQueue),
            "::",
            stringify!(length)
        )
    );
}
extern "C" {
    pub fn g_queue_new() -> *mut GQueue;
}
extern "C" {
    pub fn g_queue_free(queue: *mut GQueue);
}
extern "C" {
    pub fn g_queue_free_full(queue: *mut GQueue, free_func: GDestroyNotify);
}
extern "C" {
    pub fn g_queue_init(queue: *mut GQueue);
}
extern "C" {
    pub fn g_queue_clear(queue: *mut GQueue);
}
extern "C" {
    pub fn g_queue_is_empty(queue: *mut GQueue) -> gboolean;
}
extern "C" {
    pub fn g_queue_clear_full(queue: *mut GQueue, free_func: GDestroyNotify);
}
extern "C" {
    pub fn g_queue_get_length(queue: *mut GQueue) -> guint;
}
extern "C" {
    pub fn g_queue_reverse(queue: *mut GQueue);
}
extern "C" {
    pub fn g_queue_copy(queue: *mut GQueue) -> *mut GQueue;
}
extern "C" {
    pub fn g_queue_foreach(queue: *mut GQueue, func: GFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_queue_find(queue: *mut GQueue, data: gconstpointer) -> *mut GList;
}
extern "C" {
    pub fn g_queue_find_custom(
        queue: *mut GQueue,
        data: gconstpointer,
        func: GCompareFunc,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_queue_sort(queue: *mut GQueue, compare_func: GCompareDataFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_queue_push_head(queue: *mut GQueue, data: gpointer);
}
extern "C" {
    pub fn g_queue_push_tail(queue: *mut GQueue, data: gpointer);
}
extern "C" {
    pub fn g_queue_push_nth(queue: *mut GQueue, data: gpointer, n: gint);
}
extern "C" {
    pub fn g_queue_pop_head(queue: *mut GQueue) -> gpointer;
}
extern "C" {
    pub fn g_queue_pop_tail(queue: *mut GQueue) -> gpointer;
}
extern "C" {
    pub fn g_queue_pop_nth(queue: *mut GQueue, n: guint) -> gpointer;
}
extern "C" {
    pub fn g_queue_peek_head(queue: *mut GQueue) -> gpointer;
}
extern "C" {
    pub fn g_queue_peek_tail(queue: *mut GQueue) -> gpointer;
}
extern "C" {
    pub fn g_queue_peek_nth(queue: *mut GQueue, n: guint) -> gpointer;
}
extern "C" {
    pub fn g_queue_index(queue: *mut GQueue, data: gconstpointer) -> gint;
}
extern "C" {
    pub fn g_queue_remove(queue: *mut GQueue, data: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_queue_remove_all(queue: *mut GQueue, data: gconstpointer) -> guint;
}
extern "C" {
    pub fn g_queue_insert_before(queue: *mut GQueue, sibling: *mut GList, data: gpointer);
}
extern "C" {
    pub fn g_queue_insert_before_link(queue: *mut GQueue, sibling: *mut GList, link_: *mut GList);
}
extern "C" {
    pub fn g_queue_insert_after(queue: *mut GQueue, sibling: *mut GList, data: gpointer);
}
extern "C" {
    pub fn g_queue_insert_after_link(queue: *mut GQueue, sibling: *mut GList, link_: *mut GList);
}
extern "C" {
    pub fn g_queue_insert_sorted(
        queue: *mut GQueue,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_queue_push_head_link(queue: *mut GQueue, link_: *mut GList);
}
extern "C" {
    pub fn g_queue_push_tail_link(queue: *mut GQueue, link_: *mut GList);
}
extern "C" {
    pub fn g_queue_push_nth_link(queue: *mut GQueue, n: gint, link_: *mut GList);
}
extern "C" {
    pub fn g_queue_pop_head_link(queue: *mut GQueue) -> *mut GList;
}
extern "C" {
    pub fn g_queue_pop_tail_link(queue: *mut GQueue) -> *mut GList;
}
extern "C" {
    pub fn g_queue_pop_nth_link(queue: *mut GQueue, n: guint) -> *mut GList;
}
extern "C" {
    pub fn g_queue_peek_head_link(queue: *mut GQueue) -> *mut GList;
}
extern "C" {
    pub fn g_queue_peek_tail_link(queue: *mut GQueue) -> *mut GList;
}
extern "C" {
    pub fn g_queue_peek_nth_link(queue: *mut GQueue, n: guint) -> *mut GList;
}
extern "C" {
    pub fn g_queue_link_index(queue: *mut GQueue, link_: *mut GList) -> gint;
}
extern "C" {
    pub fn g_queue_unlink(queue: *mut GQueue, link_: *mut GList);
}
extern "C" {
    pub fn g_queue_delete_link(queue: *mut GQueue, link_: *mut GList);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRand {
    _unused: [u8; 0],
}
pub type GRand = _GRand;
extern "C" {
    pub fn g_rand_new_with_seed(seed: guint32) -> *mut GRand;
}
extern "C" {
    pub fn g_rand_new_with_seed_array(seed: *const guint32, seed_length: guint) -> *mut GRand;
}
extern "C" {
    pub fn g_rand_new() -> *mut GRand;
}
extern "C" {
    pub fn g_rand_free(rand_: *mut GRand);
}
extern "C" {
    pub fn g_rand_copy(rand_: *mut GRand) -> *mut GRand;
}
extern "C" {
    pub fn g_rand_set_seed(rand_: *mut GRand, seed: guint32);
}
extern "C" {
    pub fn g_rand_set_seed_array(rand_: *mut GRand, seed: *const guint32, seed_length: guint);
}
extern "C" {
    pub fn g_rand_int(rand_: *mut GRand) -> guint32;
}
extern "C" {
    pub fn g_rand_int_range(rand_: *mut GRand, begin: gint32, end: gint32) -> gint32;
}
extern "C" {
    pub fn g_rand_double(rand_: *mut GRand) -> gdouble;
}
extern "C" {
    pub fn g_rand_double_range(rand_: *mut GRand, begin: gdouble, end: gdouble) -> gdouble;
}
extern "C" {
    pub fn g_random_set_seed(seed: guint32);
}
extern "C" {
    pub fn g_random_int() -> guint32;
}
extern "C" {
    pub fn g_random_int_range(begin: gint32, end: gint32) -> gint32;
}
extern "C" {
    pub fn g_random_double() -> gdouble;
}
extern "C" {
    pub fn g_random_double_range(begin: gdouble, end: gdouble) -> gdouble;
}
extern "C" {
    pub fn g_rc_box_alloc(block_size: gsize) -> gpointer;
}
extern "C" {
    pub fn g_rc_box_alloc0(block_size: gsize) -> gpointer;
}
extern "C" {
    pub fn g_rc_box_dup(block_size: gsize, mem_block: gconstpointer) -> gpointer;
}
extern "C" {
    pub fn g_rc_box_acquire(mem_block: gpointer) -> gpointer;
}
extern "C" {
    pub fn g_rc_box_release(mem_block: gpointer);
}
extern "C" {
    pub fn g_rc_box_release_full(mem_block: gpointer, clear_func: GDestroyNotify);
}
extern "C" {
    pub fn g_rc_box_get_size(mem_block: gpointer) -> gsize;
}
extern "C" {
    pub fn g_atomic_rc_box_alloc(block_size: gsize) -> gpointer;
}
extern "C" {
    pub fn g_atomic_rc_box_alloc0(block_size: gsize) -> gpointer;
}
extern "C" {
    pub fn g_atomic_rc_box_dup(block_size: gsize, mem_block: gconstpointer) -> gpointer;
}
extern "C" {
    pub fn g_atomic_rc_box_acquire(mem_block: gpointer) -> gpointer;
}
extern "C" {
    pub fn g_atomic_rc_box_release(mem_block: gpointer);
}
extern "C" {
    pub fn g_atomic_rc_box_release_full(mem_block: gpointer, clear_func: GDestroyNotify);
}
extern "C" {
    pub fn g_atomic_rc_box_get_size(mem_block: gpointer) -> gsize;
}
extern "C" {
    pub fn g_ref_count_init(rc: *mut grefcount);
}
extern "C" {
    pub fn g_ref_count_inc(rc: *mut grefcount);
}
extern "C" {
    pub fn g_ref_count_dec(rc: *mut grefcount) -> gboolean;
}
extern "C" {
    pub fn g_ref_count_compare(rc: *mut grefcount, val: gint) -> gboolean;
}
extern "C" {
    pub fn g_atomic_ref_count_init(arc: *mut gatomicrefcount);
}
extern "C" {
    pub fn g_atomic_ref_count_inc(arc: *mut gatomicrefcount);
}
extern "C" {
    pub fn g_atomic_ref_count_dec(arc: *mut gatomicrefcount) -> gboolean;
}
extern "C" {
    pub fn g_atomic_ref_count_compare(arc: *mut gatomicrefcount, val: gint) -> gboolean;
}
extern "C" {
    pub fn g_ref_string_new(str_: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn g_ref_string_new_len(str_: *const cty::c_char, len: gssize) -> *mut cty::c_char;
}
extern "C" {
    pub fn g_ref_string_new_intern(str_: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn g_ref_string_acquire(str_: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn g_ref_string_release(str_: *mut cty::c_char);
}
extern "C" {
    pub fn g_ref_string_length(str_: *mut cty::c_char) -> gsize;
}
#[doc = " GRefString:"]
#[doc = ""]
#[doc = " A typedef for a reference-counted string. A pointer to a #GRefString can be"]
#[doc = " treated like a standard `char*` array by all code, but can additionally have"]
#[doc = " `g_ref_string_*()` methods called on it. `g_ref_string_*()` methods cannot be"]
#[doc = " called on `char*` arrays not allocated using g_ref_string_new()."]
#[doc = ""]
#[doc = " If using #GRefString with autocleanups, g_autoptr() must be used rather than"]
#[doc = " g_autofree(), so that the reference counting metadata is also freed."]
#[doc = ""]
#[doc = " Since: 2.58"]
pub type GRefString = cty::c_char;
pub const GRegexError_G_REGEX_ERROR_COMPILE: GRegexError = 0;
pub const GRegexError_G_REGEX_ERROR_OPTIMIZE: GRegexError = 1;
pub const GRegexError_G_REGEX_ERROR_REPLACE: GRegexError = 2;
pub const GRegexError_G_REGEX_ERROR_MATCH: GRegexError = 3;
pub const GRegexError_G_REGEX_ERROR_INTERNAL: GRegexError = 4;
pub const GRegexError_G_REGEX_ERROR_STRAY_BACKSLASH: GRegexError = 101;
pub const GRegexError_G_REGEX_ERROR_MISSING_CONTROL_CHAR: GRegexError = 102;
pub const GRegexError_G_REGEX_ERROR_UNRECOGNIZED_ESCAPE: GRegexError = 103;
pub const GRegexError_G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER: GRegexError = 104;
pub const GRegexError_G_REGEX_ERROR_QUANTIFIER_TOO_BIG: GRegexError = 105;
pub const GRegexError_G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS: GRegexError = 106;
pub const GRegexError_G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS: GRegexError = 107;
pub const GRegexError_G_REGEX_ERROR_RANGE_OUT_OF_ORDER: GRegexError = 108;
pub const GRegexError_G_REGEX_ERROR_NOTHING_TO_REPEAT: GRegexError = 109;
pub const GRegexError_G_REGEX_ERROR_UNRECOGNIZED_CHARACTER: GRegexError = 112;
pub const GRegexError_G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS: GRegexError = 113;
pub const GRegexError_G_REGEX_ERROR_UNMATCHED_PARENTHESIS: GRegexError = 114;
pub const GRegexError_G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE: GRegexError = 115;
pub const GRegexError_G_REGEX_ERROR_UNTERMINATED_COMMENT: GRegexError = 118;
pub const GRegexError_G_REGEX_ERROR_EXPRESSION_TOO_LARGE: GRegexError = 120;
pub const GRegexError_G_REGEX_ERROR_MEMORY_ERROR: GRegexError = 121;
pub const GRegexError_G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND: GRegexError = 125;
pub const GRegexError_G_REGEX_ERROR_MALFORMED_CONDITION: GRegexError = 126;
pub const GRegexError_G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES: GRegexError = 127;
pub const GRegexError_G_REGEX_ERROR_ASSERTION_EXPECTED: GRegexError = 128;
pub const GRegexError_G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME: GRegexError = 130;
pub const GRegexError_G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED: GRegexError = 131;
pub const GRegexError_G_REGEX_ERROR_HEX_CODE_TOO_LARGE: GRegexError = 134;
pub const GRegexError_G_REGEX_ERROR_INVALID_CONDITION: GRegexError = 135;
pub const GRegexError_G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND: GRegexError = 136;
pub const GRegexError_G_REGEX_ERROR_INFINITE_LOOP: GRegexError = 140;
pub const GRegexError_G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR: GRegexError = 142;
pub const GRegexError_G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME: GRegexError = 143;
pub const GRegexError_G_REGEX_ERROR_MALFORMED_PROPERTY: GRegexError = 146;
pub const GRegexError_G_REGEX_ERROR_UNKNOWN_PROPERTY: GRegexError = 147;
pub const GRegexError_G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG: GRegexError = 148;
pub const GRegexError_G_REGEX_ERROR_TOO_MANY_SUBPATTERNS: GRegexError = 149;
pub const GRegexError_G_REGEX_ERROR_INVALID_OCTAL_VALUE: GRegexError = 151;
pub const GRegexError_G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE: GRegexError = 154;
pub const GRegexError_G_REGEX_ERROR_DEFINE_REPETION: GRegexError = 155;
pub const GRegexError_G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS: GRegexError = 156;
pub const GRegexError_G_REGEX_ERROR_MISSING_BACK_REFERENCE: GRegexError = 157;
pub const GRegexError_G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE: GRegexError = 158;
pub const GRegexError_G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN: GRegexError = 159;
pub const GRegexError_G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB: GRegexError = 160;
pub const GRegexError_G_REGEX_ERROR_NUMBER_TOO_BIG: GRegexError = 161;
pub const GRegexError_G_REGEX_ERROR_MISSING_SUBPATTERN_NAME: GRegexError = 162;
pub const GRegexError_G_REGEX_ERROR_MISSING_DIGIT: GRegexError = 163;
pub const GRegexError_G_REGEX_ERROR_INVALID_DATA_CHARACTER: GRegexError = 164;
pub const GRegexError_G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME: GRegexError = 165;
pub const GRegexError_G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED: GRegexError = 166;
pub const GRegexError_G_REGEX_ERROR_INVALID_CONTROL_CHAR: GRegexError = 168;
pub const GRegexError_G_REGEX_ERROR_MISSING_NAME: GRegexError = 169;
pub const GRegexError_G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS: GRegexError = 171;
pub const GRegexError_G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES: GRegexError = 172;
pub const GRegexError_G_REGEX_ERROR_NAME_TOO_LONG: GRegexError = 175;
pub const GRegexError_G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE: GRegexError = 176;
#[doc = " GRegexError:"]
#[doc = " @G_REGEX_ERROR_COMPILE: Compilation of the regular expression failed."]
#[doc = " @G_REGEX_ERROR_OPTIMIZE: Optimization of the regular expression failed."]
#[doc = " @G_REGEX_ERROR_REPLACE: Replacement failed due to an ill-formed replacement"]
#[doc = "     string."]
#[doc = " @G_REGEX_ERROR_MATCH: The match process failed."]
#[doc = " @G_REGEX_ERROR_INTERNAL: Internal error of the regular expression engine."]
#[doc = "     Since 2.16"]
#[doc = " @G_REGEX_ERROR_STRAY_BACKSLASH: \"\\\\\" at end of pattern. Since 2.16"]
#[doc = " @G_REGEX_ERROR_MISSING_CONTROL_CHAR: \"\\\\c\" at end of pattern. Since 2.16"]
#[doc = " @G_REGEX_ERROR_UNRECOGNIZED_ESCAPE: Unrecognized character follows \"\\\\\"."]
#[doc = "     Since 2.16"]
#[doc = " @G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER: Numbers out of order in \"{}\""]
#[doc = "     quantifier. Since 2.16"]
#[doc = " @G_REGEX_ERROR_QUANTIFIER_TOO_BIG: Number too big in \"{}\" quantifier."]
#[doc = "     Since 2.16"]
#[doc = " @G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS: Missing terminating \"]\" for"]
#[doc = "     character class. Since 2.16"]
#[doc = " @G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS: Invalid escape sequence"]
#[doc = "     in character class. Since 2.16"]
#[doc = " @G_REGEX_ERROR_RANGE_OUT_OF_ORDER: Range out of order in character class."]
#[doc = "     Since 2.16"]
#[doc = " @G_REGEX_ERROR_NOTHING_TO_REPEAT: Nothing to repeat. Since 2.16"]
#[doc = " @G_REGEX_ERROR_UNRECOGNIZED_CHARACTER: Unrecognized character after \"(?\","]
#[doc = "     \"(?<\" or \"(?P\". Since 2.16"]
#[doc = " @G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS: POSIX named classes are"]
#[doc = "     supported only within a class. Since 2.16"]
#[doc = " @G_REGEX_ERROR_UNMATCHED_PARENTHESIS: Missing terminating \")\" or \")\""]
#[doc = "     without opening \"(\". Since 2.16"]
#[doc = " @G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE: Reference to non-existent"]
#[doc = "     subpattern. Since 2.16"]
#[doc = " @G_REGEX_ERROR_UNTERMINATED_COMMENT: Missing terminating \")\" after comment."]
#[doc = "     Since 2.16"]
#[doc = " @G_REGEX_ERROR_EXPRESSION_TOO_LARGE: Regular expression too large."]
#[doc = "     Since 2.16"]
#[doc = " @G_REGEX_ERROR_MEMORY_ERROR: Failed to get memory. Since 2.16"]
#[doc = " @G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND: Lookbehind assertion is not"]
#[doc = "     fixed length. Since 2.16"]
#[doc = " @G_REGEX_ERROR_MALFORMED_CONDITION: Malformed number or name after \"(?(\"."]
#[doc = "     Since 2.16"]
#[doc = " @G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES: Conditional group contains"]
#[doc = "     more than two branches. Since 2.16"]
#[doc = " @G_REGEX_ERROR_ASSERTION_EXPECTED: Assertion expected after \"(?(\"."]
#[doc = "     Since 2.16"]
#[doc = " @G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME: Unknown POSIX class name."]
#[doc = "     Since 2.16"]
#[doc = " @G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED: POSIX collating"]
#[doc = "     elements are not supported. Since 2.16"]
#[doc = " @G_REGEX_ERROR_HEX_CODE_TOO_LARGE: Character value in \"\\\\x{...}\" sequence"]
#[doc = "     is too large. Since 2.16"]
#[doc = " @G_REGEX_ERROR_INVALID_CONDITION: Invalid condition \"(?(0)\". Since 2.16"]
#[doc = " @G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND: \\\\C not allowed in"]
#[doc = "     lookbehind assertion. Since 2.16"]
#[doc = " @G_REGEX_ERROR_INFINITE_LOOP: Recursive call could loop indefinitely."]
#[doc = "     Since 2.16"]
#[doc = " @G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR: Missing terminator"]
#[doc = "     in subpattern name. Since 2.16"]
#[doc = " @G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME: Two named subpatterns have"]
#[doc = "     the same name. Since 2.16"]
#[doc = " @G_REGEX_ERROR_MALFORMED_PROPERTY: Malformed \"\\\\P\" or \"\\\\p\" sequence."]
#[doc = "     Since 2.16"]
#[doc = " @G_REGEX_ERROR_UNKNOWN_PROPERTY: Unknown property name after \"\\\\P\" or"]
#[doc = "     \"\\\\p\". Since 2.16"]
#[doc = " @G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG: Subpattern name is too long"]
#[doc = "     (maximum 32 characters). Since 2.16"]
#[doc = " @G_REGEX_ERROR_TOO_MANY_SUBPATTERNS: Too many named subpatterns (maximum"]
#[doc = "     10,000). Since 2.16"]
#[doc = " @G_REGEX_ERROR_INVALID_OCTAL_VALUE: Octal value is greater than \"\\\\377\"."]
#[doc = "     Since 2.16"]
#[doc = " @G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE: \"DEFINE\" group contains more"]
#[doc = "     than one branch. Since 2.16"]
#[doc = " @G_REGEX_ERROR_DEFINE_REPETION: Repeating a \"DEFINE\" group is not allowed."]
#[doc = "     This error is never raised. Since: 2.16 Deprecated: 2.34"]
#[doc = " @G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS: Inconsistent newline options."]
#[doc = "     Since 2.16"]
#[doc = " @G_REGEX_ERROR_MISSING_BACK_REFERENCE: \"\\\\g\" is not followed by a braced,"]
#[doc = "      angle-bracketed, or quoted name or number, or by a plain number. Since: 2.16"]
#[doc = " @G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE: relative reference must not be zero. Since: 2.34"]
#[doc = " @G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN: the backtracing"]
#[doc = "     control verb used does not allow an argument. Since: 2.34"]
#[doc = " @G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB: unknown backtracing"]
#[doc = "     control verb. Since: 2.34"]
#[doc = " @G_REGEX_ERROR_NUMBER_TOO_BIG: number is too big in escape sequence. Since: 2.34"]
#[doc = " @G_REGEX_ERROR_MISSING_SUBPATTERN_NAME: Missing subpattern name. Since: 2.34"]
#[doc = " @G_REGEX_ERROR_MISSING_DIGIT: Missing digit. Since 2.34"]
#[doc = " @G_REGEX_ERROR_INVALID_DATA_CHARACTER: In JavaScript compatibility mode,"]
#[doc = "     \"[\" is an invalid data character. Since: 2.34"]
#[doc = " @G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME: different names for subpatterns of the"]
#[doc = "     same number are not allowed. Since: 2.34"]
#[doc = " @G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED: the backtracing control"]
#[doc = "     verb requires an argument. Since: 2.34"]
#[doc = " @G_REGEX_ERROR_INVALID_CONTROL_CHAR: \"\\\\c\" must be followed by an ASCII"]
#[doc = "     character. Since: 2.34"]
#[doc = " @G_REGEX_ERROR_MISSING_NAME: \"\\\\k\" is not followed by a braced, angle-bracketed, or"]
#[doc = "     quoted name. Since: 2.34"]
#[doc = " @G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS: \"\\\\N\" is not supported in a class. Since: 2.34"]
#[doc = " @G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES: too many forward references. Since: 2.34"]
#[doc = " @G_REGEX_ERROR_NAME_TOO_LONG: the name is too long in \"(*MARK)\", \"(*PRUNE)\","]
#[doc = "     \"(*SKIP)\", or \"(*THEN)\". Since: 2.34"]
#[doc = " @G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE: the character value in the \\\\u sequence is"]
#[doc = "     too large. Since: 2.34"]
#[doc = ""]
#[doc = " Error codes returned by regular expressions functions."]
#[doc = ""]
#[doc = " Since: 2.14"]
pub type GRegexError = u32;
extern "C" {
    pub fn g_regex_error_quark() -> GQuark;
}
pub const GRegexCompileFlags_G_REGEX_CASELESS: GRegexCompileFlags = 1;
pub const GRegexCompileFlags_G_REGEX_MULTILINE: GRegexCompileFlags = 2;
pub const GRegexCompileFlags_G_REGEX_DOTALL: GRegexCompileFlags = 4;
pub const GRegexCompileFlags_G_REGEX_EXTENDED: GRegexCompileFlags = 8;
pub const GRegexCompileFlags_G_REGEX_ANCHORED: GRegexCompileFlags = 16;
pub const GRegexCompileFlags_G_REGEX_DOLLAR_ENDONLY: GRegexCompileFlags = 32;
pub const GRegexCompileFlags_G_REGEX_UNGREEDY: GRegexCompileFlags = 512;
pub const GRegexCompileFlags_G_REGEX_RAW: GRegexCompileFlags = 2048;
pub const GRegexCompileFlags_G_REGEX_NO_AUTO_CAPTURE: GRegexCompileFlags = 4096;
pub const GRegexCompileFlags_G_REGEX_OPTIMIZE: GRegexCompileFlags = 8192;
pub const GRegexCompileFlags_G_REGEX_FIRSTLINE: GRegexCompileFlags = 262144;
pub const GRegexCompileFlags_G_REGEX_DUPNAMES: GRegexCompileFlags = 524288;
pub const GRegexCompileFlags_G_REGEX_NEWLINE_CR: GRegexCompileFlags = 1048576;
pub const GRegexCompileFlags_G_REGEX_NEWLINE_LF: GRegexCompileFlags = 2097152;
pub const GRegexCompileFlags_G_REGEX_NEWLINE_CRLF: GRegexCompileFlags = 3145728;
pub const GRegexCompileFlags_G_REGEX_NEWLINE_ANYCRLF: GRegexCompileFlags = 5242880;
pub const GRegexCompileFlags_G_REGEX_BSR_ANYCRLF: GRegexCompileFlags = 8388608;
pub const GRegexCompileFlags_G_REGEX_JAVASCRIPT_COMPAT: GRegexCompileFlags = 33554432;
#[doc = " GRegexCompileFlags:"]
#[doc = " @G_REGEX_CASELESS: Letters in the pattern match both upper- and"]
#[doc = "     lowercase letters. This option can be changed within a pattern"]
#[doc = "     by a \"(?i)\" option setting."]
#[doc = " @G_REGEX_MULTILINE: By default, GRegex treats the strings as consisting"]
#[doc = "     of a single line of characters (even if it actually contains"]
#[doc = "     newlines). The \"start of line\" metacharacter (\"^\") matches only"]
#[doc = "     at the start of the string, while the \"end of line\" metacharacter"]
#[doc = "     (\"$\") matches only at the end of the string, or before a terminating"]
#[doc = "     newline (unless #G_REGEX_DOLLAR_ENDONLY is set). When"]
#[doc = "     #G_REGEX_MULTILINE is set, the \"start of line\" and \"end of line\""]
#[doc = "     constructs match immediately following or immediately before any"]
#[doc = "     newline in the string, respectively, as well as at the very start"]
#[doc = "     and end. This can be changed within a pattern by a \"(?m)\" option"]
#[doc = "     setting."]
#[doc = " @G_REGEX_DOTALL: A dot metacharacter (\".\") in the pattern matches all"]
#[doc = "     characters, including newlines. Without it, newlines are excluded."]
#[doc = "     This option can be changed within a pattern by a (\"?s\") option setting."]
#[doc = " @G_REGEX_EXTENDED: Whitespace data characters in the pattern are"]
#[doc = "     totally ignored except when escaped or inside a character class."]
#[doc = "     Whitespace does not include the VT character (code 11). In addition,"]
#[doc = "     characters between an unescaped \"#\" outside a character class and"]
#[doc = "     the next newline character, inclusive, are also ignored. This can"]
#[doc = "     be changed within a pattern by a \"(?x)\" option setting."]
#[doc = " @G_REGEX_ANCHORED: The pattern is forced to be \"anchored\", that is,"]
#[doc = "     it is constrained to match only at the first matching point in the"]
#[doc = "     string that is being searched. This effect can also be achieved by"]
#[doc = "     appropriate constructs in the pattern itself such as the \"^\""]
#[doc = "     metacharacter."]
#[doc = " @G_REGEX_DOLLAR_ENDONLY: A dollar metacharacter (\"$\") in the pattern"]
#[doc = "     matches only at the end of the string. Without this option, a"]
#[doc = "     dollar also matches immediately before the final character if"]
#[doc = "     it is a newline (but not before any other newlines). This option"]
#[doc = "     is ignored if #G_REGEX_MULTILINE is set."]
#[doc = " @G_REGEX_UNGREEDY: Inverts the \"greediness\" of the quantifiers so that"]
#[doc = "     they are not greedy by default, but become greedy if followed by \"?\"."]
#[doc = "     It can also be set by a \"(?U)\" option setting within the pattern."]
#[doc = " @G_REGEX_RAW: Usually strings must be valid UTF-8 strings, using this"]
#[doc = "     flag they are considered as a raw sequence of bytes."]
#[doc = " @G_REGEX_NO_AUTO_CAPTURE: Disables the use of numbered capturing"]
#[doc = "     parentheses in the pattern. Any opening parenthesis that is not"]
#[doc = "     followed by \"?\" behaves as if it were followed by \"?:\" but named"]
#[doc = "     parentheses can still be used for capturing (and they acquire numbers"]
#[doc = "     in the usual way)."]
#[doc = " @G_REGEX_OPTIMIZE: Optimize the regular expression. If the pattern will"]
#[doc = "     be used many times, then it may be worth the effort to optimize it"]
#[doc = "     to improve the speed of matches."]
#[doc = " @G_REGEX_FIRSTLINE: Limits an unanchored pattern to match before (or at) the"]
#[doc = "     first newline. Since: 2.34"]
#[doc = " @G_REGEX_DUPNAMES: Names used to identify capturing subpatterns need not"]
#[doc = "     be unique. This can be helpful for certain types of pattern when it"]
#[doc = "     is known that only one instance of the named subpattern can ever be"]
#[doc = "     matched."]
#[doc = " @G_REGEX_NEWLINE_CR: Usually any newline character or character sequence is"]
#[doc = "     recognized. If this option is set, the only recognized newline character"]
#[doc = "     is '\\r'."]
#[doc = " @G_REGEX_NEWLINE_LF: Usually any newline character or character sequence is"]
#[doc = "     recognized. If this option is set, the only recognized newline character"]
#[doc = "     is '\\n'."]
#[doc = " @G_REGEX_NEWLINE_CRLF: Usually any newline character or character sequence is"]
#[doc = "     recognized. If this option is set, the only recognized newline character"]
#[doc = "     sequence is '\\r\\n'."]
#[doc = " @G_REGEX_NEWLINE_ANYCRLF: Usually any newline character or character sequence"]
#[doc = "     is recognized. If this option is set, the only recognized newline character"]
#[doc = "     sequences are '\\r', '\\n', and '\\r\\n'. Since: 2.34"]
#[doc = " @G_REGEX_BSR_ANYCRLF: Usually any newline character or character sequence"]
#[doc = "     is recognised. If this option is set, then \"\\R\" only recognizes the newline"]
#[doc = "    characters '\\r', '\\n' and '\\r\\n'. Since: 2.34"]
#[doc = " @G_REGEX_JAVASCRIPT_COMPAT: Changes behaviour so that it is compatible with"]
#[doc = "     JavaScript rather than PCRE. Since: 2.34"]
#[doc = ""]
#[doc = " Flags specifying compile-time options."]
#[doc = ""]
#[doc = " Since: 2.14"]
pub type GRegexCompileFlags = u32;
pub const GRegexMatchFlags_G_REGEX_MATCH_ANCHORED: GRegexMatchFlags = 16;
pub const GRegexMatchFlags_G_REGEX_MATCH_NOTBOL: GRegexMatchFlags = 128;
pub const GRegexMatchFlags_G_REGEX_MATCH_NOTEOL: GRegexMatchFlags = 256;
pub const GRegexMatchFlags_G_REGEX_MATCH_NOTEMPTY: GRegexMatchFlags = 1024;
pub const GRegexMatchFlags_G_REGEX_MATCH_PARTIAL: GRegexMatchFlags = 32768;
pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_CR: GRegexMatchFlags = 1048576;
pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_LF: GRegexMatchFlags = 2097152;
pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_CRLF: GRegexMatchFlags = 3145728;
pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_ANY: GRegexMatchFlags = 4194304;
pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_ANYCRLF: GRegexMatchFlags = 5242880;
pub const GRegexMatchFlags_G_REGEX_MATCH_BSR_ANYCRLF: GRegexMatchFlags = 8388608;
pub const GRegexMatchFlags_G_REGEX_MATCH_BSR_ANY: GRegexMatchFlags = 16777216;
pub const GRegexMatchFlags_G_REGEX_MATCH_PARTIAL_SOFT: GRegexMatchFlags = 32768;
pub const GRegexMatchFlags_G_REGEX_MATCH_PARTIAL_HARD: GRegexMatchFlags = 134217728;
pub const GRegexMatchFlags_G_REGEX_MATCH_NOTEMPTY_ATSTART: GRegexMatchFlags = 268435456;
#[doc = " GRegexMatchFlags:"]
#[doc = " @G_REGEX_MATCH_ANCHORED: The pattern is forced to be \"anchored\", that is,"]
#[doc = "     it is constrained to match only at the first matching point in the"]
#[doc = "     string that is being searched. This effect can also be achieved by"]
#[doc = "     appropriate constructs in the pattern itself such as the \"^\""]
#[doc = "     metacharacter."]
#[doc = " @G_REGEX_MATCH_NOTBOL: Specifies that first character of the string is"]
#[doc = "     not the beginning of a line, so the circumflex metacharacter should"]
#[doc = "     not match before it. Setting this without #G_REGEX_MULTILINE (at"]
#[doc = "     compile time) causes circumflex never to match. This option affects"]
#[doc = "     only the behaviour of the circumflex metacharacter, it does not"]
#[doc = "     affect \"\\A\"."]
#[doc = " @G_REGEX_MATCH_NOTEOL: Specifies that the end of the subject string is"]
#[doc = "     not the end of a line, so the dollar metacharacter should not match"]
#[doc = "     it nor (except in multiline mode) a newline immediately before it."]
#[doc = "     Setting this without #G_REGEX_MULTILINE (at compile time) causes"]
#[doc = "     dollar never to match. This option affects only the behaviour of"]
#[doc = "     the dollar metacharacter, it does not affect \"\\Z\" or \"\\z\"."]
#[doc = " @G_REGEX_MATCH_NOTEMPTY: An empty string is not considered to be a valid"]
#[doc = "     match if this option is set. If there are alternatives in the pattern,"]
#[doc = "     they are tried. If all the alternatives match the empty string, the"]
#[doc = "     entire match fails. For example, if the pattern \"a?b?\" is applied to"]
#[doc = "     a string not beginning with \"a\" or \"b\", it matches the empty string"]
#[doc = "     at the start of the string. With this flag set, this match is not"]
#[doc = "     valid, so GRegex searches further into the string for occurrences"]
#[doc = "     of \"a\" or \"b\"."]
#[doc = " @G_REGEX_MATCH_PARTIAL: Turns on the partial matching feature, for more"]
#[doc = "     documentation on partial matching see g_match_info_is_partial_match()."]
#[doc = " @G_REGEX_MATCH_NEWLINE_CR: Overrides the newline definition set when"]
#[doc = "     creating a new #GRegex, setting the '\\r' character as line terminator."]
#[doc = " @G_REGEX_MATCH_NEWLINE_LF: Overrides the newline definition set when"]
#[doc = "     creating a new #GRegex, setting the '\\n' character as line terminator."]
#[doc = " @G_REGEX_MATCH_NEWLINE_CRLF: Overrides the newline definition set when"]
#[doc = "     creating a new #GRegex, setting the '\\r\\n' characters sequence as line terminator."]
#[doc = " @G_REGEX_MATCH_NEWLINE_ANY: Overrides the newline definition set when"]
#[doc = "     creating a new #GRegex, any Unicode newline sequence"]
#[doc = "     is recognised as a newline. These are '\\r', '\\n' and '\\rn', and the"]
#[doc = "     single characters U+000B LINE TABULATION, U+000C FORM FEED (FF),"]
#[doc = "     U+0085 NEXT LINE (NEL), U+2028 LINE SEPARATOR and"]
#[doc = "     U+2029 PARAGRAPH SEPARATOR."]
#[doc = " @G_REGEX_MATCH_NEWLINE_ANYCRLF: Overrides the newline definition set when"]
#[doc = "     creating a new #GRegex; any '\\r', '\\n', or '\\r\\n' character sequence"]
#[doc = "     is recognized as a newline. Since: 2.34"]
#[doc = " @G_REGEX_MATCH_BSR_ANYCRLF: Overrides the newline definition for \"\\R\" set when"]
#[doc = "     creating a new #GRegex; only '\\r', '\\n', or '\\r\\n' character sequences"]
#[doc = "     are recognized as a newline by \"\\R\". Since: 2.34"]
#[doc = " @G_REGEX_MATCH_BSR_ANY: Overrides the newline definition for \"\\R\" set when"]
#[doc = "     creating a new #GRegex; any Unicode newline character or character sequence"]
#[doc = "     are recognized as a newline by \"\\R\". These are '\\r', '\\n' and '\\rn', and the"]
#[doc = "     single characters U+000B LINE TABULATION, U+000C FORM FEED (FF),"]
#[doc = "     U+0085 NEXT LINE (NEL), U+2028 LINE SEPARATOR and"]
#[doc = "     U+2029 PARAGRAPH SEPARATOR. Since: 2.34"]
#[doc = " @G_REGEX_MATCH_PARTIAL_SOFT: An alias for #G_REGEX_MATCH_PARTIAL. Since: 2.34"]
#[doc = " @G_REGEX_MATCH_PARTIAL_HARD: Turns on the partial matching feature. In contrast to"]
#[doc = "     to #G_REGEX_MATCH_PARTIAL_SOFT, this stops matching as soon as a partial match"]
#[doc = "     is found, without continuing to search for a possible complete match. See"]
#[doc = "     g_match_info_is_partial_match() for more information. Since: 2.34"]
#[doc = " @G_REGEX_MATCH_NOTEMPTY_ATSTART: Like #G_REGEX_MATCH_NOTEMPTY, but only applied to"]
#[doc = "     the start of the matched string. For anchored"]
#[doc = "     patterns this can only happen for pattern containing \"\\K\". Since: 2.34"]
#[doc = ""]
#[doc = " Flags specifying match-time options."]
#[doc = ""]
#[doc = " Since: 2.14"]
pub type GRegexMatchFlags = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRegex {
    _unused: [u8; 0],
}
#[doc = " GRegex:"]
#[doc = ""]
#[doc = " A GRegex is the \"compiled\" form of a regular expression pattern."]
#[doc = " This structure is opaque and its fields cannot be accessed directly."]
#[doc = ""]
#[doc = " Since: 2.14"]
pub type GRegex = _GRegex;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMatchInfo {
    _unused: [u8; 0],
}
#[doc = " GMatchInfo:"]
#[doc = ""]
#[doc = " A GMatchInfo is an opaque struct used to return information about"]
#[doc = " matches."]
pub type GMatchInfo = _GMatchInfo;
#[doc = " GRegexEvalCallback:"]
#[doc = " @match_info: the #GMatchInfo generated by the match."]
#[doc = "     Use g_match_info_get_regex() and g_match_info_get_string() if you"]
#[doc = "     need the #GRegex or the matched string."]
#[doc = " @result: a #GString containing the new string"]
#[doc = " @user_data: user data passed to g_regex_replace_eval()"]
#[doc = ""]
#[doc = " Specifies the type of the function passed to g_regex_replace_eval()."]
#[doc = " It is called for each occurrence of the pattern in the string passed"]
#[doc = " to g_regex_replace_eval(), and it should append the replacement to"]
#[doc = " @result."]
#[doc = ""]
#[doc = " Returns: %FALSE to continue the replacement process, %TRUE to stop it"]
#[doc = ""]
#[doc = " Since: 2.14"]
pub type GRegexEvalCallback = ::core::option::Option<
    unsafe extern "C" fn(
        match_info: *const GMatchInfo,
        result: *mut GString,
        user_data: gpointer,
    ) -> gboolean,
>;
extern "C" {
    pub fn g_regex_new(
        pattern: *const gchar,
        compile_options: GRegexCompileFlags,
        match_options: GRegexMatchFlags,
        error: *mut *mut GError,
    ) -> *mut GRegex;
}
extern "C" {
    pub fn g_regex_ref(regex: *mut GRegex) -> *mut GRegex;
}
extern "C" {
    pub fn g_regex_unref(regex: *mut GRegex);
}
extern "C" {
    pub fn g_regex_get_pattern(regex: *const GRegex) -> *const gchar;
}
extern "C" {
    pub fn g_regex_get_max_backref(regex: *const GRegex) -> gint;
}
extern "C" {
    pub fn g_regex_get_capture_count(regex: *const GRegex) -> gint;
}
extern "C" {
    pub fn g_regex_get_has_cr_or_lf(regex: *const GRegex) -> gboolean;
}
extern "C" {
    pub fn g_regex_get_max_lookbehind(regex: *const GRegex) -> gint;
}
extern "C" {
    pub fn g_regex_get_string_number(regex: *const GRegex, name: *const gchar) -> gint;
}
extern "C" {
    pub fn g_regex_escape_string(string: *const gchar, length: gint) -> *mut gchar;
}
extern "C" {
    pub fn g_regex_escape_nul(string: *const gchar, length: gint) -> *mut gchar;
}
extern "C" {
    pub fn g_regex_get_compile_flags(regex: *const GRegex) -> GRegexCompileFlags;
}
extern "C" {
    pub fn g_regex_get_match_flags(regex: *const GRegex) -> GRegexMatchFlags;
}
extern "C" {
    pub fn g_regex_match_simple(
        pattern: *const gchar,
        string: *const gchar,
        compile_options: GRegexCompileFlags,
        match_options: GRegexMatchFlags,
    ) -> gboolean;
}
extern "C" {
    pub fn g_regex_match(
        regex: *const GRegex,
        string: *const gchar,
        match_options: GRegexMatchFlags,
        match_info: *mut *mut GMatchInfo,
    ) -> gboolean;
}
extern "C" {
    pub fn g_regex_match_full(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        match_options: GRegexMatchFlags,
        match_info: *mut *mut GMatchInfo,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_regex_match_all(
        regex: *const GRegex,
        string: *const gchar,
        match_options: GRegexMatchFlags,
        match_info: *mut *mut GMatchInfo,
    ) -> gboolean;
}
extern "C" {
    pub fn g_regex_match_all_full(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        match_options: GRegexMatchFlags,
        match_info: *mut *mut GMatchInfo,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_regex_split_simple(
        pattern: *const gchar,
        string: *const gchar,
        compile_options: GRegexCompileFlags,
        match_options: GRegexMatchFlags,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_regex_split(
        regex: *const GRegex,
        string: *const gchar,
        match_options: GRegexMatchFlags,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_regex_split_full(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        match_options: GRegexMatchFlags,
        max_tokens: gint,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_regex_replace(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        replacement: *const gchar,
        match_options: GRegexMatchFlags,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_regex_replace_literal(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        replacement: *const gchar,
        match_options: GRegexMatchFlags,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_regex_replace_eval(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        match_options: GRegexMatchFlags,
        eval: GRegexEvalCallback,
        user_data: gpointer,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_regex_check_replacement(
        replacement: *const gchar,
        has_references: *mut gboolean,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_match_info_get_regex(match_info: *const GMatchInfo) -> *mut GRegex;
}
extern "C" {
    pub fn g_match_info_get_string(match_info: *const GMatchInfo) -> *const gchar;
}
extern "C" {
    pub fn g_match_info_ref(match_info: *mut GMatchInfo) -> *mut GMatchInfo;
}
extern "C" {
    pub fn g_match_info_unref(match_info: *mut GMatchInfo);
}
extern "C" {
    pub fn g_match_info_free(match_info: *mut GMatchInfo);
}
extern "C" {
    pub fn g_match_info_next(match_info: *mut GMatchInfo, error: *mut *mut GError) -> gboolean;
}
extern "C" {
    pub fn g_match_info_matches(match_info: *const GMatchInfo) -> gboolean;
}
extern "C" {
    pub fn g_match_info_get_match_count(match_info: *const GMatchInfo) -> gint;
}
extern "C" {
    pub fn g_match_info_is_partial_match(match_info: *const GMatchInfo) -> gboolean;
}
extern "C" {
    pub fn g_match_info_expand_references(
        match_info: *const GMatchInfo,
        string_to_expand: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_match_info_fetch(match_info: *const GMatchInfo, match_num: gint) -> *mut gchar;
}
extern "C" {
    pub fn g_match_info_fetch_pos(
        match_info: *const GMatchInfo,
        match_num: gint,
        start_pos: *mut gint,
        end_pos: *mut gint,
    ) -> gboolean;
}
extern "C" {
    pub fn g_match_info_fetch_named(
        match_info: *const GMatchInfo,
        name: *const gchar,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_match_info_fetch_named_pos(
        match_info: *const GMatchInfo,
        name: *const gchar,
        start_pos: *mut gint,
        end_pos: *mut gint,
    ) -> gboolean;
}
extern "C" {
    pub fn g_match_info_fetch_all(match_info: *const GMatchInfo) -> *mut *mut gchar;
}
pub type GScanner = _GScanner;
pub type GScannerConfig = _GScannerConfig;
pub type GTokenValue = _GTokenValue;
pub type GScannerMsgFunc = ::core::option::Option<
    unsafe extern "C" fn(scanner: *mut GScanner, message: *mut gchar, error: gboolean),
>;
pub const GErrorType_G_ERR_UNKNOWN: GErrorType = 0;
pub const GErrorType_G_ERR_UNEXP_EOF: GErrorType = 1;
pub const GErrorType_G_ERR_UNEXP_EOF_IN_STRING: GErrorType = 2;
pub const GErrorType_G_ERR_UNEXP_EOF_IN_COMMENT: GErrorType = 3;
pub const GErrorType_G_ERR_NON_DIGIT_IN_CONST: GErrorType = 4;
pub const GErrorType_G_ERR_DIGIT_RADIX: GErrorType = 5;
pub const GErrorType_G_ERR_FLOAT_RADIX: GErrorType = 6;
pub const GErrorType_G_ERR_FLOAT_MALFORMED: GErrorType = 7;
pub type GErrorType = u32;
pub const GTokenType_G_TOKEN_EOF: GTokenType = 0;
pub const GTokenType_G_TOKEN_LEFT_PAREN: GTokenType = 40;
pub const GTokenType_G_TOKEN_RIGHT_PAREN: GTokenType = 41;
pub const GTokenType_G_TOKEN_LEFT_CURLY: GTokenType = 123;
pub const GTokenType_G_TOKEN_RIGHT_CURLY: GTokenType = 125;
pub const GTokenType_G_TOKEN_LEFT_BRACE: GTokenType = 91;
pub const GTokenType_G_TOKEN_RIGHT_BRACE: GTokenType = 93;
pub const GTokenType_G_TOKEN_EQUAL_SIGN: GTokenType = 61;
pub const GTokenType_G_TOKEN_COMMA: GTokenType = 44;
pub const GTokenType_G_TOKEN_NONE: GTokenType = 256;
pub const GTokenType_G_TOKEN_ERROR: GTokenType = 257;
pub const GTokenType_G_TOKEN_CHAR: GTokenType = 258;
pub const GTokenType_G_TOKEN_BINARY: GTokenType = 259;
pub const GTokenType_G_TOKEN_OCTAL: GTokenType = 260;
pub const GTokenType_G_TOKEN_INT: GTokenType = 261;
pub const GTokenType_G_TOKEN_HEX: GTokenType = 262;
pub const GTokenType_G_TOKEN_FLOAT: GTokenType = 263;
pub const GTokenType_G_TOKEN_STRING: GTokenType = 264;
pub const GTokenType_G_TOKEN_SYMBOL: GTokenType = 265;
pub const GTokenType_G_TOKEN_IDENTIFIER: GTokenType = 266;
pub const GTokenType_G_TOKEN_IDENTIFIER_NULL: GTokenType = 267;
pub const GTokenType_G_TOKEN_COMMENT_SINGLE: GTokenType = 268;
pub const GTokenType_G_TOKEN_COMMENT_MULTI: GTokenType = 269;
pub const GTokenType_G_TOKEN_LAST: GTokenType = 270;
pub type GTokenType = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GTokenValue {
    pub v_symbol: gpointer,
    pub v_identifier: *mut gchar,
    pub v_binary: gulong,
    pub v_octal: gulong,
    pub v_int: gulong,
    pub v_int64: guint64,
    pub v_float: gdouble,
    pub v_hex: gulong,
    pub v_string: *mut gchar,
    pub v_comment: *mut gchar,
    pub v_char: guchar,
    pub v_error: guint,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__GTokenValue() {
    assert_eq!(
        ::core::mem::size_of::<_GTokenValue>(),
        8usize,
        concat!("Size of: ", stringify!(_GTokenValue))
    );
    assert_eq!(
        ::core::mem::align_of::<_GTokenValue>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTokenValue))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GTokenValue>())).v_symbol as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_symbol)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GTokenValue>())).v_identifier as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_identifier)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GTokenValue>())).v_binary as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_binary)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GTokenValue>())).v_octal as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_octal)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GTokenValue>())).v_int as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_int)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GTokenValue>())).v_int64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_int64)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GTokenValue>())).v_float as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_float)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GTokenValue>())).v_hex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_hex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GTokenValue>())).v_string as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_string)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GTokenValue>())).v_comment as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_comment)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GTokenValue>())).v_char as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_char)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GTokenValue>())).v_error as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_error)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GScannerConfig {
    pub cset_skip_characters: *mut gchar,
    pub cset_identifier_first: *mut gchar,
    pub cset_identifier_nth: *mut gchar,
    pub cpair_comment_single: *mut gchar,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize], u8>,
    pub padding_dummy: guint,
}
#[test]
fn bindgen_test_layout__GScannerConfig() {
    assert_eq!(
        ::core::mem::size_of::<_GScannerConfig>(),
        40usize,
        concat!("Size of: ", stringify!(_GScannerConfig))
    );
    assert_eq!(
        ::core::mem::align_of::<_GScannerConfig>(),
        8usize,
        concat!("Alignment of ", stringify!(_GScannerConfig))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_GScannerConfig>())).cset_skip_characters as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScannerConfig),
            "::",
            stringify!(cset_skip_characters)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_GScannerConfig>())).cset_identifier_first as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScannerConfig),
            "::",
            stringify!(cset_identifier_first)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_GScannerConfig>())).cset_identifier_nth as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScannerConfig),
            "::",
            stringify!(cset_identifier_nth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_GScannerConfig>())).cpair_comment_single as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScannerConfig),
            "::",
            stringify!(cpair_comment_single)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GScannerConfig>())).padding_dummy as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScannerConfig),
            "::",
            stringify!(padding_dummy)
        )
    );
}
impl _GScannerConfig {
    #[inline]
    pub fn case_sensitive(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_case_sensitive(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn skip_comment_multi(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skip_comment_multi(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn skip_comment_single(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skip_comment_single(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_comment_multi(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_comment_multi(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_identifier(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_identifier(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_identifier_1char(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_identifier_1char(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_identifier_NULL(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_identifier_NULL(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_symbols(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_symbols(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_binary(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_binary(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_octal(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_octal(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_float(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_float(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_hex(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_hex(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_hex_dollar(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_hex_dollar(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_string_sq(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_string_sq(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_string_dq(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_string_dq(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn numbers_2_int(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_numbers_2_int(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int_2_float(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_int_2_float(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn identifier_2_string(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_identifier_2_string(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn char_2_token(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_char_2_token(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn symbol_2_token(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_symbol_2_token(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scope_0_fallback(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scope_0_fallback(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn store_int64(&self) -> guint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_store_int64(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        case_sensitive: guint,
        skip_comment_multi: guint,
        skip_comment_single: guint,
        scan_comment_multi: guint,
        scan_identifier: guint,
        scan_identifier_1char: guint,
        scan_identifier_NULL: guint,
        scan_symbols: guint,
        scan_binary: guint,
        scan_octal: guint,
        scan_float: guint,
        scan_hex: guint,
        scan_hex_dollar: guint,
        scan_string_sq: guint,
        scan_string_dq: guint,
        numbers_2_int: guint,
        int_2_float: guint,
        identifier_2_string: guint,
        char_2_token: guint,
        symbol_2_token: guint,
        scope_0_fallback: guint,
        store_int64: guint,
    ) -> __BindgenBitfieldUnit<[u8; 3usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let case_sensitive: u32 = unsafe { ::core::mem::transmute(case_sensitive) };
            case_sensitive as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let skip_comment_multi: u32 = unsafe { ::core::mem::transmute(skip_comment_multi) };
            skip_comment_multi as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let skip_comment_single: u32 = unsafe { ::core::mem::transmute(skip_comment_single) };
            skip_comment_single as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let scan_comment_multi: u32 = unsafe { ::core::mem::transmute(scan_comment_multi) };
            scan_comment_multi as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let scan_identifier: u32 = unsafe { ::core::mem::transmute(scan_identifier) };
            scan_identifier as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let scan_identifier_1char: u32 =
                unsafe { ::core::mem::transmute(scan_identifier_1char) };
            scan_identifier_1char as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let scan_identifier_NULL: u32 = unsafe { ::core::mem::transmute(scan_identifier_NULL) };
            scan_identifier_NULL as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let scan_symbols: u32 = unsafe { ::core::mem::transmute(scan_symbols) };
            scan_symbols as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let scan_binary: u32 = unsafe { ::core::mem::transmute(scan_binary) };
            scan_binary as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let scan_octal: u32 = unsafe { ::core::mem::transmute(scan_octal) };
            scan_octal as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let scan_float: u32 = unsafe { ::core::mem::transmute(scan_float) };
            scan_float as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let scan_hex: u32 = unsafe { ::core::mem::transmute(scan_hex) };
            scan_hex as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let scan_hex_dollar: u32 = unsafe { ::core::mem::transmute(scan_hex_dollar) };
            scan_hex_dollar as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let scan_string_sq: u32 = unsafe { ::core::mem::transmute(scan_string_sq) };
            scan_string_sq as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let scan_string_dq: u32 = unsafe { ::core::mem::transmute(scan_string_dq) };
            scan_string_dq as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let numbers_2_int: u32 = unsafe { ::core::mem::transmute(numbers_2_int) };
            numbers_2_int as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let int_2_float: u32 = unsafe { ::core::mem::transmute(int_2_float) };
            int_2_float as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let identifier_2_string: u32 = unsafe { ::core::mem::transmute(identifier_2_string) };
            identifier_2_string as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let char_2_token: u32 = unsafe { ::core::mem::transmute(char_2_token) };
            char_2_token as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let symbol_2_token: u32 = unsafe { ::core::mem::transmute(symbol_2_token) };
            symbol_2_token as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let scope_0_fallback: u32 = unsafe { ::core::mem::transmute(scope_0_fallback) };
            scope_0_fallback as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let store_int64: u32 = unsafe { ::core::mem::transmute(store_int64) };
            store_int64 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GScanner {
    pub user_data: gpointer,
    pub max_parse_errors: guint,
    pub parse_errors: guint,
    pub input_name: *const gchar,
    pub qdata: *mut GData,
    pub config: *mut GScannerConfig,
    pub token: GTokenType,
    pub value: GTokenValue,
    pub line: guint,
    pub position: guint,
    pub next_token: GTokenType,
    pub next_value: GTokenValue,
    pub next_line: guint,
    pub next_position: guint,
    pub symbol_table: *mut GHashTable,
    pub input_fd: gint,
    pub text: *const gchar,
    pub text_end: *const gchar,
    pub buffer: *mut gchar,
    pub scope_id: guint,
    pub msg_handler: GScannerMsgFunc,
}
#[test]
fn bindgen_test_layout__GScanner() {
    assert_eq!(
        ::core::mem::size_of::<_GScanner>(),
        144usize,
        concat!("Size of: ", stringify!(_GScanner))
    );
    assert_eq!(
        ::core::mem::align_of::<_GScanner>(),
        8usize,
        concat!("Alignment of ", stringify!(_GScanner))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GScanner>())).user_data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GScanner>())).max_parse_errors as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(max_parse_errors)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GScanner>())).parse_errors as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(parse_errors)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GScanner>())).input_name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(input_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GScanner>())).qdata as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(qdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GScanner>())).config as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(config)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GScanner>())).token as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(token)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GScanner>())).value as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GScanner>())).line as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(line)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GScanner>())).position as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GScanner>())).next_token as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(next_token)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GScanner>())).next_value as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(next_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GScanner>())).next_line as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(next_line)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GScanner>())).next_position as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(next_position)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GScanner>())).symbol_table as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(symbol_table)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GScanner>())).input_fd as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(input_fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GScanner>())).text as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GScanner>())).text_end as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(text_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GScanner>())).buffer as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GScanner>())).scope_id as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(scope_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GScanner>())).msg_handler as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(msg_handler)
        )
    );
}
extern "C" {
    pub fn g_scanner_new(config_templ: *const GScannerConfig) -> *mut GScanner;
}
extern "C" {
    pub fn g_scanner_destroy(scanner: *mut GScanner);
}
extern "C" {
    pub fn g_scanner_input_file(scanner: *mut GScanner, input_fd: gint);
}
extern "C" {
    pub fn g_scanner_sync_file_offset(scanner: *mut GScanner);
}
extern "C" {
    pub fn g_scanner_input_text(scanner: *mut GScanner, text: *const gchar, text_len: guint);
}
extern "C" {
    pub fn g_scanner_get_next_token(scanner: *mut GScanner) -> GTokenType;
}
extern "C" {
    pub fn g_scanner_peek_next_token(scanner: *mut GScanner) -> GTokenType;
}
extern "C" {
    pub fn g_scanner_cur_token(scanner: *mut GScanner) -> GTokenType;
}
extern "C" {
    pub fn g_scanner_cur_value(scanner: *mut GScanner) -> GTokenValue;
}
extern "C" {
    pub fn g_scanner_cur_line(scanner: *mut GScanner) -> guint;
}
extern "C" {
    pub fn g_scanner_cur_position(scanner: *mut GScanner) -> guint;
}
extern "C" {
    pub fn g_scanner_eof(scanner: *mut GScanner) -> gboolean;
}
extern "C" {
    pub fn g_scanner_set_scope(scanner: *mut GScanner, scope_id: guint) -> guint;
}
extern "C" {
    pub fn g_scanner_scope_add_symbol(
        scanner: *mut GScanner,
        scope_id: guint,
        symbol: *const gchar,
        value: gpointer,
    );
}
extern "C" {
    pub fn g_scanner_scope_remove_symbol(
        scanner: *mut GScanner,
        scope_id: guint,
        symbol: *const gchar,
    );
}
extern "C" {
    pub fn g_scanner_scope_lookup_symbol(
        scanner: *mut GScanner,
        scope_id: guint,
        symbol: *const gchar,
    ) -> gpointer;
}
extern "C" {
    pub fn g_scanner_scope_foreach_symbol(
        scanner: *mut GScanner,
        scope_id: guint,
        func: GHFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_scanner_lookup_symbol(scanner: *mut GScanner, symbol: *const gchar) -> gpointer;
}
extern "C" {
    pub fn g_scanner_unexp_token(
        scanner: *mut GScanner,
        expected_token: GTokenType,
        identifier_spec: *const gchar,
        symbol_spec: *const gchar,
        symbol_name: *const gchar,
        message: *const gchar,
        is_error: gint,
    );
}
extern "C" {
    pub fn g_scanner_error(scanner: *mut GScanner, format: *const gchar, ...);
}
extern "C" {
    pub fn g_scanner_warn(scanner: *mut GScanner, format: *const gchar, ...);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSequence {
    _unused: [u8; 0],
}
pub type GSequence = _GSequence;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSequenceNode {
    _unused: [u8; 0],
}
pub type GSequenceIter = _GSequenceNode;
pub type GSequenceIterCompareFunc = ::core::option::Option<
    unsafe extern "C" fn(a: *mut GSequenceIter, b: *mut GSequenceIter, data: gpointer) -> gint,
>;
extern "C" {
    pub fn g_sequence_new(data_destroy: GDestroyNotify) -> *mut GSequence;
}
extern "C" {
    pub fn g_sequence_free(seq: *mut GSequence);
}
extern "C" {
    pub fn g_sequence_get_length(seq: *mut GSequence) -> gint;
}
extern "C" {
    pub fn g_sequence_foreach(seq: *mut GSequence, func: GFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_sequence_foreach_range(
        begin: *mut GSequenceIter,
        end: *mut GSequenceIter,
        func: GFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_sequence_sort(seq: *mut GSequence, cmp_func: GCompareDataFunc, cmp_data: gpointer);
}
extern "C" {
    pub fn g_sequence_sort_iter(
        seq: *mut GSequence,
        cmp_func: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    );
}
extern "C" {
    pub fn g_sequence_is_empty(seq: *mut GSequence) -> gboolean;
}
extern "C" {
    pub fn g_sequence_get_begin_iter(seq: *mut GSequence) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_get_end_iter(seq: *mut GSequence) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_get_iter_at_pos(seq: *mut GSequence, pos: gint) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_append(seq: *mut GSequence, data: gpointer) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_prepend(seq: *mut GSequence, data: gpointer) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_insert_before(iter: *mut GSequenceIter, data: gpointer)
        -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_move(src: *mut GSequenceIter, dest: *mut GSequenceIter);
}
extern "C" {
    pub fn g_sequence_swap(a: *mut GSequenceIter, b: *mut GSequenceIter);
}
extern "C" {
    pub fn g_sequence_insert_sorted(
        seq: *mut GSequence,
        data: gpointer,
        cmp_func: GCompareDataFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_insert_sorted_iter(
        seq: *mut GSequence,
        data: gpointer,
        iter_cmp: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_sort_changed(
        iter: *mut GSequenceIter,
        cmp_func: GCompareDataFunc,
        cmp_data: gpointer,
    );
}
extern "C" {
    pub fn g_sequence_sort_changed_iter(
        iter: *mut GSequenceIter,
        iter_cmp: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    );
}
extern "C" {
    pub fn g_sequence_remove(iter: *mut GSequenceIter);
}
extern "C" {
    pub fn g_sequence_remove_range(begin: *mut GSequenceIter, end: *mut GSequenceIter);
}
extern "C" {
    pub fn g_sequence_move_range(
        dest: *mut GSequenceIter,
        begin: *mut GSequenceIter,
        end: *mut GSequenceIter,
    );
}
extern "C" {
    pub fn g_sequence_search(
        seq: *mut GSequence,
        data: gpointer,
        cmp_func: GCompareDataFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_search_iter(
        seq: *mut GSequence,
        data: gpointer,
        iter_cmp: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_lookup(
        seq: *mut GSequence,
        data: gpointer,
        cmp_func: GCompareDataFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_lookup_iter(
        seq: *mut GSequence,
        data: gpointer,
        iter_cmp: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_get(iter: *mut GSequenceIter) -> gpointer;
}
extern "C" {
    pub fn g_sequence_set(iter: *mut GSequenceIter, data: gpointer);
}
extern "C" {
    pub fn g_sequence_iter_is_begin(iter: *mut GSequenceIter) -> gboolean;
}
extern "C" {
    pub fn g_sequence_iter_is_end(iter: *mut GSequenceIter) -> gboolean;
}
extern "C" {
    pub fn g_sequence_iter_next(iter: *mut GSequenceIter) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_iter_prev(iter: *mut GSequenceIter) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_iter_get_position(iter: *mut GSequenceIter) -> gint;
}
extern "C" {
    pub fn g_sequence_iter_move(iter: *mut GSequenceIter, delta: gint) -> *mut GSequenceIter;
}
extern "C" {
    pub fn g_sequence_iter_get_sequence(iter: *mut GSequenceIter) -> *mut GSequence;
}
extern "C" {
    pub fn g_sequence_iter_compare(a: *mut GSequenceIter, b: *mut GSequenceIter) -> gint;
}
extern "C" {
    pub fn g_sequence_range_get_midpoint(
        begin: *mut GSequenceIter,
        end: *mut GSequenceIter,
    ) -> *mut GSequenceIter;
}
pub const GShellError_G_SHELL_ERROR_BAD_QUOTING: GShellError = 0;
pub const GShellError_G_SHELL_ERROR_EMPTY_STRING: GShellError = 1;
pub const GShellError_G_SHELL_ERROR_FAILED: GShellError = 2;
pub type GShellError = u32;
extern "C" {
    pub fn g_shell_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_shell_quote(unquoted_string: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_shell_unquote(quoted_string: *const gchar, error: *mut *mut GError) -> *mut gchar;
}
extern "C" {
    pub fn g_shell_parse_argv(
        command_line: *const gchar,
        argcp: *mut gint,
        argvp: *mut *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_slice_alloc(block_size: gsize) -> gpointer;
}
extern "C" {
    pub fn g_slice_alloc0(block_size: gsize) -> gpointer;
}
extern "C" {
    pub fn g_slice_copy(block_size: gsize, mem_block: gconstpointer) -> gpointer;
}
extern "C" {
    pub fn g_slice_free1(block_size: gsize, mem_block: gpointer);
}
extern "C" {
    pub fn g_slice_free_chain_with_offset(
        block_size: gsize,
        mem_chain: gpointer,
        next_offset: gsize,
    );
}
pub const GSliceConfig_G_SLICE_CONFIG_ALWAYS_MALLOC: GSliceConfig = 1;
pub const GSliceConfig_G_SLICE_CONFIG_BYPASS_MAGAZINES: GSliceConfig = 2;
pub const GSliceConfig_G_SLICE_CONFIG_WORKING_SET_MSECS: GSliceConfig = 3;
pub const GSliceConfig_G_SLICE_CONFIG_COLOR_INCREMENT: GSliceConfig = 4;
pub const GSliceConfig_G_SLICE_CONFIG_CHUNK_SIZES: GSliceConfig = 5;
pub const GSliceConfig_G_SLICE_CONFIG_CONTENTION_COUNTER: GSliceConfig = 6;
pub type GSliceConfig = u32;
extern "C" {
    pub fn g_slice_set_config(ckey: GSliceConfig, value: gint64);
}
extern "C" {
    pub fn g_slice_get_config(ckey: GSliceConfig) -> gint64;
}
extern "C" {
    pub fn g_slice_get_config_state(
        ckey: GSliceConfig,
        address: gint64,
        n_values: *mut guint,
    ) -> *mut gint64;
}
pub const GSpawnError_G_SPAWN_ERROR_FORK: GSpawnError = 0;
pub const GSpawnError_G_SPAWN_ERROR_READ: GSpawnError = 1;
pub const GSpawnError_G_SPAWN_ERROR_CHDIR: GSpawnError = 2;
pub const GSpawnError_G_SPAWN_ERROR_ACCES: GSpawnError = 3;
pub const GSpawnError_G_SPAWN_ERROR_PERM: GSpawnError = 4;
pub const GSpawnError_G_SPAWN_ERROR_TOO_BIG: GSpawnError = 5;
pub const GSpawnError_G_SPAWN_ERROR_2BIG: GSpawnError = 5;
pub const GSpawnError_G_SPAWN_ERROR_NOEXEC: GSpawnError = 6;
pub const GSpawnError_G_SPAWN_ERROR_NAMETOOLONG: GSpawnError = 7;
pub const GSpawnError_G_SPAWN_ERROR_NOENT: GSpawnError = 8;
pub const GSpawnError_G_SPAWN_ERROR_NOMEM: GSpawnError = 9;
pub const GSpawnError_G_SPAWN_ERROR_NOTDIR: GSpawnError = 10;
pub const GSpawnError_G_SPAWN_ERROR_LOOP: GSpawnError = 11;
pub const GSpawnError_G_SPAWN_ERROR_TXTBUSY: GSpawnError = 12;
pub const GSpawnError_G_SPAWN_ERROR_IO: GSpawnError = 13;
pub const GSpawnError_G_SPAWN_ERROR_NFILE: GSpawnError = 14;
pub const GSpawnError_G_SPAWN_ERROR_MFILE: GSpawnError = 15;
pub const GSpawnError_G_SPAWN_ERROR_INVAL: GSpawnError = 16;
pub const GSpawnError_G_SPAWN_ERROR_ISDIR: GSpawnError = 17;
pub const GSpawnError_G_SPAWN_ERROR_LIBBAD: GSpawnError = 18;
pub const GSpawnError_G_SPAWN_ERROR_FAILED: GSpawnError = 19;
#[doc = " GSpawnError:"]
#[doc = " @G_SPAWN_ERROR_FORK: Fork failed due to lack of memory."]
#[doc = " @G_SPAWN_ERROR_READ: Read or select on pipes failed."]
#[doc = " @G_SPAWN_ERROR_CHDIR: Changing to working directory failed."]
#[doc = " @G_SPAWN_ERROR_ACCES: execv() returned `EACCES`"]
#[doc = " @G_SPAWN_ERROR_PERM: execv() returned `EPERM`"]
#[doc = " @G_SPAWN_ERROR_TOO_BIG: execv() returned `E2BIG`"]
#[doc = " @G_SPAWN_ERROR_2BIG: deprecated alias for %G_SPAWN_ERROR_TOO_BIG (deprecated since GLib 2.32)"]
#[doc = " @G_SPAWN_ERROR_NOEXEC: execv() returned `ENOEXEC`"]
#[doc = " @G_SPAWN_ERROR_NAMETOOLONG: execv() returned `ENAMETOOLONG`"]
#[doc = " @G_SPAWN_ERROR_NOENT: execv() returned `ENOENT`"]
#[doc = " @G_SPAWN_ERROR_NOMEM: execv() returned `ENOMEM`"]
#[doc = " @G_SPAWN_ERROR_NOTDIR: execv() returned `ENOTDIR`"]
#[doc = " @G_SPAWN_ERROR_LOOP: execv() returned `ELOOP`"]
#[doc = " @G_SPAWN_ERROR_TXTBUSY: execv() returned `ETXTBUSY`"]
#[doc = " @G_SPAWN_ERROR_IO: execv() returned `EIO`"]
#[doc = " @G_SPAWN_ERROR_NFILE: execv() returned `ENFILE`"]
#[doc = " @G_SPAWN_ERROR_MFILE: execv() returned `EMFILE`"]
#[doc = " @G_SPAWN_ERROR_INVAL: execv() returned `EINVAL`"]
#[doc = " @G_SPAWN_ERROR_ISDIR: execv() returned `EISDIR`"]
#[doc = " @G_SPAWN_ERROR_LIBBAD: execv() returned `ELIBBAD`"]
#[doc = " @G_SPAWN_ERROR_FAILED: Some other fatal failure,"]
#[doc = "   `error->message` should explain."]
#[doc = ""]
#[doc = " Error codes returned by spawning processes."]
pub type GSpawnError = u32;
#[doc = " GSpawnChildSetupFunc:"]
#[doc = " @user_data: (closure): user data to pass to the function."]
#[doc = ""]
#[doc = " Specifies the type of the setup function passed to g_spawn_async(),"]
#[doc = " g_spawn_sync() and g_spawn_async_with_pipes(), which can, in very"]
#[doc = " limited ways, be used to affect the child's execution."]
#[doc = ""]
#[doc = " On POSIX platforms, the function is called in the child after GLib"]
#[doc = " has performed all the setup it plans to perform, but before calling"]
#[doc = " exec(). Actions taken in this function will only affect the child,"]
#[doc = " not the parent."]
#[doc = ""]
#[doc = " On Windows, the function is called in the parent. Its usefulness on"]
#[doc = " Windows is thus questionable. In many cases executing the child setup"]
#[doc = " function in the parent can have ill effects, and you should be very"]
#[doc = " careful when porting software to Windows that uses child setup"]
#[doc = " functions."]
#[doc = ""]
#[doc = " However, even on POSIX, you are extremely limited in what you can"]
#[doc = " safely do from a #GSpawnChildSetupFunc, because any mutexes that were"]
#[doc = " held by other threads in the parent process at the time of the fork()"]
#[doc = " will still be locked in the child process, and they will never be"]
#[doc = " unlocked (since the threads that held them don't exist in the child)."]
#[doc = " POSIX allows only async-signal-safe functions (see signal(7)) to be"]
#[doc = " called in the child between fork() and exec(), which drastically limits"]
#[doc = " the usefulness of child setup functions."]
#[doc = ""]
#[doc = " In particular, it is not safe to call any function which may"]
#[doc = " call malloc(), which includes POSIX functions such as setenv()."]
#[doc = " If you need to set up the child environment differently from"]
#[doc = " the parent, you should use g_get_environ(), g_environ_setenv(),"]
#[doc = " and g_environ_unsetenv(), and then pass the complete environment"]
#[doc = " list to the `g_spawn...` function."]
pub type GSpawnChildSetupFunc = ::core::option::Option<unsafe extern "C" fn(user_data: gpointer)>;
pub const GSpawnFlags_G_SPAWN_DEFAULT: GSpawnFlags = 0;
pub const GSpawnFlags_G_SPAWN_LEAVE_DESCRIPTORS_OPEN: GSpawnFlags = 1;
pub const GSpawnFlags_G_SPAWN_DO_NOT_REAP_CHILD: GSpawnFlags = 2;
pub const GSpawnFlags_G_SPAWN_SEARCH_PATH: GSpawnFlags = 4;
pub const GSpawnFlags_G_SPAWN_STDOUT_TO_DEV_NULL: GSpawnFlags = 8;
pub const GSpawnFlags_G_SPAWN_STDERR_TO_DEV_NULL: GSpawnFlags = 16;
pub const GSpawnFlags_G_SPAWN_CHILD_INHERITS_STDIN: GSpawnFlags = 32;
pub const GSpawnFlags_G_SPAWN_FILE_AND_ARGV_ZERO: GSpawnFlags = 64;
pub const GSpawnFlags_G_SPAWN_SEARCH_PATH_FROM_ENVP: GSpawnFlags = 128;
pub const GSpawnFlags_G_SPAWN_CLOEXEC_PIPES: GSpawnFlags = 256;
#[doc = " GSpawnFlags:"]
#[doc = " @G_SPAWN_DEFAULT: no flags, default behaviour"]
#[doc = " @G_SPAWN_LEAVE_DESCRIPTORS_OPEN: the parent's open file descriptors will"]
#[doc = "     be inherited by the child; otherwise all descriptors except stdin,"]
#[doc = "     stdout and stderr will be closed before calling exec() in the child."]
#[doc = " @G_SPAWN_DO_NOT_REAP_CHILD: the child will not be automatically reaped;"]
#[doc = "     you must use g_child_watch_add() yourself (or call waitpid() or handle"]
#[doc = "     `SIGCHLD` yourself), or the child will become a zombie."]
#[doc = " @G_SPAWN_SEARCH_PATH: `argv[0]` need not be an absolute path, it will be"]
#[doc = "     looked for in the user's `PATH`."]
#[doc = " @G_SPAWN_STDOUT_TO_DEV_NULL: the child's standard output will be discarded,"]
#[doc = "     instead of going to the same location as the parent's standard output."]
#[doc = " @G_SPAWN_STDERR_TO_DEV_NULL: the child's standard error will be discarded."]
#[doc = " @G_SPAWN_CHILD_INHERITS_STDIN: the child will inherit the parent's standard"]
#[doc = "     input (by default, the child's standard input is attached to `/dev/null`)."]
#[doc = " @G_SPAWN_FILE_AND_ARGV_ZERO: the first element of `argv` is the file to"]
#[doc = "     execute, while the remaining elements are the actual argument vector"]
#[doc = "     to pass to the file. Normally g_spawn_async_with_pipes() uses `argv[0]`"]
#[doc = "     as the file to execute, and passes all of `argv` to the child."]
#[doc = " @G_SPAWN_SEARCH_PATH_FROM_ENVP: if `argv[0]` is not an abolute path,"]
#[doc = "     it will be looked for in the `PATH` from the passed child environment."]
#[doc = "     Since: 2.34"]
#[doc = " @G_SPAWN_CLOEXEC_PIPES: create all pipes with the `O_CLOEXEC` flag set."]
#[doc = "     Since: 2.40"]
#[doc = ""]
#[doc = " Flags passed to g_spawn_sync(), g_spawn_async() and g_spawn_async_with_pipes()."]
pub type GSpawnFlags = u32;
extern "C" {
    pub fn g_spawn_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_spawn_exit_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_spawn_async(
        working_directory: *const gchar,
        argv: *mut *mut gchar,
        envp: *mut *mut gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        child_pid: *mut GPid,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_spawn_async_with_pipes(
        working_directory: *const gchar,
        argv: *mut *mut gchar,
        envp: *mut *mut gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        child_pid: *mut GPid,
        standard_input: *mut gint,
        standard_output: *mut gint,
        standard_error: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_spawn_async_with_fds(
        working_directory: *const gchar,
        argv: *mut *mut gchar,
        envp: *mut *mut gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        child_pid: *mut GPid,
        stdin_fd: gint,
        stdout_fd: gint,
        stderr_fd: gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_spawn_sync(
        working_directory: *const gchar,
        argv: *mut *mut gchar,
        envp: *mut *mut gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        standard_output: *mut *mut gchar,
        standard_error: *mut *mut gchar,
        exit_status: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_spawn_command_line_sync(
        command_line: *const gchar,
        standard_output: *mut *mut gchar,
        standard_error: *mut *mut gchar,
        exit_status: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_spawn_command_line_async(
        command_line: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_spawn_check_exit_status(exit_status: gint, error: *mut *mut GError) -> gboolean;
}
extern "C" {
    pub fn g_spawn_close_pid(pid: GPid);
}
pub const GAsciiType_G_ASCII_ALNUM: GAsciiType = 1;
pub const GAsciiType_G_ASCII_ALPHA: GAsciiType = 2;
pub const GAsciiType_G_ASCII_CNTRL: GAsciiType = 4;
pub const GAsciiType_G_ASCII_DIGIT: GAsciiType = 8;
pub const GAsciiType_G_ASCII_GRAPH: GAsciiType = 16;
pub const GAsciiType_G_ASCII_LOWER: GAsciiType = 32;
pub const GAsciiType_G_ASCII_PRINT: GAsciiType = 64;
pub const GAsciiType_G_ASCII_PUNCT: GAsciiType = 128;
pub const GAsciiType_G_ASCII_SPACE: GAsciiType = 256;
pub const GAsciiType_G_ASCII_UPPER: GAsciiType = 512;
pub const GAsciiType_G_ASCII_XDIGIT: GAsciiType = 1024;
pub type GAsciiType = u32;
extern "C" {
    pub static g_ascii_table: *const guint16;
}
extern "C" {
    pub fn g_ascii_tolower(c: gchar) -> gchar;
}
extern "C" {
    pub fn g_ascii_toupper(c: gchar) -> gchar;
}
extern "C" {
    pub fn g_ascii_digit_value(c: gchar) -> gint;
}
extern "C" {
    pub fn g_ascii_xdigit_value(c: gchar) -> gint;
}
extern "C" {
    pub fn g_strdelimit(
        string: *mut gchar,
        delimiters: *const gchar,
        new_delimiter: gchar,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_strcanon(
        string: *mut gchar,
        valid_chars: *const gchar,
        substitutor: gchar,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_strerror(errnum: gint) -> *const gchar;
}
extern "C" {
    pub fn g_strsignal(signum: gint) -> *const gchar;
}
extern "C" {
    pub fn g_strreverse(string: *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strlcpy(dest: *mut gchar, src: *const gchar, dest_size: gsize) -> gsize;
}
extern "C" {
    pub fn g_strlcat(dest: *mut gchar, src: *const gchar, dest_size: gsize) -> gsize;
}
extern "C" {
    pub fn g_strstr_len(
        haystack: *const gchar,
        haystack_len: gssize,
        needle: *const gchar,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_strrstr(haystack: *const gchar, needle: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strrstr_len(
        haystack: *const gchar,
        haystack_len: gssize,
        needle: *const gchar,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_str_has_suffix(str_: *const gchar, suffix: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_str_has_prefix(str_: *const gchar, prefix: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_strtod(nptr: *const gchar, endptr: *mut *mut gchar) -> gdouble;
}
extern "C" {
    pub fn g_ascii_strtod(nptr: *const gchar, endptr: *mut *mut gchar) -> gdouble;
}
extern "C" {
    pub fn g_ascii_strtoull(nptr: *const gchar, endptr: *mut *mut gchar, base: guint) -> guint64;
}
extern "C" {
    pub fn g_ascii_strtoll(nptr: *const gchar, endptr: *mut *mut gchar, base: guint) -> gint64;
}
extern "C" {
    pub fn g_ascii_dtostr(buffer: *mut gchar, buf_len: gint, d: gdouble) -> *mut gchar;
}
extern "C" {
    pub fn g_ascii_formatd(
        buffer: *mut gchar,
        buf_len: gint,
        format: *const gchar,
        d: gdouble,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_strchug(string: *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strchomp(string: *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_ascii_strcasecmp(s1: *const gchar, s2: *const gchar) -> gint;
}
extern "C" {
    pub fn g_ascii_strncasecmp(s1: *const gchar, s2: *const gchar, n: gsize) -> gint;
}
extern "C" {
    pub fn g_ascii_strdown(str_: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    pub fn g_ascii_strup(str_: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    pub fn g_str_is_ascii(str_: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_strcasecmp(s1: *const gchar, s2: *const gchar) -> gint;
}
extern "C" {
    pub fn g_strncasecmp(s1: *const gchar, s2: *const gchar, n: guint) -> gint;
}
extern "C" {
    pub fn g_strdown(string: *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strup(string: *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strdup(str_: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strdup_printf(format: *const gchar, ...) -> *mut gchar;
}
extern "C" {
    pub fn g_strdup_vprintf(format: *const gchar, args: *mut __va_list_tag) -> *mut gchar;
}
extern "C" {
    pub fn g_strndup(str_: *const gchar, n: gsize) -> *mut gchar;
}
extern "C" {
    pub fn g_strnfill(length: gsize, fill_char: gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strconcat(string1: *const gchar, ...) -> *mut gchar;
}
extern "C" {
    pub fn g_strjoin(separator: *const gchar, ...) -> *mut gchar;
}
extern "C" {
    pub fn g_strcompress(source: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strescape(source: *const gchar, exceptions: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_memdup(mem: gconstpointer, byte_size: guint) -> gpointer;
}
pub type GStrv = *mut *mut gchar;
extern "C" {
    pub fn g_strsplit(
        string: *const gchar,
        delimiter: *const gchar,
        max_tokens: gint,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_strsplit_set(
        string: *const gchar,
        delimiters: *const gchar,
        max_tokens: gint,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_strjoinv(separator: *const gchar, str_array: *mut *mut gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_strfreev(str_array: *mut *mut gchar);
}
extern "C" {
    pub fn g_strdupv(str_array: *mut *mut gchar) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_strv_length(str_array: *mut *mut gchar) -> guint;
}
extern "C" {
    pub fn g_stpcpy(dest: *mut gchar, src: *const cty::c_char) -> *mut gchar;
}
extern "C" {
    pub fn g_str_to_ascii(str_: *const gchar, from_locale: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_str_tokenize_and_fold(
        string: *const gchar,
        translit_locale: *const gchar,
        ascii_alternates: *mut *mut *mut gchar,
    ) -> *mut *mut gchar;
}
extern "C" {
    pub fn g_str_match_string(
        search_term: *const gchar,
        potential_hit: *const gchar,
        accept_alternates: gboolean,
    ) -> gboolean;
}
extern "C" {
    pub fn g_strv_contains(strv: *const *const gchar, str_: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_strv_equal(strv1: *const *const gchar, strv2: *const *const gchar) -> gboolean;
}
pub const GNumberParserError_G_NUMBER_PARSER_ERROR_INVALID: GNumberParserError = 0;
pub const GNumberParserError_G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS: GNumberParserError = 1;
#[doc = " GNumberParserError:"]
#[doc = " @G_NUMBER_PARSER_ERROR_INVALID: String was not a valid number."]
#[doc = " @G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS: String was a number, but out of bounds."]
#[doc = ""]
#[doc = " Error codes returned by functions converting a string to a number."]
#[doc = ""]
#[doc = " Since: 2.54"]
pub type GNumberParserError = u32;
extern "C" {
    pub fn g_number_parser_error_quark() -> GQuark;
}
extern "C" {
    pub fn g_ascii_string_to_signed(
        str_: *const gchar,
        base: guint,
        min: gint64,
        max: gint64,
        out_num: *mut gint64,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_ascii_string_to_unsigned(
        str_: *const gchar,
        base: guint,
        min: guint64,
        max: guint64,
        out_num: *mut guint64,
        error: *mut *mut GError,
    ) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GStringChunk {
    _unused: [u8; 0],
}
pub type GStringChunk = _GStringChunk;
extern "C" {
    pub fn g_string_chunk_new(size: gsize) -> *mut GStringChunk;
}
extern "C" {
    pub fn g_string_chunk_free(chunk: *mut GStringChunk);
}
extern "C" {
    pub fn g_string_chunk_clear(chunk: *mut GStringChunk);
}
extern "C" {
    pub fn g_string_chunk_insert(chunk: *mut GStringChunk, string: *const gchar) -> *mut gchar;
}
extern "C" {
    pub fn g_string_chunk_insert_len(
        chunk: *mut GStringChunk,
        string: *const gchar,
        len: gssize,
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_string_chunk_insert_const(
        chunk: *mut GStringChunk,
        string: *const gchar,
    ) -> *mut gchar;
}
extern "C" {
    pub fn memcpy(
        __dest: *mut cty::c_void,
        __src: *const cty::c_void,
        __n: cty::c_ulong,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut cty::c_void,
        __src: *const cty::c_void,
        __n: cty::c_ulong,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut cty::c_void,
        __src: *const cty::c_void,
        __c: cty::c_int,
        __n: cty::c_ulong,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn memset(__s: *mut cty::c_void, __c: cty::c_int, __n: cty::c_ulong) -> *mut cty::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const cty::c_void,
        __s2: *const cty::c_void,
        __n: cty::c_ulong,
    ) -> cty::c_int;
}
extern "C" {
    pub fn memchr(__s: *const cty::c_void, __c: cty::c_int, __n: cty::c_ulong) -> *mut cty::c_void;
}
extern "C" {
    pub fn strcpy(__dest: *mut cty::c_char, __src: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut cty::c_char,
        __src: *const cty::c_char,
        __n: cty::c_ulong,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn strcat(__dest: *mut cty::c_char, __src: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut cty::c_char,
        __src: *const cty::c_char,
        __n: cty::c_ulong,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn strcmp(__s1: *const cty::c_char, __s2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const cty::c_char,
        __s2: *const cty::c_char,
        __n: cty::c_ulong,
    ) -> cty::c_int;
}
extern "C" {
    pub fn strcoll(__s1: *const cty::c_char, __s2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut cty::c_char,
        __src: *const cty::c_char,
        __n: cty::c_ulong,
    ) -> cty::c_ulong;
}
extern "C" {
    pub fn strcoll_l(
        __s1: *const cty::c_char,
        __s2: *const cty::c_char,
        __l: locale_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut cty::c_char,
        __src: *const cty::c_char,
        __n: size_t,
        __l: locale_t,
    ) -> size_t;
}
extern "C" {
    pub fn strdup(__s: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strndup(__string: *const cty::c_char, __n: cty::c_ulong) -> *mut cty::c_char;
}
extern "C" {
    pub fn strchr(__s: *const cty::c_char, __c: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn strrchr(__s: *const cty::c_char, __c: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn strcspn(__s: *const cty::c_char, __reject: *const cty::c_char) -> cty::c_ulong;
}
extern "C" {
    pub fn strspn(__s: *const cty::c_char, __accept: *const cty::c_char) -> cty::c_ulong;
}
extern "C" {
    pub fn strpbrk(__s: *const cty::c_char, __accept: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strstr(__haystack: *const cty::c_char, __needle: *const cty::c_char)
        -> *mut cty::c_char;
}
extern "C" {
    pub fn strtok(__s: *mut cty::c_char, __delim: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut cty::c_char,
        __delim: *const cty::c_char,
        __save_ptr: *mut *mut cty::c_char,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut cty::c_char,
        __delim: *const cty::c_char,
        __save_ptr: *mut *mut cty::c_char,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn strlen(__s: *const cty::c_char) -> cty::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const cty::c_char, __maxlen: size_t) -> size_t;
}
extern "C" {
    pub fn strerror(__errnum: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn strerror_r(
        __errnum: cty::c_int,
        __buf: *mut cty::c_char,
        __buflen: size_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn strerror_l(__errnum: cty::c_int, __l: locale_t) -> *mut cty::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const cty::c_void,
        __s2: *const cty::c_void,
        __n: cty::c_ulong,
    ) -> cty::c_int;
}
extern "C" {
    pub fn bcopy(__src: *const cty::c_void, __dest: *mut cty::c_void, __n: size_t);
}
extern "C" {
    pub fn bzero(__s: *mut cty::c_void, __n: cty::c_ulong);
}
extern "C" {
    pub fn index(__s: *const cty::c_char, __c: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn rindex(__s: *const cty::c_char, __c: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn ffs(__i: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn ffsl(__l: cty::c_long) -> cty::c_int;
}
extern "C" {
    pub fn ffsll(__ll: cty::c_longlong) -> cty::c_int;
}
extern "C" {
    pub fn strcasecmp(__s1: *const cty::c_char, __s2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const cty::c_char,
        __s2: *const cty::c_char,
        __n: cty::c_ulong,
    ) -> cty::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const cty::c_char,
        __s2: *const cty::c_char,
        __loc: locale_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const cty::c_char,
        __s2: *const cty::c_char,
        __n: size_t,
        __loc: locale_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut cty::c_void, __n: size_t);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut cty::c_char,
        __delim: *const cty::c_char,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn strsignal(__sig: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn __stpcpy(__dest: *mut cty::c_char, __src: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn stpcpy(__dest: *mut cty::c_char, __src: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut cty::c_char,
        __src: *const cty::c_char,
        __n: size_t,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut cty::c_char,
        __src: *const cty::c_char,
        __n: cty::c_ulong,
    ) -> *mut cty::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestCase {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestSuite {
    _unused: [u8; 0],
}
pub type GTestFunc = ::core::option::Option<unsafe extern "C" fn()>;
pub type GTestDataFunc = ::core::option::Option<unsafe extern "C" fn(user_data: gconstpointer)>;
pub type GTestFixtureFunc =
    ::core::option::Option<unsafe extern "C" fn(fixture: gpointer, user_data: gconstpointer)>;
extern "C" {
    pub fn g_strcmp0(str1: *const cty::c_char, str2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn g_test_minimized_result(minimized_quantity: f64, format: *const cty::c_char, ...);
}
extern "C" {
    pub fn g_test_maximized_result(maximized_quantity: f64, format: *const cty::c_char, ...);
}
extern "C" {
    pub fn g_test_init(argc: *mut cty::c_int, argv: *mut *mut *mut cty::c_char, ...);
}
extern "C" {
    pub fn g_test_subprocess() -> gboolean;
}
extern "C" {
    pub fn g_test_run() -> cty::c_int;
}
extern "C" {
    pub fn g_test_add_func(testpath: *const cty::c_char, test_func: GTestFunc);
}
extern "C" {
    pub fn g_test_add_data_func(
        testpath: *const cty::c_char,
        test_data: gconstpointer,
        test_func: GTestDataFunc,
    );
}
extern "C" {
    pub fn g_test_add_data_func_full(
        testpath: *const cty::c_char,
        test_data: gpointer,
        test_func: GTestDataFunc,
        data_free_func: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_test_fail();
}
extern "C" {
    pub fn g_test_incomplete(msg: *const gchar);
}
extern "C" {
    pub fn g_test_skip(msg: *const gchar);
}
extern "C" {
    pub fn g_test_failed() -> gboolean;
}
extern "C" {
    pub fn g_test_set_nonfatal_assertions();
}
extern "C" {
    pub fn g_test_message(format: *const cty::c_char, ...);
}
extern "C" {
    pub fn g_test_bug_base(uri_pattern: *const cty::c_char);
}
extern "C" {
    pub fn g_test_bug(bug_uri_snippet: *const cty::c_char);
}
extern "C" {
    pub fn g_test_summary(summary: *const cty::c_char);
}
extern "C" {
    pub fn g_test_timer_start();
}
extern "C" {
    pub fn g_test_timer_elapsed() -> f64;
}
extern "C" {
    pub fn g_test_timer_last() -> f64;
}
extern "C" {
    pub fn g_test_queue_free(gfree_pointer: gpointer);
}
extern "C" {
    pub fn g_test_queue_destroy(destroy_func: GDestroyNotify, destroy_data: gpointer);
}
pub const GTestTrapFlags_G_TEST_TRAP_SILENCE_STDOUT: GTestTrapFlags = 128;
pub const GTestTrapFlags_G_TEST_TRAP_SILENCE_STDERR: GTestTrapFlags = 256;
pub const GTestTrapFlags_G_TEST_TRAP_INHERIT_STDIN: GTestTrapFlags = 512;
#[doc = " GTestTrapFlags:"]
#[doc = " @G_TEST_TRAP_SILENCE_STDOUT: Redirect stdout of the test child to"]
#[doc = "     `/dev/null` so it cannot be observed on the console during test"]
#[doc = "     runs. The actual output is still captured though to allow later"]
#[doc = "     tests with g_test_trap_assert_stdout()."]
#[doc = " @G_TEST_TRAP_SILENCE_STDERR: Redirect stderr of the test child to"]
#[doc = "     `/dev/null` so it cannot be observed on the console during test"]
#[doc = "     runs. The actual output is still captured though to allow later"]
#[doc = "     tests with g_test_trap_assert_stderr()."]
#[doc = " @G_TEST_TRAP_INHERIT_STDIN: If this flag is given, stdin of the"]
#[doc = "     child process is shared with stdin of its parent process."]
#[doc = "     It is redirected to `/dev/null` otherwise."]
#[doc = ""]
#[doc = " Test traps are guards around forked tests."]
#[doc = " These flags determine what traps to set."]
#[doc = ""]
#[doc = " Deprecated: 2.38: #GTestTrapFlags is used only with g_test_trap_fork(),"]
#[doc = " which is deprecated. g_test_trap_subprocess() uses"]
#[doc = " #GTestSubprocessFlags."]
pub type GTestTrapFlags = u32;
extern "C" {
    pub fn g_test_trap_fork(usec_timeout: guint64, test_trap_flags: GTestTrapFlags) -> gboolean;
}
pub const GTestSubprocessFlags_G_TEST_SUBPROCESS_INHERIT_STDIN: GTestSubprocessFlags = 1;
pub const GTestSubprocessFlags_G_TEST_SUBPROCESS_INHERIT_STDOUT: GTestSubprocessFlags = 2;
pub const GTestSubprocessFlags_G_TEST_SUBPROCESS_INHERIT_STDERR: GTestSubprocessFlags = 4;
pub type GTestSubprocessFlags = u32;
extern "C" {
    pub fn g_test_trap_subprocess(
        test_path: *const cty::c_char,
        usec_timeout: guint64,
        test_flags: GTestSubprocessFlags,
    );
}
extern "C" {
    pub fn g_test_trap_has_passed() -> gboolean;
}
extern "C" {
    pub fn g_test_trap_reached_timeout() -> gboolean;
}
extern "C" {
    pub fn g_test_rand_int() -> gint32;
}
extern "C" {
    pub fn g_test_rand_int_range(begin: gint32, end: gint32) -> gint32;
}
extern "C" {
    pub fn g_test_rand_double() -> f64;
}
extern "C" {
    pub fn g_test_rand_double_range(range_start: f64, range_end: f64) -> f64;
}
extern "C" {
    pub fn g_test_create_case(
        test_name: *const cty::c_char,
        data_size: gsize,
        test_data: gconstpointer,
        data_setup: GTestFixtureFunc,
        data_test: GTestFixtureFunc,
        data_teardown: GTestFixtureFunc,
    ) -> *mut GTestCase;
}
extern "C" {
    pub fn g_test_create_suite(suite_name: *const cty::c_char) -> *mut GTestSuite;
}
extern "C" {
    pub fn g_test_get_root() -> *mut GTestSuite;
}
extern "C" {
    pub fn g_test_suite_add(suite: *mut GTestSuite, test_case: *mut GTestCase);
}
extern "C" {
    pub fn g_test_suite_add_suite(suite: *mut GTestSuite, nestedsuite: *mut GTestSuite);
}
extern "C" {
    pub fn g_test_run_suite(suite: *mut GTestSuite) -> cty::c_int;
}
extern "C" {
    pub fn g_test_trap_assertions(
        domain: *const cty::c_char,
        file: *const cty::c_char,
        line: cty::c_int,
        func: *const cty::c_char,
        assertion_flags: guint64,
        pattern: *const cty::c_char,
    );
}
extern "C" {
    pub fn g_assertion_message(
        domain: *const cty::c_char,
        file: *const cty::c_char,
        line: cty::c_int,
        func: *const cty::c_char,
        message: *const cty::c_char,
    );
}
extern "C" {
    pub fn g_assertion_message_expr(
        domain: *const cty::c_char,
        file: *const cty::c_char,
        line: cty::c_int,
        func: *const cty::c_char,
        expr: *const cty::c_char,
    );
}
extern "C" {
    pub fn g_assertion_message_cmpstr(
        domain: *const cty::c_char,
        file: *const cty::c_char,
        line: cty::c_int,
        func: *const cty::c_char,
        expr: *const cty::c_char,
        arg1: *const cty::c_char,
        cmp: *const cty::c_char,
        arg2: *const cty::c_char,
    );
}
extern "C" {
    pub fn g_assertion_message_cmpnum(
        domain: *const cty::c_char,
        file: *const cty::c_char,
        line: cty::c_int,
        func: *const cty::c_char,
        expr: *const cty::c_char,
        arg1: u128,
        cmp: *const cty::c_char,
        arg2: u128,
        numtype: cty::c_char,
    );
}
extern "C" {
    pub fn g_assertion_message_error(
        domain: *const cty::c_char,
        file: *const cty::c_char,
        line: cty::c_int,
        func: *const cty::c_char,
        expr: *const cty::c_char,
        error: *const GError,
        error_domain: GQuark,
        error_code: cty::c_int,
    );
}
extern "C" {
    pub fn g_test_add_vtable(
        testpath: *const cty::c_char,
        data_size: gsize,
        test_data: gconstpointer,
        data_setup: GTestFixtureFunc,
        data_test: GTestFixtureFunc,
        data_teardown: GTestFixtureFunc,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestConfig {
    pub test_initialized: gboolean,
    pub test_quick: gboolean,
    pub test_perf: gboolean,
    pub test_verbose: gboolean,
    pub test_quiet: gboolean,
    pub test_undefined: gboolean,
}
#[test]
fn bindgen_test_layout_GTestConfig() {
    assert_eq!(
        ::core::mem::size_of::<GTestConfig>(),
        24usize,
        concat!("Size of: ", stringify!(GTestConfig))
    );
    assert_eq!(
        ::core::mem::align_of::<GTestConfig>(),
        4usize,
        concat!("Alignment of ", stringify!(GTestConfig))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GTestConfig>())).test_initialized as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestConfig),
            "::",
            stringify!(test_initialized)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GTestConfig>())).test_quick as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestConfig),
            "::",
            stringify!(test_quick)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GTestConfig>())).test_perf as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestConfig),
            "::",
            stringify!(test_perf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GTestConfig>())).test_verbose as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestConfig),
            "::",
            stringify!(test_verbose)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GTestConfig>())).test_quiet as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestConfig),
            "::",
            stringify!(test_quiet)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GTestConfig>())).test_undefined as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestConfig),
            "::",
            stringify!(test_undefined)
        )
    );
}
extern "C" {
    pub static g_test_config_vars: *const GTestConfig;
}
pub const GTestResult_G_TEST_RUN_SUCCESS: GTestResult = 0;
pub const GTestResult_G_TEST_RUN_SKIPPED: GTestResult = 1;
pub const GTestResult_G_TEST_RUN_FAILURE: GTestResult = 2;
pub const GTestResult_G_TEST_RUN_INCOMPLETE: GTestResult = 3;
pub type GTestResult = u32;
pub const GTestLogType_G_TEST_LOG_NONE: GTestLogType = 0;
pub const GTestLogType_G_TEST_LOG_ERROR: GTestLogType = 1;
pub const GTestLogType_G_TEST_LOG_START_BINARY: GTestLogType = 2;
pub const GTestLogType_G_TEST_LOG_LIST_CASE: GTestLogType = 3;
pub const GTestLogType_G_TEST_LOG_SKIP_CASE: GTestLogType = 4;
pub const GTestLogType_G_TEST_LOG_START_CASE: GTestLogType = 5;
pub const GTestLogType_G_TEST_LOG_STOP_CASE: GTestLogType = 6;
pub const GTestLogType_G_TEST_LOG_MIN_RESULT: GTestLogType = 7;
pub const GTestLogType_G_TEST_LOG_MAX_RESULT: GTestLogType = 8;
pub const GTestLogType_G_TEST_LOG_MESSAGE: GTestLogType = 9;
pub const GTestLogType_G_TEST_LOG_START_SUITE: GTestLogType = 10;
pub const GTestLogType_G_TEST_LOG_STOP_SUITE: GTestLogType = 11;
pub type GTestLogType = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestLogMsg {
    pub log_type: GTestLogType,
    pub n_strings: guint,
    pub strings: *mut *mut gchar,
    pub n_nums: guint,
    pub nums: *mut u128,
}
#[test]
fn bindgen_test_layout_GTestLogMsg() {
    assert_eq!(
        ::core::mem::size_of::<GTestLogMsg>(),
        32usize,
        concat!("Size of: ", stringify!(GTestLogMsg))
    );
    assert_eq!(
        ::core::mem::align_of::<GTestLogMsg>(),
        8usize,
        concat!("Alignment of ", stringify!(GTestLogMsg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GTestLogMsg>())).log_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestLogMsg),
            "::",
            stringify!(log_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GTestLogMsg>())).n_strings as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestLogMsg),
            "::",
            stringify!(n_strings)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GTestLogMsg>())).strings as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestLogMsg),
            "::",
            stringify!(strings)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GTestLogMsg>())).n_nums as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestLogMsg),
            "::",
            stringify!(n_nums)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GTestLogMsg>())).nums as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestLogMsg),
            "::",
            stringify!(nums)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestLogBuffer {
    pub data: *mut GString,
    pub msgs: *mut GSList,
}
#[test]
fn bindgen_test_layout_GTestLogBuffer() {
    assert_eq!(
        ::core::mem::size_of::<GTestLogBuffer>(),
        16usize,
        concat!("Size of: ", stringify!(GTestLogBuffer))
    );
    assert_eq!(
        ::core::mem::align_of::<GTestLogBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(GTestLogBuffer))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GTestLogBuffer>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestLogBuffer),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GTestLogBuffer>())).msgs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestLogBuffer),
            "::",
            stringify!(msgs)
        )
    );
}
extern "C" {
    pub fn g_test_log_type_name(log_type: GTestLogType) -> *const cty::c_char;
}
extern "C" {
    pub fn g_test_log_buffer_new() -> *mut GTestLogBuffer;
}
extern "C" {
    pub fn g_test_log_buffer_free(tbuffer: *mut GTestLogBuffer);
}
extern "C" {
    pub fn g_test_log_buffer_push(
        tbuffer: *mut GTestLogBuffer,
        n_bytes: guint,
        bytes: *const guint8,
    );
}
extern "C" {
    pub fn g_test_log_buffer_pop(tbuffer: *mut GTestLogBuffer) -> *mut GTestLogMsg;
}
extern "C" {
    pub fn g_test_log_msg_free(tmsg: *mut GTestLogMsg);
}
#[doc = " GTestLogFatalFunc:"]
#[doc = " @log_domain: the log domain of the message"]
#[doc = " @log_level: the log level of the message (including the fatal and recursion flags)"]
#[doc = " @message: the message to process"]
#[doc = " @user_data: user data, set in g_test_log_set_fatal_handler()"]
#[doc = ""]
#[doc = " Specifies the prototype of fatal log handler functions."]
#[doc = ""]
#[doc = " Returns: %TRUE if the program should abort, %FALSE otherwise"]
#[doc = ""]
#[doc = " Since: 2.22"]
pub type GTestLogFatalFunc = ::core::option::Option<
    unsafe extern "C" fn(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        message: *const gchar,
        user_data: gpointer,
    ) -> gboolean,
>;
extern "C" {
    pub fn g_test_log_set_fatal_handler(log_func: GTestLogFatalFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_test_expect_message(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        pattern: *const gchar,
    );
}
extern "C" {
    pub fn g_test_assert_expected_messages_internal(
        domain: *const cty::c_char,
        file: *const cty::c_char,
        line: cty::c_int,
        func: *const cty::c_char,
    );
}
pub const GTestFileType_G_TEST_DIST: GTestFileType = 0;
pub const GTestFileType_G_TEST_BUILT: GTestFileType = 1;
pub type GTestFileType = u32;
extern "C" {
    pub fn g_test_build_filename(
        file_type: GTestFileType,
        first_path: *const gchar,
        ...
    ) -> *mut gchar;
}
extern "C" {
    pub fn g_test_get_dir(file_type: GTestFileType) -> *const gchar;
}
extern "C" {
    pub fn g_test_get_filename(
        file_type: GTestFileType,
        first_path: *const gchar,
        ...
    ) -> *const gchar;
}
pub type GThreadPool = _GThreadPool;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GThreadPool {
    pub func: GFunc,
    pub user_data: gpointer,
    pub exclusive: gboolean,
}
#[test]
fn bindgen_test_layout__GThreadPool() {
    assert_eq!(
        ::core::mem::size_of::<_GThreadPool>(),
        24usize,
        concat!("Size of: ", stringify!(_GThreadPool))
    );
    assert_eq!(
        ::core::mem::align_of::<_GThreadPool>(),
        8usize,
        concat!("Alignment of ", stringify!(_GThreadPool))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GThreadPool>())).func as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadPool),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GThreadPool>())).user_data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadPool),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GThreadPool>())).exclusive as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadPool),
            "::",
            stringify!(exclusive)
        )
    );
}
extern "C" {
    pub fn g_thread_pool_new(
        func: GFunc,
        user_data: gpointer,
        max_threads: gint,
        exclusive: gboolean,
        error: *mut *mut GError,
    ) -> *mut GThreadPool;
}
extern "C" {
    pub fn g_thread_pool_free(pool: *mut GThreadPool, immediate: gboolean, wait_: gboolean);
}
extern "C" {
    pub fn g_thread_pool_push(
        pool: *mut GThreadPool,
        data: gpointer,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_thread_pool_unprocessed(pool: *mut GThreadPool) -> guint;
}
extern "C" {
    pub fn g_thread_pool_set_sort_function(
        pool: *mut GThreadPool,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_thread_pool_move_to_front(pool: *mut GThreadPool, data: gpointer) -> gboolean;
}
extern "C" {
    pub fn g_thread_pool_set_max_threads(
        pool: *mut GThreadPool,
        max_threads: gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn g_thread_pool_get_max_threads(pool: *mut GThreadPool) -> gint;
}
extern "C" {
    pub fn g_thread_pool_get_num_threads(pool: *mut GThreadPool) -> guint;
}
extern "C" {
    pub fn g_thread_pool_set_max_unused_threads(max_threads: gint);
}
extern "C" {
    pub fn g_thread_pool_get_max_unused_threads() -> gint;
}
extern "C" {
    pub fn g_thread_pool_get_num_unused_threads() -> guint;
}
extern "C" {
    pub fn g_thread_pool_stop_unused_threads();
}
extern "C" {
    pub fn g_thread_pool_set_max_idle_time(interval: guint);
}
extern "C" {
    pub fn g_thread_pool_get_max_idle_time() -> guint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTimer {
    _unused: [u8; 0],
}
pub type GTimer = _GTimer;
extern "C" {
    pub fn g_timer_new() -> *mut GTimer;
}
extern "C" {
    pub fn g_timer_destroy(timer: *mut GTimer);
}
extern "C" {
    pub fn g_timer_start(timer: *mut GTimer);
}
extern "C" {
    pub fn g_timer_stop(timer: *mut GTimer);
}
extern "C" {
    pub fn g_timer_reset(timer: *mut GTimer);
}
extern "C" {
    pub fn g_timer_continue(timer: *mut GTimer);
}
extern "C" {
    pub fn g_timer_elapsed(timer: *mut GTimer, microseconds: *mut gulong) -> gdouble;
}
extern "C" {
    pub fn g_timer_is_active(timer: *mut GTimer) -> gboolean;
}
extern "C" {
    pub fn g_usleep(microseconds: gulong);
}
extern "C" {
    pub fn g_time_val_add(time_: *mut GTimeVal, microseconds: glong);
}
extern "C" {
    pub fn g_time_val_from_iso8601(iso_date: *const gchar, time_: *mut GTimeVal) -> gboolean;
}
extern "C" {
    pub fn g_time_val_to_iso8601(time_: *mut GTimeVal) -> *mut gchar;
}
pub type GTrashStack = _GTrashStack;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTrashStack {
    pub next: *mut GTrashStack,
}
#[test]
fn bindgen_test_layout__GTrashStack() {
    assert_eq!(
        ::core::mem::size_of::<_GTrashStack>(),
        8usize,
        concat!("Size of: ", stringify!(_GTrashStack))
    );
    assert_eq!(
        ::core::mem::align_of::<_GTrashStack>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTrashStack))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GTrashStack>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTrashStack),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    pub fn g_trash_stack_push(stack_p: *mut *mut GTrashStack, data_p: gpointer);
}
extern "C" {
    pub fn g_trash_stack_pop(stack_p: *mut *mut GTrashStack) -> gpointer;
}
extern "C" {
    pub fn g_trash_stack_peek(stack_p: *mut *mut GTrashStack) -> gpointer;
}
extern "C" {
    pub fn g_trash_stack_height(stack_p: *mut *mut GTrashStack) -> guint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTree {
    _unused: [u8; 0],
}
pub type GTree = _GTree;
pub type GTraverseFunc = ::core::option::Option<
    unsafe extern "C" fn(key: gpointer, value: gpointer, data: gpointer) -> gboolean,
>;
extern "C" {
    pub fn g_tree_new(key_compare_func: GCompareFunc) -> *mut GTree;
}
extern "C" {
    pub fn g_tree_new_with_data(
        key_compare_func: GCompareDataFunc,
        key_compare_data: gpointer,
    ) -> *mut GTree;
}
extern "C" {
    pub fn g_tree_new_full(
        key_compare_func: GCompareDataFunc,
        key_compare_data: gpointer,
        key_destroy_func: GDestroyNotify,
        value_destroy_func: GDestroyNotify,
    ) -> *mut GTree;
}
extern "C" {
    pub fn g_tree_ref(tree: *mut GTree) -> *mut GTree;
}
extern "C" {
    pub fn g_tree_unref(tree: *mut GTree);
}
extern "C" {
    pub fn g_tree_destroy(tree: *mut GTree);
}
extern "C" {
    pub fn g_tree_insert(tree: *mut GTree, key: gpointer, value: gpointer);
}
extern "C" {
    pub fn g_tree_replace(tree: *mut GTree, key: gpointer, value: gpointer);
}
extern "C" {
    pub fn g_tree_remove(tree: *mut GTree, key: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_tree_steal(tree: *mut GTree, key: gconstpointer) -> gboolean;
}
extern "C" {
    pub fn g_tree_lookup(tree: *mut GTree, key: gconstpointer) -> gpointer;
}
extern "C" {
    pub fn g_tree_lookup_extended(
        tree: *mut GTree,
        lookup_key: gconstpointer,
        orig_key: *mut gpointer,
        value: *mut gpointer,
    ) -> gboolean;
}
extern "C" {
    pub fn g_tree_foreach(tree: *mut GTree, func: GTraverseFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_tree_traverse(
        tree: *mut GTree,
        traverse_func: GTraverseFunc,
        traverse_type: GTraverseType,
        user_data: gpointer,
    );
}
extern "C" {
    pub fn g_tree_search(
        tree: *mut GTree,
        search_func: GCompareFunc,
        user_data: gconstpointer,
    ) -> gpointer;
}
extern "C" {
    pub fn g_tree_height(tree: *mut GTree) -> gint;
}
extern "C" {
    pub fn g_tree_nnodes(tree: *mut GTree) -> gint;
}
extern "C" {
    pub fn g_uri_unescape_string(
        escaped_string: *const cty::c_char,
        illegal_characters: *const cty::c_char,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn g_uri_unescape_segment(
        escaped_string: *const cty::c_char,
        escaped_string_end: *const cty::c_char,
        illegal_characters: *const cty::c_char,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn g_uri_parse_scheme(uri: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn g_uri_escape_string(
        unescaped: *const cty::c_char,
        reserved_chars_allowed: *const cty::c_char,
        allow_utf8: gboolean,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn g_uuid_string_is_valid(str_: *const gchar) -> gboolean;
}
extern "C" {
    pub fn g_uuid_string_random() -> *mut gchar;
}
extern "C" {
    pub static glib_major_version: guint;
}
extern "C" {
    pub static glib_minor_version: guint;
}
extern "C" {
    pub static glib_micro_version: guint;
}
extern "C" {
    pub static glib_interface_age: guint;
}
extern "C" {
    pub static glib_binary_age: guint;
}
extern "C" {
    pub fn glib_check_version(
        required_major: guint,
        required_minor: guint,
        required_micro: guint,
    ) -> *const gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAllocator {
    _unused: [u8; 0],
}
pub type GAllocator = _GAllocator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMemChunk {
    _unused: [u8; 0],
}
pub type GMemChunk = _GMemChunk;
extern "C" {
    pub fn g_mem_chunk_new(
        name: *const gchar,
        atom_size: gint,
        area_size: gsize,
        type_: gint,
    ) -> *mut GMemChunk;
}
extern "C" {
    pub fn g_mem_chunk_destroy(mem_chunk: *mut GMemChunk);
}
extern "C" {
    pub fn g_mem_chunk_alloc(mem_chunk: *mut GMemChunk) -> gpointer;
}
extern "C" {
    pub fn g_mem_chunk_alloc0(mem_chunk: *mut GMemChunk) -> gpointer;
}
extern "C" {
    pub fn g_mem_chunk_free(mem_chunk: *mut GMemChunk, mem: gpointer);
}
extern "C" {
    pub fn g_mem_chunk_clean(mem_chunk: *mut GMemChunk);
}
extern "C" {
    pub fn g_mem_chunk_reset(mem_chunk: *mut GMemChunk);
}
extern "C" {
    pub fn g_mem_chunk_print(mem_chunk: *mut GMemChunk);
}
extern "C" {
    pub fn g_mem_chunk_info();
}
extern "C" {
    pub fn g_blow_chunks();
}
extern "C" {
    pub fn g_allocator_new(name: *const gchar, n_preallocs: guint) -> *mut GAllocator;
}
extern "C" {
    pub fn g_allocator_free(allocator: *mut GAllocator);
}
extern "C" {
    pub fn g_list_push_allocator(allocator: *mut GAllocator);
}
extern "C" {
    pub fn g_list_pop_allocator();
}
extern "C" {
    pub fn g_slist_push_allocator(allocator: *mut GAllocator);
}
extern "C" {
    pub fn g_slist_pop_allocator();
}
extern "C" {
    pub fn g_node_push_allocator(allocator: *mut GAllocator);
}
extern "C" {
    pub fn g_node_pop_allocator();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCache {
    _unused: [u8; 0],
}
pub type GCache = _GCache;
pub type GCacheNewFunc = ::core::option::Option<unsafe extern "C" fn(key: gpointer) -> gpointer>;
pub type GCacheDupFunc = ::core::option::Option<unsafe extern "C" fn(value: gpointer) -> gpointer>;
pub type GCacheDestroyFunc = ::core::option::Option<unsafe extern "C" fn(value: gpointer)>;
extern "C" {
    pub fn g_cache_new(
        value_new_func: GCacheNewFunc,
        value_destroy_func: GCacheDestroyFunc,
        key_dup_func: GCacheDupFunc,
        key_destroy_func: GCacheDestroyFunc,
        hash_key_func: GHashFunc,
        hash_value_func: GHashFunc,
        key_equal_func: GEqualFunc,
    ) -> *mut GCache;
}
extern "C" {
    pub fn g_cache_destroy(cache: *mut GCache);
}
extern "C" {
    pub fn g_cache_insert(cache: *mut GCache, key: gpointer) -> gpointer;
}
extern "C" {
    pub fn g_cache_remove(cache: *mut GCache, value: gconstpointer);
}
extern "C" {
    pub fn g_cache_key_foreach(cache: *mut GCache, func: GHFunc, user_data: gpointer);
}
extern "C" {
    pub fn g_cache_value_foreach(cache: *mut GCache, func: GHFunc, user_data: gpointer);
}
pub type GCompletion = _GCompletion;
pub type GCompletionFunc =
    ::core::option::Option<unsafe extern "C" fn(arg1: gpointer) -> *mut gchar>;
pub type GCompletionStrncmpFunc = ::core::option::Option<
    unsafe extern "C" fn(s1: *const gchar, s2: *const gchar, n: gsize) -> gint,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCompletion {
    pub items: *mut GList,
    pub func: GCompletionFunc,
    pub prefix: *mut gchar,
    pub cache: *mut GList,
    pub strncmp_func: GCompletionStrncmpFunc,
}
#[test]
fn bindgen_test_layout__GCompletion() {
    assert_eq!(
        ::core::mem::size_of::<_GCompletion>(),
        40usize,
        concat!("Size of: ", stringify!(_GCompletion))
    );
    assert_eq!(
        ::core::mem::align_of::<_GCompletion>(),
        8usize,
        concat!("Alignment of ", stringify!(_GCompletion))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GCompletion>())).items as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCompletion),
            "::",
            stringify!(items)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GCompletion>())).func as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCompletion),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GCompletion>())).prefix as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCompletion),
            "::",
            stringify!(prefix)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GCompletion>())).cache as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCompletion),
            "::",
            stringify!(cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GCompletion>())).strncmp_func as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCompletion),
            "::",
            stringify!(strncmp_func)
        )
    );
}
extern "C" {
    pub fn g_completion_new(func: GCompletionFunc) -> *mut GCompletion;
}
extern "C" {
    pub fn g_completion_add_items(cmp: *mut GCompletion, items: *mut GList);
}
extern "C" {
    pub fn g_completion_remove_items(cmp: *mut GCompletion, items: *mut GList);
}
extern "C" {
    pub fn g_completion_clear_items(cmp: *mut GCompletion);
}
extern "C" {
    pub fn g_completion_complete(
        cmp: *mut GCompletion,
        prefix: *const gchar,
        new_prefix: *mut *mut gchar,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_completion_complete_utf8(
        cmp: *mut GCompletion,
        prefix: *const gchar,
        new_prefix: *mut *mut gchar,
    ) -> *mut GList;
}
extern "C" {
    pub fn g_completion_set_compare(cmp: *mut GCompletion, strncmp_func: GCompletionStrncmpFunc);
}
extern "C" {
    pub fn g_completion_free(cmp: *mut GCompletion);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRelation {
    _unused: [u8; 0],
}
pub type GRelation = _GRelation;
pub type GTuples = _GTuples;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTuples {
    pub len: guint,
}
#[test]
fn bindgen_test_layout__GTuples() {
    assert_eq!(
        ::core::mem::size_of::<_GTuples>(),
        4usize,
        concat!("Size of: ", stringify!(_GTuples))
    );
    assert_eq!(
        ::core::mem::align_of::<_GTuples>(),
        4usize,
        concat!("Alignment of ", stringify!(_GTuples))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GTuples>())).len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTuples),
            "::",
            stringify!(len)
        )
    );
}
extern "C" {
    pub fn g_relation_new(fields: gint) -> *mut GRelation;
}
extern "C" {
    pub fn g_relation_destroy(relation: *mut GRelation);
}
extern "C" {
    pub fn g_relation_index(
        relation: *mut GRelation,
        field: gint,
        hash_func: GHashFunc,
        key_equal_func: GEqualFunc,
    );
}
extern "C" {
    pub fn g_relation_insert(relation: *mut GRelation, ...);
}
extern "C" {
    pub fn g_relation_delete(relation: *mut GRelation, key: gconstpointer, field: gint) -> gint;
}
extern "C" {
    pub fn g_relation_select(
        relation: *mut GRelation,
        key: gconstpointer,
        field: gint,
    ) -> *mut GTuples;
}
extern "C" {
    pub fn g_relation_count(relation: *mut GRelation, key: gconstpointer, field: gint) -> gint;
}
extern "C" {
    pub fn g_relation_exists(relation: *mut GRelation, ...) -> gboolean;
}
extern "C" {
    pub fn g_relation_print(relation: *mut GRelation);
}
extern "C" {
    pub fn g_tuples_destroy(tuples: *mut GTuples);
}
extern "C" {
    pub fn g_tuples_index(tuples: *mut GTuples, index_: gint, field: gint) -> gpointer;
}
pub const GThreadPriority_G_THREAD_PRIORITY_LOW: GThreadPriority = 0;
pub const GThreadPriority_G_THREAD_PRIORITY_NORMAL: GThreadPriority = 1;
pub const GThreadPriority_G_THREAD_PRIORITY_HIGH: GThreadPriority = 2;
pub const GThreadPriority_G_THREAD_PRIORITY_URGENT: GThreadPriority = 3;
pub type GThreadPriority = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GThread {
    pub func: GThreadFunc,
    pub data: gpointer,
    pub joinable: gboolean,
    pub priority: GThreadPriority,
}
#[test]
fn bindgen_test_layout__GThread() {
    assert_eq!(
        ::core::mem::size_of::<_GThread>(),
        24usize,
        concat!("Size of: ", stringify!(_GThread))
    );
    assert_eq!(
        ::core::mem::align_of::<_GThread>(),
        8usize,
        concat!("Alignment of ", stringify!(_GThread))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GThread>())).func as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThread),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GThread>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThread),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GThread>())).joinable as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThread),
            "::",
            stringify!(joinable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GThread>())).priority as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThread),
            "::",
            stringify!(priority)
        )
    );
}
pub type GThreadFunctions = _GThreadFunctions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GThreadFunctions {
    pub mutex_new: ::core::option::Option<unsafe extern "C" fn() -> *mut GMutex>,
    pub mutex_lock: ::core::option::Option<unsafe extern "C" fn(mutex: *mut GMutex)>,
    pub mutex_trylock: ::core::option::Option<unsafe extern "C" fn(mutex: *mut GMutex) -> gboolean>,
    pub mutex_unlock: ::core::option::Option<unsafe extern "C" fn(mutex: *mut GMutex)>,
    pub mutex_free: ::core::option::Option<unsafe extern "C" fn(mutex: *mut GMutex)>,
    pub cond_new: ::core::option::Option<unsafe extern "C" fn() -> *mut GCond>,
    pub cond_signal: ::core::option::Option<unsafe extern "C" fn(cond: *mut GCond)>,
    pub cond_broadcast: ::core::option::Option<unsafe extern "C" fn(cond: *mut GCond)>,
    pub cond_wait:
        ::core::option::Option<unsafe extern "C" fn(cond: *mut GCond, mutex: *mut GMutex)>,
    pub cond_timed_wait: ::core::option::Option<
        unsafe extern "C" fn(
            cond: *mut GCond,
            mutex: *mut GMutex,
            end_time: *mut GTimeVal,
        ) -> gboolean,
    >,
    pub cond_free: ::core::option::Option<unsafe extern "C" fn(cond: *mut GCond)>,
    pub private_new:
        ::core::option::Option<unsafe extern "C" fn(destructor: GDestroyNotify) -> *mut GPrivate>,
    pub private_get:
        ::core::option::Option<unsafe extern "C" fn(private_key: *mut GPrivate) -> gpointer>,
    pub private_set:
        ::core::option::Option<unsafe extern "C" fn(private_key: *mut GPrivate, data: gpointer)>,
    pub thread_create: ::core::option::Option<
        unsafe extern "C" fn(
            func: GThreadFunc,
            data: gpointer,
            stack_size: gulong,
            joinable: gboolean,
            bound: gboolean,
            priority: GThreadPriority,
            thread: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub thread_yield: ::core::option::Option<unsafe extern "C" fn()>,
    pub thread_join: ::core::option::Option<unsafe extern "C" fn(thread: gpointer)>,
    pub thread_exit: ::core::option::Option<unsafe extern "C" fn()>,
    pub thread_set_priority:
        ::core::option::Option<unsafe extern "C" fn(thread: gpointer, priority: GThreadPriority)>,
    pub thread_self: ::core::option::Option<unsafe extern "C" fn(thread: gpointer)>,
    pub thread_equal: ::core::option::Option<
        unsafe extern "C" fn(thread1: gpointer, thread2: gpointer) -> gboolean,
    >,
}
#[test]
fn bindgen_test_layout__GThreadFunctions() {
    assert_eq!(
        ::core::mem::size_of::<_GThreadFunctions>(),
        168usize,
        concat!("Size of: ", stringify!(_GThreadFunctions))
    );
    assert_eq!(
        ::core::mem::align_of::<_GThreadFunctions>(),
        8usize,
        concat!("Alignment of ", stringify!(_GThreadFunctions))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GThreadFunctions>())).mutex_new as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(mutex_new)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GThreadFunctions>())).mutex_lock as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(mutex_lock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_GThreadFunctions>())).mutex_trylock as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(mutex_trylock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GThreadFunctions>())).mutex_unlock as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(mutex_unlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GThreadFunctions>())).mutex_free as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(mutex_free)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GThreadFunctions>())).cond_new as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(cond_new)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GThreadFunctions>())).cond_signal as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(cond_signal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_GThreadFunctions>())).cond_broadcast as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(cond_broadcast)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GThreadFunctions>())).cond_wait as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(cond_wait)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_GThreadFunctions>())).cond_timed_wait as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(cond_timed_wait)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GThreadFunctions>())).cond_free as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(cond_free)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GThreadFunctions>())).private_new as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(private_new)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GThreadFunctions>())).private_get as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(private_get)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GThreadFunctions>())).private_set as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(private_set)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_GThreadFunctions>())).thread_create as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(thread_create)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GThreadFunctions>())).thread_yield as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(thread_yield)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GThreadFunctions>())).thread_join as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(thread_join)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GThreadFunctions>())).thread_exit as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(thread_exit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_GThreadFunctions>())).thread_set_priority as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(thread_set_priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GThreadFunctions>())).thread_self as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(thread_self)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GThreadFunctions>())).thread_equal as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(thread_equal)
        )
    );
}
extern "C" {
    pub static mut g_thread_functions_for_glib_use: GThreadFunctions;
}
extern "C" {
    pub static mut g_thread_use_default_impl: gboolean;
}
extern "C" {
    pub static mut g_thread_gettime: ::core::option::Option<unsafe extern "C" fn() -> guint64>;
}
extern "C" {
    pub fn g_thread_create(
        func: GThreadFunc,
        data: gpointer,
        joinable: gboolean,
        error: *mut *mut GError,
    ) -> *mut GThread;
}
extern "C" {
    pub fn g_thread_create_full(
        func: GThreadFunc,
        data: gpointer,
        stack_size: gulong,
        joinable: gboolean,
        bound: gboolean,
        priority: GThreadPriority,
        error: *mut *mut GError,
    ) -> *mut GThread;
}
extern "C" {
    pub fn g_thread_set_priority(thread: *mut GThread, priority: GThreadPriority);
}
extern "C" {
    pub fn g_thread_foreach(thread_func: GFunc, user_data: gpointer);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: cty::c_int,
}
#[test]
fn bindgen_test_layout_sched_param() {
    assert_eq!(
        ::core::mem::size_of::<sched_param>(),
        4usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::core::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_param>())).sched_priority as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(sched_priority)
        )
    );
}
pub type __cpu_mask = cty::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_set_t {
    pub __bits: [__cpu_mask; 16usize],
}
#[test]
fn bindgen_test_layout_cpu_set_t() {
    assert_eq!(
        ::core::mem::size_of::<cpu_set_t>(),
        128usize,
        concat!("Size of: ", stringify!(cpu_set_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cpu_set_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_set_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpu_set_t>())).__bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_set_t),
            "::",
            stringify!(__bits)
        )
    );
}
extern "C" {
    pub fn __sched_cpucount(__setsize: size_t, __setp: *const cpu_set_t) -> cty::c_int;
}
extern "C" {
    pub fn __sched_cpualloc(__count: size_t) -> *mut cpu_set_t;
}
extern "C" {
    pub fn __sched_cpufree(__set: *mut cpu_set_t);
}
extern "C" {
    pub fn sched_setparam(__pid: __pid_t, __param: *const sched_param) -> cty::c_int;
}
extern "C" {
    pub fn sched_getparam(__pid: __pid_t, __param: *mut sched_param) -> cty::c_int;
}
extern "C" {
    pub fn sched_setscheduler(
        __pid: __pid_t,
        __policy: cty::c_int,
        __param: *const sched_param,
    ) -> cty::c_int;
}
extern "C" {
    pub fn sched_getscheduler(__pid: __pid_t) -> cty::c_int;
}
extern "C" {
    pub fn sched_yield() -> cty::c_int;
}
extern "C" {
    pub fn sched_get_priority_max(__algorithm: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn sched_get_priority_min(__algorithm: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn sched_rr_get_interval(__pid: __pid_t, __t: *mut timespec) -> cty::c_int;
}
pub type __jmp_buf = [cty::c_long; 8usize];
pub const PTHREAD_CREATE_JOINABLE: _bindgen_ty_11 = 0;
pub const PTHREAD_CREATE_DETACHED: _bindgen_ty_11 = 1;
pub type _bindgen_ty_11 = u32;
pub const PTHREAD_MUTEX_TIMED_NP: _bindgen_ty_12 = 0;
pub const PTHREAD_MUTEX_RECURSIVE_NP: _bindgen_ty_12 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK_NP: _bindgen_ty_12 = 2;
pub const PTHREAD_MUTEX_ADAPTIVE_NP: _bindgen_ty_12 = 3;
pub const PTHREAD_MUTEX_NORMAL: _bindgen_ty_12 = 0;
pub const PTHREAD_MUTEX_RECURSIVE: _bindgen_ty_12 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK: _bindgen_ty_12 = 2;
pub const PTHREAD_MUTEX_DEFAULT: _bindgen_ty_12 = 0;
pub type _bindgen_ty_12 = u32;
pub const PTHREAD_MUTEX_STALLED: _bindgen_ty_13 = 0;
pub const PTHREAD_MUTEX_STALLED_NP: _bindgen_ty_13 = 0;
pub const PTHREAD_MUTEX_ROBUST: _bindgen_ty_13 = 1;
pub const PTHREAD_MUTEX_ROBUST_NP: _bindgen_ty_13 = 1;
pub type _bindgen_ty_13 = u32;
pub const PTHREAD_PRIO_NONE: _bindgen_ty_14 = 0;
pub const PTHREAD_PRIO_INHERIT: _bindgen_ty_14 = 1;
pub const PTHREAD_PRIO_PROTECT: _bindgen_ty_14 = 2;
pub type _bindgen_ty_14 = u32;
pub const PTHREAD_RWLOCK_PREFER_READER_NP: _bindgen_ty_15 = 0;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NP: _bindgen_ty_15 = 1;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP: _bindgen_ty_15 = 2;
pub const PTHREAD_RWLOCK_DEFAULT_NP: _bindgen_ty_15 = 0;
pub type _bindgen_ty_15 = u32;
pub const PTHREAD_INHERIT_SCHED: _bindgen_ty_16 = 0;
pub const PTHREAD_EXPLICIT_SCHED: _bindgen_ty_16 = 1;
pub type _bindgen_ty_16 = u32;
pub const PTHREAD_SCOPE_SYSTEM: _bindgen_ty_17 = 0;
pub const PTHREAD_SCOPE_PROCESS: _bindgen_ty_17 = 1;
pub type _bindgen_ty_17 = u32;
pub const PTHREAD_PROCESS_PRIVATE: _bindgen_ty_18 = 0;
pub const PTHREAD_PROCESS_SHARED: _bindgen_ty_18 = 1;
pub type _bindgen_ty_18 = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pthread_cleanup_buffer {
    pub __routine: ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void)>,
    pub __arg: *mut cty::c_void,
    pub __canceltype: cty::c_int,
    pub __prev: *mut _pthread_cleanup_buffer,
}
#[test]
fn bindgen_test_layout__pthread_cleanup_buffer() {
    assert_eq!(
        ::core::mem::size_of::<_pthread_cleanup_buffer>(),
        32usize,
        concat!("Size of: ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        ::core::mem::align_of::<_pthread_cleanup_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_pthread_cleanup_buffer>())).__routine as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_pthread_cleanup_buffer>())).__arg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_pthread_cleanup_buffer>())).__canceltype as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__canceltype)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_pthread_cleanup_buffer>())).__prev as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__prev)
        )
    );
}
pub const PTHREAD_CANCEL_ENABLE: _bindgen_ty_19 = 0;
pub const PTHREAD_CANCEL_DISABLE: _bindgen_ty_19 = 1;
pub type _bindgen_ty_19 = u32;
pub const PTHREAD_CANCEL_DEFERRED: _bindgen_ty_20 = 0;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: _bindgen_ty_20 = 1;
pub type _bindgen_ty_20 = u32;
extern "C" {
    pub fn pthread_create(
        __newthread: *mut pthread_t,
        __attr: *const pthread_attr_t,
        __start_routine: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut cty::c_void) -> *mut cty::c_void,
        >,
        __arg: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_exit(__retval: *mut cty::c_void);
}
extern "C" {
    pub fn pthread_join(__th: pthread_t, __thread_return: *mut *mut cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn pthread_detach(__th: pthread_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_self() -> pthread_t;
}
extern "C" {
    pub fn pthread_equal(__thread1: pthread_t, __thread2: pthread_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_attr_init(__attr: *mut pthread_attr_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_attr_destroy(__attr: *mut pthread_attr_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_attr_getdetachstate(
        __attr: *const pthread_attr_t,
        __detachstate: *mut cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_attr_setdetachstate(
        __attr: *mut pthread_attr_t,
        __detachstate: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_attr_getguardsize(
        __attr: *const pthread_attr_t,
        __guardsize: *mut size_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_attr_setguardsize(
        __attr: *mut pthread_attr_t,
        __guardsize: size_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedparam(
        __attr: *const pthread_attr_t,
        __param: *mut sched_param,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedparam(
        __attr: *mut pthread_attr_t,
        __param: *const sched_param,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedpolicy(
        __attr: *const pthread_attr_t,
        __policy: *mut cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedpolicy(
        __attr: *mut pthread_attr_t,
        __policy: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_attr_getinheritsched(
        __attr: *const pthread_attr_t,
        __inherit: *mut cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_attr_setinheritsched(
        __attr: *mut pthread_attr_t,
        __inherit: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_attr_getscope(
        __attr: *const pthread_attr_t,
        __scope: *mut cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_attr_setscope(__attr: *mut pthread_attr_t, __scope: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn pthread_attr_getstackaddr(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_attr_setstackaddr(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_attr_getstacksize(
        __attr: *const pthread_attr_t,
        __stacksize: *mut size_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_attr_setstacksize(
        __attr: *mut pthread_attr_t,
        __stacksize: size_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_attr_getstack(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut cty::c_void,
        __stacksize: *mut size_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_attr_setstack(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut cty::c_void,
        __stacksize: size_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_setschedparam(
        __target_thread: pthread_t,
        __policy: cty::c_int,
        __param: *const sched_param,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_getschedparam(
        __target_thread: pthread_t,
        __policy: *mut cty::c_int,
        __param: *mut sched_param,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_setschedprio(__target_thread: pthread_t, __prio: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn pthread_once(
        __once_control: *mut pthread_once_t,
        __init_routine: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_setcancelstate(__state: cty::c_int, __oldstate: *mut cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn pthread_setcanceltype(__type: cty::c_int, __oldtype: *mut cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn pthread_cancel(__th: pthread_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_testcancel();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_unwind_buf_t {
    pub __cancel_jmp_buf: [__pthread_unwind_buf_t__bindgen_ty_1; 1usize],
    pub __pad: [*mut cty::c_void; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_unwind_buf_t__bindgen_ty_1 {
    pub __cancel_jmp_buf: __jmp_buf,
    pub __mask_was_saved: cty::c_int,
}
#[test]
fn bindgen_test_layout___pthread_unwind_buf_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<__pthread_unwind_buf_t__bindgen_ty_1>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_unwind_buf_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_unwind_buf_t__bindgen_ty_1>())).__cancel_jmp_buf
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_unwind_buf_t__bindgen_ty_1>())).__mask_was_saved
                as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1),
            "::",
            stringify!(__mask_was_saved)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_unwind_buf_t() {
    assert_eq!(
        ::core::mem::size_of::<__pthread_unwind_buf_t>(),
        104usize,
        concat!("Size of: ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_unwind_buf_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_unwind_buf_t>())).__cancel_jmp_buf as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_unwind_buf_t>())).__pad as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cleanup_frame {
    pub __cancel_routine: ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void)>,
    pub __cancel_arg: *mut cty::c_void,
    pub __do_it: cty::c_int,
    pub __cancel_type: cty::c_int,
}
#[test]
fn bindgen_test_layout___pthread_cleanup_frame() {
    assert_eq!(
        ::core::mem::size_of::<__pthread_cleanup_frame>(),
        24usize,
        concat!("Size of: ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_cleanup_frame>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_cleanup_frame>())).__cancel_routine as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_routine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_cleanup_frame>())).__cancel_arg as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_arg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_cleanup_frame>())).__do_it as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__do_it)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_cleanup_frame>())).__cancel_type as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_type)
        )
    );
}
extern "C" {
    pub fn __pthread_register_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unregister_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unwind_next(__buf: *mut __pthread_unwind_buf_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __jmp_buf_tag {
    _unused: [u8; 0],
}
extern "C" {
    pub fn __sigsetjmp(__env: *mut __jmp_buf_tag, __savemask: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn pthread_mutex_init(
        __mutex: *mut pthread_mutex_t,
        __mutexattr: *const pthread_mutexattr_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_mutex_trylock(__mutex: *mut pthread_mutex_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_mutex_timedlock(
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_mutex_getprioceiling(
        __mutex: *const pthread_mutex_t,
        __prioceiling: *mut cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_mutex_setprioceiling(
        __mutex: *mut pthread_mutex_t,
        __prioceiling: cty::c_int,
        __old_ceiling: *mut cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_mutex_consistent(__mutex: *mut pthread_mutex_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_init(__attr: *mut pthread_mutexattr_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_destroy(__attr: *mut pthread_mutexattr_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getpshared(
        __attr: *const pthread_mutexattr_t,
        __pshared: *mut cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setpshared(
        __attr: *mut pthread_mutexattr_t,
        __pshared: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_gettype(
        __attr: *const pthread_mutexattr_t,
        __kind: *mut cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_settype(
        __attr: *mut pthread_mutexattr_t,
        __kind: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprotocol(
        __attr: *const pthread_mutexattr_t,
        __protocol: *mut cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprotocol(
        __attr: *mut pthread_mutexattr_t,
        __protocol: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprioceiling(
        __attr: *const pthread_mutexattr_t,
        __prioceiling: *mut cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprioceiling(
        __attr: *mut pthread_mutexattr_t,
        __prioceiling: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getrobust(
        __attr: *const pthread_mutexattr_t,
        __robustness: *mut cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setrobust(
        __attr: *mut pthread_mutexattr_t,
        __robustness: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_rwlock_init(
        __rwlock: *mut pthread_rwlock_t,
        __attr: *const pthread_rwlockattr_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_rwlock_destroy(__rwlock: *mut pthread_rwlock_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_rwlock_rdlock(__rwlock: *mut pthread_rwlock_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_rwlock_tryrdlock(__rwlock: *mut pthread_rwlock_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedrdlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_rwlock_wrlock(__rwlock: *mut pthread_rwlock_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_rwlock_trywrlock(__rwlock: *mut pthread_rwlock_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedwrlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_rwlock_unlock(__rwlock: *mut pthread_rwlock_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_init(__attr: *mut pthread_rwlockattr_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_destroy(__attr: *mut pthread_rwlockattr_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getpshared(
        __attr: *const pthread_rwlockattr_t,
        __pshared: *mut cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setpshared(
        __attr: *mut pthread_rwlockattr_t,
        __pshared: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getkind_np(
        __attr: *const pthread_rwlockattr_t,
        __pref: *mut cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setkind_np(
        __attr: *mut pthread_rwlockattr_t,
        __pref: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_cond_init(
        __cond: *mut pthread_cond_t,
        __cond_attr: *const pthread_condattr_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_cond_destroy(__cond: *mut pthread_cond_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_cond_signal(__cond: *mut pthread_cond_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_cond_broadcast(__cond: *mut pthread_cond_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_cond_wait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_condattr_init(__attr: *mut pthread_condattr_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_condattr_destroy(__attr: *mut pthread_condattr_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_condattr_getpshared(
        __attr: *const pthread_condattr_t,
        __pshared: *mut cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_condattr_setpshared(
        __attr: *mut pthread_condattr_t,
        __pshared: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_condattr_getclock(
        __attr: *const pthread_condattr_t,
        __clock_id: *mut __clockid_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_condattr_setclock(
        __attr: *mut pthread_condattr_t,
        __clock_id: __clockid_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_spin_init(__lock: *mut pthread_spinlock_t, __pshared: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn pthread_spin_destroy(__lock: *mut pthread_spinlock_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_spin_lock(__lock: *mut pthread_spinlock_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_spin_trylock(__lock: *mut pthread_spinlock_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_spin_unlock(__lock: *mut pthread_spinlock_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_barrier_init(
        __barrier: *mut pthread_barrier_t,
        __attr: *const pthread_barrierattr_t,
        __count: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_barrier_destroy(__barrier: *mut pthread_barrier_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_barrier_wait(__barrier: *mut pthread_barrier_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_init(__attr: *mut pthread_barrierattr_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_destroy(__attr: *mut pthread_barrierattr_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_getpshared(
        __attr: *const pthread_barrierattr_t,
        __pshared: *mut cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_setpshared(
        __attr: *mut pthread_barrierattr_t,
        __pshared: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_key_create(
        __key: *mut pthread_key_t,
        __destr_function: ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void)>,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_key_delete(__key: pthread_key_t) -> cty::c_int;
}
extern "C" {
    pub fn pthread_getspecific(__key: pthread_key_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn pthread_setspecific(__key: pthread_key_t, __pointer: *const cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn pthread_getcpuclockid(
        __thread_id: pthread_t,
        __clock_id: *mut __clockid_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pthread_atfork(
        __prepare: ::core::option::Option<unsafe extern "C" fn()>,
        __parent: ::core::option::Option<unsafe extern "C" fn()>,
        __child: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> cty::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GStaticMutex {
    pub mutex: *mut GMutex,
    pub unused: pthread_mutex_t,
}
#[test]
fn bindgen_test_layout_GStaticMutex() {
    assert_eq!(
        ::core::mem::size_of::<GStaticMutex>(),
        48usize,
        concat!("Size of: ", stringify!(GStaticMutex))
    );
    assert_eq!(
        ::core::mem::align_of::<GStaticMutex>(),
        8usize,
        concat!("Alignment of ", stringify!(GStaticMutex))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GStaticMutex>())).mutex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GStaticMutex),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<GStaticMutex>())).unused as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GStaticMutex),
            "::",
            stringify!(unused)
        )
    );
}
extern "C" {
    pub fn g_static_mutex_init(mutex: *mut GStaticMutex);
}
extern "C" {
    pub fn g_static_mutex_free(mutex: *mut GStaticMutex);
}
extern "C" {
    pub fn g_static_mutex_get_mutex_impl(mutex: *mut GStaticMutex) -> *mut GMutex;
}
pub type GStaticRecMutex = _GStaticRecMutex;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GStaticRecMutex {
    pub mutex: GStaticMutex,
    pub depth: guint,
    pub unused: _GStaticRecMutex__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GStaticRecMutex__bindgen_ty_1 {
    pub owner: pthread_t,
    pub dummy: gdouble,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__GStaticRecMutex__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_GStaticRecMutex__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_GStaticRecMutex__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_GStaticRecMutex__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_GStaticRecMutex__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_GStaticRecMutex__bindgen_ty_1>())).owner as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRecMutex__bindgen_ty_1),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_GStaticRecMutex__bindgen_ty_1>())).dummy as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRecMutex__bindgen_ty_1),
            "::",
            stringify!(dummy)
        )
    );
}
#[test]
fn bindgen_test_layout__GStaticRecMutex() {
    assert_eq!(
        ::core::mem::size_of::<_GStaticRecMutex>(),
        64usize,
        concat!("Size of: ", stringify!(_GStaticRecMutex))
    );
    assert_eq!(
        ::core::mem::align_of::<_GStaticRecMutex>(),
        8usize,
        concat!("Alignment of ", stringify!(_GStaticRecMutex))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GStaticRecMutex>())).mutex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRecMutex),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GStaticRecMutex>())).depth as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRecMutex),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GStaticRecMutex>())).unused as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRecMutex),
            "::",
            stringify!(unused)
        )
    );
}
extern "C" {
    pub fn g_static_rec_mutex_init(mutex: *mut GStaticRecMutex);
}
extern "C" {
    pub fn g_static_rec_mutex_lock(mutex: *mut GStaticRecMutex);
}
extern "C" {
    pub fn g_static_rec_mutex_trylock(mutex: *mut GStaticRecMutex) -> gboolean;
}
extern "C" {
    pub fn g_static_rec_mutex_unlock(mutex: *mut GStaticRecMutex);
}
extern "C" {
    pub fn g_static_rec_mutex_lock_full(mutex: *mut GStaticRecMutex, depth: guint);
}
extern "C" {
    pub fn g_static_rec_mutex_unlock_full(mutex: *mut GStaticRecMutex) -> guint;
}
extern "C" {
    pub fn g_static_rec_mutex_free(mutex: *mut GStaticRecMutex);
}
pub type GStaticRWLock = _GStaticRWLock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GStaticRWLock {
    pub mutex: GStaticMutex,
    pub read_cond: *mut GCond,
    pub write_cond: *mut GCond,
    pub read_counter: guint,
    pub have_writer: gboolean,
    pub want_to_read: guint,
    pub want_to_write: guint,
}
#[test]
fn bindgen_test_layout__GStaticRWLock() {
    assert_eq!(
        ::core::mem::size_of::<_GStaticRWLock>(),
        80usize,
        concat!("Size of: ", stringify!(_GStaticRWLock))
    );
    assert_eq!(
        ::core::mem::align_of::<_GStaticRWLock>(),
        8usize,
        concat!("Alignment of ", stringify!(_GStaticRWLock))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GStaticRWLock>())).mutex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRWLock),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GStaticRWLock>())).read_cond as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRWLock),
            "::",
            stringify!(read_cond)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GStaticRWLock>())).write_cond as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRWLock),
            "::",
            stringify!(write_cond)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GStaticRWLock>())).read_counter as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRWLock),
            "::",
            stringify!(read_counter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GStaticRWLock>())).have_writer as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRWLock),
            "::",
            stringify!(have_writer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GStaticRWLock>())).want_to_read as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRWLock),
            "::",
            stringify!(want_to_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GStaticRWLock>())).want_to_write as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRWLock),
            "::",
            stringify!(want_to_write)
        )
    );
}
extern "C" {
    pub fn g_static_rw_lock_init(lock: *mut GStaticRWLock);
}
extern "C" {
    pub fn g_static_rw_lock_reader_lock(lock: *mut GStaticRWLock);
}
extern "C" {
    pub fn g_static_rw_lock_reader_trylock(lock: *mut GStaticRWLock) -> gboolean;
}
extern "C" {
    pub fn g_static_rw_lock_reader_unlock(lock: *mut GStaticRWLock);
}
extern "C" {
    pub fn g_static_rw_lock_writer_lock(lock: *mut GStaticRWLock);
}
extern "C" {
    pub fn g_static_rw_lock_writer_trylock(lock: *mut GStaticRWLock) -> gboolean;
}
extern "C" {
    pub fn g_static_rw_lock_writer_unlock(lock: *mut GStaticRWLock);
}
extern "C" {
    pub fn g_static_rw_lock_free(lock: *mut GStaticRWLock);
}
extern "C" {
    pub fn g_private_new(notify: GDestroyNotify) -> *mut GPrivate;
}
pub type GStaticPrivate = _GStaticPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GStaticPrivate {
    pub index: guint,
}
#[test]
fn bindgen_test_layout__GStaticPrivate() {
    assert_eq!(
        ::core::mem::size_of::<_GStaticPrivate>(),
        4usize,
        concat!("Size of: ", stringify!(_GStaticPrivate))
    );
    assert_eq!(
        ::core::mem::align_of::<_GStaticPrivate>(),
        4usize,
        concat!("Alignment of ", stringify!(_GStaticPrivate))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_GStaticPrivate>())).index as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticPrivate),
            "::",
            stringify!(index)
        )
    );
}
extern "C" {
    pub fn g_static_private_init(private_key: *mut GStaticPrivate);
}
extern "C" {
    pub fn g_static_private_get(private_key: *mut GStaticPrivate) -> gpointer;
}
extern "C" {
    pub fn g_static_private_set(
        private_key: *mut GStaticPrivate,
        data: gpointer,
        notify: GDestroyNotify,
    );
}
extern "C" {
    pub fn g_static_private_free(private_key: *mut GStaticPrivate);
}
extern "C" {
    pub fn g_once_init_enter_impl(location: *mut gsize) -> gboolean;
}
extern "C" {
    pub fn g_thread_init(vtable: gpointer);
}
extern "C" {
    pub fn g_thread_init_with_errorcheck_mutexes(vtable: gpointer);
}
extern "C" {
    pub fn g_thread_get_initialized() -> gboolean;
}
extern "C" {
    pub static mut g_threads_got_initialized: gboolean;
}
extern "C" {
    pub fn g_mutex_new() -> *mut GMutex;
}
extern "C" {
    pub fn g_mutex_free(mutex: *mut GMutex);
}
extern "C" {
    pub fn g_cond_new() -> *mut GCond;
}
extern "C" {
    pub fn g_cond_free(cond: *mut GCond);
}
extern "C" {
    pub fn g_cond_timed_wait(
        cond: *mut GCond,
        mutex: *mut GMutex,
        timeval: *mut GTimeVal,
    ) -> gboolean;
}
pub type GAsyncQueue_autoptr = *mut GAsyncQueue;
pub type GAsyncQueue_listautoptr = *mut GList;
pub type GAsyncQueue_slistautoptr = *mut GSList;
pub type GAsyncQueue_queueautoptr = *mut GQueue;
pub type GBookmarkFile_autoptr = *mut GBookmarkFile;
pub type GBookmarkFile_listautoptr = *mut GList;
pub type GBookmarkFile_slistautoptr = *mut GSList;
pub type GBookmarkFile_queueautoptr = *mut GQueue;
pub type GBytes_autoptr = *mut GBytes;
pub type GBytes_listautoptr = *mut GList;
pub type GBytes_slistautoptr = *mut GSList;
pub type GBytes_queueautoptr = *mut GQueue;
pub type GChecksum_autoptr = *mut GChecksum;
pub type GChecksum_listautoptr = *mut GList;
pub type GChecksum_slistautoptr = *mut GSList;
pub type GChecksum_queueautoptr = *mut GQueue;
pub type GDateTime_autoptr = *mut GDateTime;
pub type GDateTime_listautoptr = *mut GList;
pub type GDateTime_slistautoptr = *mut GSList;
pub type GDateTime_queueautoptr = *mut GQueue;
pub type GDate_autoptr = *mut GDate;
pub type GDate_listautoptr = *mut GList;
pub type GDate_slistautoptr = *mut GSList;
pub type GDate_queueautoptr = *mut GQueue;
pub type GDir_autoptr = *mut GDir;
pub type GDir_listautoptr = *mut GList;
pub type GDir_slistautoptr = *mut GSList;
pub type GDir_queueautoptr = *mut GQueue;
pub type GError_autoptr = *mut GError;
pub type GError_listautoptr = *mut GList;
pub type GError_slistautoptr = *mut GSList;
pub type GError_queueautoptr = *mut GQueue;
pub type GHashTable_autoptr = *mut GHashTable;
pub type GHashTable_listautoptr = *mut GList;
pub type GHashTable_slistautoptr = *mut GSList;
pub type GHashTable_queueautoptr = *mut GQueue;
pub type GHmac_autoptr = *mut GHmac;
pub type GHmac_listautoptr = *mut GList;
pub type GHmac_slistautoptr = *mut GSList;
pub type GHmac_queueautoptr = *mut GQueue;
pub type GIOChannel_autoptr = *mut GIOChannel;
pub type GIOChannel_listautoptr = *mut GList;
pub type GIOChannel_slistautoptr = *mut GSList;
pub type GIOChannel_queueautoptr = *mut GQueue;
pub type GKeyFile_autoptr = *mut GKeyFile;
pub type GKeyFile_listautoptr = *mut GList;
pub type GKeyFile_slistautoptr = *mut GSList;
pub type GKeyFile_queueautoptr = *mut GQueue;
pub type GList_autoptr = *mut GList;
pub type GList_listautoptr = *mut GList;
pub type GList_slistautoptr = *mut GSList;
pub type GList_queueautoptr = *mut GQueue;
pub type GArray_autoptr = *mut GArray;
pub type GArray_listautoptr = *mut GList;
pub type GArray_slistautoptr = *mut GSList;
pub type GArray_queueautoptr = *mut GQueue;
pub type GPtrArray_autoptr = *mut GPtrArray;
pub type GPtrArray_listautoptr = *mut GList;
pub type GPtrArray_slistautoptr = *mut GSList;
pub type GPtrArray_queueautoptr = *mut GQueue;
pub type GByteArray_autoptr = *mut GByteArray;
pub type GByteArray_listautoptr = *mut GList;
pub type GByteArray_slistautoptr = *mut GSList;
pub type GByteArray_queueautoptr = *mut GQueue;
pub type GMainContext_autoptr = *mut GMainContext;
pub type GMainContext_listautoptr = *mut GList;
pub type GMainContext_slistautoptr = *mut GSList;
pub type GMainContext_queueautoptr = *mut GQueue;
pub type GMainContextPusher_autoptr = *mut GMainContextPusher;
pub type GMainContextPusher_listautoptr = *mut GList;
pub type GMainContextPusher_slistautoptr = *mut GSList;
pub type GMainContextPusher_queueautoptr = *mut GQueue;
pub type GMainLoop_autoptr = *mut GMainLoop;
pub type GMainLoop_listautoptr = *mut GList;
pub type GMainLoop_slistautoptr = *mut GSList;
pub type GMainLoop_queueautoptr = *mut GQueue;
pub type GSource_autoptr = *mut GSource;
pub type GSource_listautoptr = *mut GList;
pub type GSource_slistautoptr = *mut GSList;
pub type GSource_queueautoptr = *mut GQueue;
pub type GMappedFile_autoptr = *mut GMappedFile;
pub type GMappedFile_listautoptr = *mut GList;
pub type GMappedFile_slistautoptr = *mut GSList;
pub type GMappedFile_queueautoptr = *mut GQueue;
pub type GMarkupParseContext_autoptr = *mut GMarkupParseContext;
pub type GMarkupParseContext_listautoptr = *mut GList;
pub type GMarkupParseContext_slistautoptr = *mut GSList;
pub type GMarkupParseContext_queueautoptr = *mut GQueue;
pub type GNode_autoptr = *mut GNode;
pub type GNode_listautoptr = *mut GList;
pub type GNode_slistautoptr = *mut GSList;
pub type GNode_queueautoptr = *mut GQueue;
pub type GOptionContext_autoptr = *mut GOptionContext;
pub type GOptionContext_listautoptr = *mut GList;
pub type GOptionContext_slistautoptr = *mut GSList;
pub type GOptionContext_queueautoptr = *mut GQueue;
pub type GOptionGroup_autoptr = *mut GOptionGroup;
pub type GOptionGroup_listautoptr = *mut GList;
pub type GOptionGroup_slistautoptr = *mut GSList;
pub type GOptionGroup_queueautoptr = *mut GQueue;
pub type GPatternSpec_autoptr = *mut GPatternSpec;
pub type GPatternSpec_listautoptr = *mut GList;
pub type GPatternSpec_slistautoptr = *mut GSList;
pub type GPatternSpec_queueautoptr = *mut GQueue;
pub type GQueue_autoptr = *mut GQueue;
pub type GQueue_listautoptr = *mut GList;
pub type GQueue_slistautoptr = *mut GSList;
pub type GQueue_queueautoptr = *mut GQueue;
pub type GRand_autoptr = *mut GRand;
pub type GRand_listautoptr = *mut GList;
pub type GRand_slistautoptr = *mut GSList;
pub type GRand_queueautoptr = *mut GQueue;
pub type GRegex_autoptr = *mut GRegex;
pub type GRegex_listautoptr = *mut GList;
pub type GRegex_slistautoptr = *mut GSList;
pub type GRegex_queueautoptr = *mut GQueue;
pub type GMatchInfo_autoptr = *mut GMatchInfo;
pub type GMatchInfo_listautoptr = *mut GList;
pub type GMatchInfo_slistautoptr = *mut GSList;
pub type GMatchInfo_queueautoptr = *mut GQueue;
pub type GScanner_autoptr = *mut GScanner;
pub type GScanner_listautoptr = *mut GList;
pub type GScanner_slistautoptr = *mut GSList;
pub type GScanner_queueautoptr = *mut GQueue;
pub type GSequence_autoptr = *mut GSequence;
pub type GSequence_listautoptr = *mut GList;
pub type GSequence_slistautoptr = *mut GSList;
pub type GSequence_queueautoptr = *mut GQueue;
pub type GSList_autoptr = *mut GSList;
pub type GSList_listautoptr = *mut GList;
pub type GSList_slistautoptr = *mut GSList;
pub type GSList_queueautoptr = *mut GQueue;
pub type GString_autoptr = *mut GString;
pub type GString_listautoptr = *mut GList;
pub type GString_slistautoptr = *mut GSList;
pub type GString_queueautoptr = *mut GQueue;
pub type GStringChunk_autoptr = *mut GStringChunk;
pub type GStringChunk_listautoptr = *mut GList;
pub type GStringChunk_slistautoptr = *mut GSList;
pub type GStringChunk_queueautoptr = *mut GQueue;
pub type GThread_autoptr = *mut GThread;
pub type GThread_listautoptr = *mut GList;
pub type GThread_slistautoptr = *mut GSList;
pub type GThread_queueautoptr = *mut GQueue;
pub type GMutexLocker_autoptr = *mut GMutexLocker;
pub type GMutexLocker_listautoptr = *mut GList;
pub type GMutexLocker_slistautoptr = *mut GSList;
pub type GMutexLocker_queueautoptr = *mut GQueue;
pub type GRecMutexLocker_autoptr = *mut GRecMutexLocker;
pub type GRecMutexLocker_listautoptr = *mut GList;
pub type GRecMutexLocker_slistautoptr = *mut GSList;
pub type GRecMutexLocker_queueautoptr = *mut GQueue;
pub type GRWLockWriterLocker_autoptr = *mut GRWLockWriterLocker;
pub type GRWLockWriterLocker_listautoptr = *mut GList;
pub type GRWLockWriterLocker_slistautoptr = *mut GSList;
pub type GRWLockWriterLocker_queueautoptr = *mut GQueue;
pub type GRWLockReaderLocker_autoptr = *mut GRWLockReaderLocker;
pub type GRWLockReaderLocker_listautoptr = *mut GList;
pub type GRWLockReaderLocker_slistautoptr = *mut GSList;
pub type GRWLockReaderLocker_queueautoptr = *mut GQueue;
pub type GTimer_autoptr = *mut GTimer;
pub type GTimer_listautoptr = *mut GList;
pub type GTimer_slistautoptr = *mut GSList;
pub type GTimer_queueautoptr = *mut GQueue;
pub type GTimeZone_autoptr = *mut GTimeZone;
pub type GTimeZone_listautoptr = *mut GList;
pub type GTimeZone_slistautoptr = *mut GSList;
pub type GTimeZone_queueautoptr = *mut GQueue;
pub type GTree_autoptr = *mut GTree;
pub type GTree_listautoptr = *mut GList;
pub type GTree_slistautoptr = *mut GSList;
pub type GTree_queueautoptr = *mut GQueue;
pub type GVariant_autoptr = *mut GVariant;
pub type GVariant_listautoptr = *mut GList;
pub type GVariant_slistautoptr = *mut GSList;
pub type GVariant_queueautoptr = *mut GQueue;
pub type GVariantBuilder_autoptr = *mut GVariantBuilder;
pub type GVariantBuilder_listautoptr = *mut GList;
pub type GVariantBuilder_slistautoptr = *mut GSList;
pub type GVariantBuilder_queueautoptr = *mut GQueue;
pub type GVariantIter_autoptr = *mut GVariantIter;
pub type GVariantIter_listautoptr = *mut GList;
pub type GVariantIter_slistautoptr = *mut GSList;
pub type GVariantIter_queueautoptr = *mut GQueue;
pub type GVariantDict_autoptr = *mut GVariantDict;
pub type GVariantDict_listautoptr = *mut GList;
pub type GVariantDict_slistautoptr = *mut GSList;
pub type GVariantDict_queueautoptr = *mut GQueue;
pub type GVariantType_autoptr = *mut GVariantType;
pub type GVariantType_listautoptr = *mut GList;
pub type GVariantType_slistautoptr = *mut GSList;
pub type GVariantType_queueautoptr = *mut GQueue;
pub type GRefString_autoptr = *mut GRefString;
pub type GRefString_listautoptr = *mut GList;
pub type GRefString_slistautoptr = *mut GSList;
pub type GRefString_queueautoptr = *mut GQueue;
extern "C" {
    pub fn cairo_version() -> cty::c_int;
}
extern "C" {
    pub fn cairo_version_string() -> *const cty::c_char;
}
#[doc = " cairo_bool_t:"]
#[doc = ""]
#[doc = " #cairo_bool_t is used for boolean values. Returns of type"]
#[doc = " #cairo_bool_t will always be either 0 or 1, but testing against"]
#[doc = " these values explicitly is not encouraged; just use the"]
#[doc = " value as a boolean condition."]
#[doc = ""]
#[doc = " <informalexample><programlisting>"]
#[doc = "  if (cairo_in_stroke (cr, x, y)) {"]
#[doc = "      /<!-- -->* do something *<!-- -->/"]
#[doc = "  }"]
#[doc = " </programlisting></informalexample>"]
#[doc = ""]
#[doc = " Since: 1.0"]
pub type cairo_bool_t = cty::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cairo {
    _unused: [u8; 0],
}
#[doc = " cairo_t:"]
#[doc = ""]
#[doc = " A #cairo_t contains the current state of the rendering device,"]
#[doc = " including coordinates of yet to be drawn shapes."]
#[doc = ""]
#[doc = " Cairo contexts, as #cairo_t objects are named, are central to"]
#[doc = " cairo and all drawing with cairo is always done to a #cairo_t"]
#[doc = " object."]
#[doc = ""]
#[doc = " Memory management of #cairo_t is done with"]
#[doc = " cairo_reference() and cairo_destroy()."]
#[doc = ""]
#[doc = " Since: 1.0"]
pub type cairo_t = _cairo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cairo_surface {
    _unused: [u8; 0],
}
#[doc = " cairo_surface_t:"]
#[doc = ""]
#[doc = " A #cairo_surface_t represents an image, either as the destination"]
#[doc = " of a drawing operation or as source when drawing onto another"]
#[doc = " surface.  To draw to a #cairo_surface_t, create a cairo context"]
#[doc = " with the surface as the target, using cairo_create()."]
#[doc = ""]
#[doc = " There are different subtypes of #cairo_surface_t for"]
#[doc = " different drawing backends; for example, cairo_image_surface_create()"]
#[doc = " creates a bitmap image in memory."]
#[doc = " The type of a surface can be queried with cairo_surface_get_type()."]
#[doc = ""]
#[doc = " The initial contents of a surface after creation depend upon the manner"]
#[doc = " of its creation. If cairo creates the surface and backing storage for"]
#[doc = " the user, it will be initially cleared; for example,"]
#[doc = " cairo_image_surface_create() and cairo_surface_create_similar()."]
#[doc = " Alternatively, if the user passes in a reference to some backing storage"]
#[doc = " and asks cairo to wrap that in a #cairo_surface_t, then the contents are"]
#[doc = " not modified; for example, cairo_image_surface_create_for_data() and"]
#[doc = " cairo_xlib_surface_create()."]
#[doc = ""]
#[doc = " Memory management of #cairo_surface_t is done with"]
#[doc = " cairo_surface_reference() and cairo_surface_destroy()."]
#[doc = ""]
#[doc = " Since: 1.0"]
pub type cairo_surface_t = _cairo_surface;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cairo_device {
    _unused: [u8; 0],
}
#[doc = " cairo_device_t:"]
#[doc = ""]
#[doc = " A #cairo_device_t represents the driver interface for drawing"]
#[doc = " operations to a #cairo_surface_t.  There are different subtypes of"]
#[doc = " #cairo_device_t for different drawing backends; for example,"]
#[doc = " cairo_egl_device_create() creates a device that wraps an EGL display and"]
#[doc = " context."]
#[doc = ""]
#[doc = " The type of a device can be queried with cairo_device_get_type()."]
#[doc = ""]
#[doc = " Memory management of #cairo_device_t is done with"]
#[doc = " cairo_device_reference() and cairo_device_destroy()."]
#[doc = ""]
#[doc = " Since: 1.10"]
pub type cairo_device_t = _cairo_device;
#[doc = " cairo_matrix_t:"]
#[doc = " @xx: xx component of the affine transformation"]
#[doc = " @yx: yx component of the affine transformation"]
#[doc = " @xy: xy component of the affine transformation"]
#[doc = " @yy: yy component of the affine transformation"]
#[doc = " @x0: X translation component of the affine transformation"]
#[doc = " @y0: Y translation component of the affine transformation"]
#[doc = ""]
#[doc = " A #cairo_matrix_t holds an affine transformation, such as a scale,"]
#[doc = " rotation, shear, or a combination of those. The transformation of"]
#[doc = " a point (x, y) is given by:"]
#[doc = " <programlisting>"]
#[doc = "     x_new = xx * x + xy * y + x0;"]
#[doc = "     y_new = yx * x + yy * y + y0;"]
#[doc = " </programlisting>"]
#[doc = ""]
#[doc = " Since: 1.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cairo_matrix {
    pub xx: f64,
    pub yx: f64,
    pub xy: f64,
    pub yy: f64,
    pub x0: f64,
    pub y0: f64,
}
#[test]
fn bindgen_test_layout__cairo_matrix() {
    assert_eq!(
        ::core::mem::size_of::<_cairo_matrix>(),
        48usize,
        concat!("Size of: ", stringify!(_cairo_matrix))
    );
    assert_eq!(
        ::core::mem::align_of::<_cairo_matrix>(),
        8usize,
        concat!("Alignment of ", stringify!(_cairo_matrix))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_cairo_matrix>())).xx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cairo_matrix),
            "::",
            stringify!(xx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_cairo_matrix>())).yx as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_cairo_matrix),
            "::",
            stringify!(yx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_cairo_matrix>())).xy as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_cairo_matrix),
            "::",
            stringify!(xy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_cairo_matrix>())).yy as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_cairo_matrix),
            "::",
            stringify!(yy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_cairo_matrix>())).x0 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_cairo_matrix),
            "::",
            stringify!(x0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_cairo_matrix>())).y0 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cairo_matrix),
            "::",
            stringify!(y0)
        )
    );
}
#[doc = " cairo_matrix_t:"]
#[doc = " @xx: xx component of the affine transformation"]
#[doc = " @yx: yx component of the affine transformation"]
#[doc = " @xy: xy component of the affine transformation"]
#[doc = " @yy: yy component of the affine transformation"]
#[doc = " @x0: X translation component of the affine transformation"]
#[doc = " @y0: Y translation component of the affine transformation"]
#[doc = ""]
#[doc = " A #cairo_matrix_t holds an affine transformation, such as a scale,"]
#[doc = " rotation, shear, or a combination of those. The transformation of"]
#[doc = " a point (x, y) is given by:"]
#[doc = " <programlisting>"]
#[doc = "     x_new = xx * x + xy * y + x0;"]
#[doc = "     y_new = yx * x + yy * y + y0;"]
#[doc = " </programlisting>"]
#[doc = ""]
#[doc = " Since: 1.0"]
pub type cairo_matrix_t = _cairo_matrix;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cairo_pattern {
    _unused: [u8; 0],
}
#[doc = " cairo_pattern_t:"]
#[doc = ""]
#[doc = " A #cairo_pattern_t represents a source when drawing onto a"]
#[doc = " surface. There are different subtypes of #cairo_pattern_t,"]
#[doc = " for different types of sources; for example,"]
#[doc = " cairo_pattern_create_rgb() creates a pattern for a solid"]
#[doc = " opaque color."]
#[doc = ""]
#[doc = " Other than various"]
#[doc = " <function>cairo_pattern_create_<emphasis>type</emphasis>()</function>"]
#[doc = " functions, some of the pattern types can be implicitly created using various"]
#[doc = " <function>cairo_set_source_<emphasis>type</emphasis>()</function> functions;"]
#[doc = " for example cairo_set_source_rgb()."]
#[doc = ""]
#[doc = " The type of a pattern can be queried with cairo_pattern_get_type()."]
#[doc = ""]
#[doc = " Memory management of #cairo_pattern_t is done with"]
#[doc = " cairo_pattern_reference() and cairo_pattern_destroy()."]
#[doc = ""]
#[doc = " Since: 1.0"]
pub type cairo_pattern_t = _cairo_pattern;
#[doc = " cairo_destroy_func_t:"]
#[doc = " @data: The data element being destroyed."]
#[doc = ""]
#[doc = " #cairo_destroy_func_t the type of function which is called when a"]
#[doc = " data element is destroyed. It is passed the pointer to the data"]
#[doc = " element and should free any memory and resources allocated for it."]
#[doc = ""]
#[doc = " Since: 1.0"]
pub type cairo_destroy_func_t =
    ::core::option::Option<unsafe extern "C" fn(data: *mut cty::c_void)>;
#[doc = " cairo_user_data_key_t:"]
#[doc = " @unused: not used; ignore."]
#[doc = ""]
#[doc = " #cairo_user_data_key_t is used for attaching user data to cairo"]
#[doc = " data structures.  The actual contents of the struct is never used,"]
#[doc = " and there is no need to initialize the object; only the unique"]
#[doc = " address of a #cairo_data_key_t object is used.  Typically, you"]
#[doc = " would just use the address of a static #cairo_data_key_t object."]
#[doc = ""]
#[doc = " Since: 1.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cairo_user_data_key {
    pub unused: cty::c_int,
}
#[test]
fn bindgen_test_layout__cairo_user_data_key() {
    assert_eq!(
        ::core::mem::size_of::<_cairo_user_data_key>(),
        4usize,
        concat!("Size of: ", stringify!(_cairo_user_data_key))
    );
    assert_eq!(
        ::core::mem::align_of::<_cairo_user_data_key>(),
        4usize,
        concat!("Alignment of ", stringify!(_cairo_user_data_key))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_cairo_user_data_key>())).unused as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cairo_user_data_key),
            "::",
            stringify!(unused)
        )
    );
}
#[doc = " cairo_user_data_key_t:"]
#[doc = " @unused: not used; ignore."]
#[doc = ""]
#[doc = " #cairo_user_data_key_t is used for attaching user data to cairo"]
#[doc = " data structures.  The actual contents of the struct is never used,"]
#[doc = " and there is no need to initialize the object; only the unique"]
#[doc = " address of a #cairo_data_key_t object is used.  Typically, you"]
#[doc = " would just use the address of a static #cairo_data_key_t object."]
#[doc = ""]
#[doc = " Since: 1.0"]
pub type cairo_user_data_key_t = _cairo_user_data_key;
pub const _cairo_status_CAIRO_STATUS_SUCCESS: _cairo_status = 0;
pub const _cairo_status_CAIRO_STATUS_NO_MEMORY: _cairo_status = 1;
pub const _cairo_status_CAIRO_STATUS_INVALID_RESTORE: _cairo_status = 2;
pub const _cairo_status_CAIRO_STATUS_INVALID_POP_GROUP: _cairo_status = 3;
pub const _cairo_status_CAIRO_STATUS_NO_CURRENT_POINT: _cairo_status = 4;
pub const _cairo_status_CAIRO_STATUS_INVALID_MATRIX: _cairo_status = 5;
pub const _cairo_status_CAIRO_STATUS_INVALID_STATUS: _cairo_status = 6;
pub const _cairo_status_CAIRO_STATUS_NULL_POINTER: _cairo_status = 7;
pub const _cairo_status_CAIRO_STATUS_INVALID_STRING: _cairo_status = 8;
pub const _cairo_status_CAIRO_STATUS_INVALID_PATH_DATA: _cairo_status = 9;
pub const _cairo_status_CAIRO_STATUS_READ_ERROR: _cairo_status = 10;
pub const _cairo_status_CAIRO_STATUS_WRITE_ERROR: _cairo_status = 11;
pub const _cairo_status_CAIRO_STATUS_SURFACE_FINISHED: _cairo_status = 12;
pub const _cairo_status_CAIRO_STATUS_SURFACE_TYPE_MISMATCH: _cairo_status = 13;
pub const _cairo_status_CAIRO_STATUS_PATTERN_TYPE_MISMATCH: _cairo_status = 14;
pub const _cairo_status_CAIRO_STATUS_INVALID_CONTENT: _cairo_status = 15;
pub const _cairo_status_CAIRO_STATUS_INVALID_FORMAT: _cairo_status = 16;
pub const _cairo_status_CAIRO_STATUS_INVALID_VISUAL: _cairo_status = 17;
pub const _cairo_status_CAIRO_STATUS_FILE_NOT_FOUND: _cairo_status = 18;
pub const _cairo_status_CAIRO_STATUS_INVALID_DASH: _cairo_status = 19;
pub const _cairo_status_CAIRO_STATUS_INVALID_DSC_COMMENT: _cairo_status = 20;
pub const _cairo_status_CAIRO_STATUS_INVALID_INDEX: _cairo_status = 21;
pub const _cairo_status_CAIRO_STATUS_CLIP_NOT_REPRESENTABLE: _cairo_status = 22;
pub const _cairo_status_CAIRO_STATUS_TEMP_FILE_ERROR: _cairo_status = 23;
pub const _cairo_status_CAIRO_STATUS_INVALID_STRIDE: _cairo_status = 24;
pub const _cairo_status_CAIRO_STATUS_FONT_TYPE_MISMATCH: _cairo_status = 25;
pub const _cairo_status_CAIRO_STATUS_USER_FONT_IMMUTABLE: _cairo_status = 26;
pub const _cairo_status_CAIRO_STATUS_USER_FONT_ERROR: _cairo_status = 27;
pub const _cairo_status_CAIRO_STATUS_NEGATIVE_COUNT: _cairo_status = 28;
pub const _cairo_status_CAIRO_STATUS_INVALID_CLUSTERS: _cairo_status = 29;
pub const _cairo_status_CAIRO_STATUS_INVALID_SLANT: _cairo_status = 30;
pub const _cairo_status_CAIRO_STATUS_INVALID_WEIGHT: _cairo_status = 31;
pub const _cairo_status_CAIRO_STATUS_INVALID_SIZE: _cairo_status = 32;
pub const _cairo_status_CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED: _cairo_status = 33;
pub const _cairo_status_CAIRO_STATUS_DEVICE_TYPE_MISMATCH: _cairo_status = 34;
pub const _cairo_status_CAIRO_STATUS_DEVICE_ERROR: _cairo_status = 35;
pub const _cairo_status_CAIRO_STATUS_INVALID_MESH_CONSTRUCTION: _cairo_status = 36;
pub const _cairo_status_CAIRO_STATUS_DEVICE_FINISHED: _cairo_status = 37;
pub const _cairo_status_CAIRO_STATUS_JBIG2_GLOBAL_MISSING: _cairo_status = 38;
pub const _cairo_status_CAIRO_STATUS_PNG_ERROR: _cairo_status = 39;
pub const _cairo_status_CAIRO_STATUS_FREETYPE_ERROR: _cairo_status = 40;
pub const _cairo_status_CAIRO_STATUS_WIN32_GDI_ERROR: _cairo_status = 41;
pub const _cairo_status_CAIRO_STATUS_TAG_ERROR: _cairo_status = 42;
pub const _cairo_status_CAIRO_STATUS_LAST_STATUS: _cairo_status = 43;
#[doc = " cairo_status_t:"]
#[doc = " @CAIRO_STATUS_SUCCESS: no error has occurred (Since 1.0)"]
#[doc = " @CAIRO_STATUS_NO_MEMORY: out of memory (Since 1.0)"]
#[doc = " @CAIRO_STATUS_INVALID_RESTORE: cairo_restore() called without matching cairo_save() (Since 1.0)"]
#[doc = " @CAIRO_STATUS_INVALID_POP_GROUP: no saved group to pop, i.e. cairo_pop_group() without matching cairo_push_group() (Since 1.0)"]
#[doc = " @CAIRO_STATUS_NO_CURRENT_POINT: no current point defined (Since 1.0)"]
#[doc = " @CAIRO_STATUS_INVALID_MATRIX: invalid matrix (not invertible) (Since 1.0)"]
#[doc = " @CAIRO_STATUS_INVALID_STATUS: invalid value for an input #cairo_status_t (Since 1.0)"]
#[doc = " @CAIRO_STATUS_NULL_POINTER: %NULL pointer (Since 1.0)"]
#[doc = " @CAIRO_STATUS_INVALID_STRING: input string not valid UTF-8 (Since 1.0)"]
#[doc = " @CAIRO_STATUS_INVALID_PATH_DATA: input path data not valid (Since 1.0)"]
#[doc = " @CAIRO_STATUS_READ_ERROR: error while reading from input stream (Since 1.0)"]
#[doc = " @CAIRO_STATUS_WRITE_ERROR: error while writing to output stream (Since 1.0)"]
#[doc = " @CAIRO_STATUS_SURFACE_FINISHED: target surface has been finished (Since 1.0)"]
#[doc = " @CAIRO_STATUS_SURFACE_TYPE_MISMATCH: the surface type is not appropriate for the operation (Since 1.0)"]
#[doc = " @CAIRO_STATUS_PATTERN_TYPE_MISMATCH: the pattern type is not appropriate for the operation (Since 1.0)"]
#[doc = " @CAIRO_STATUS_INVALID_CONTENT: invalid value for an input #cairo_content_t (Since 1.0)"]
#[doc = " @CAIRO_STATUS_INVALID_FORMAT: invalid value for an input #cairo_format_t (Since 1.0)"]
#[doc = " @CAIRO_STATUS_INVALID_VISUAL: invalid value for an input Visual* (Since 1.0)"]
#[doc = " @CAIRO_STATUS_FILE_NOT_FOUND: file not found (Since 1.0)"]
#[doc = " @CAIRO_STATUS_INVALID_DASH: invalid value for a dash setting (Since 1.0)"]
#[doc = " @CAIRO_STATUS_INVALID_DSC_COMMENT: invalid value for a DSC comment (Since 1.2)"]
#[doc = " @CAIRO_STATUS_INVALID_INDEX: invalid index passed to getter (Since 1.4)"]
#[doc = " @CAIRO_STATUS_CLIP_NOT_REPRESENTABLE: clip region not representable in desired format (Since 1.4)"]
#[doc = " @CAIRO_STATUS_TEMP_FILE_ERROR: error creating or writing to a temporary file (Since 1.6)"]
#[doc = " @CAIRO_STATUS_INVALID_STRIDE: invalid value for stride (Since 1.6)"]
#[doc = " @CAIRO_STATUS_FONT_TYPE_MISMATCH: the font type is not appropriate for the operation (Since 1.8)"]
#[doc = " @CAIRO_STATUS_USER_FONT_IMMUTABLE: the user-font is immutable (Since 1.8)"]
#[doc = " @CAIRO_STATUS_USER_FONT_ERROR: error occurred in a user-font callback function (Since 1.8)"]
#[doc = " @CAIRO_STATUS_NEGATIVE_COUNT: negative number used where it is not allowed (Since 1.8)"]
#[doc = " @CAIRO_STATUS_INVALID_CLUSTERS: input clusters do not represent the accompanying text and glyph array (Since 1.8)"]
#[doc = " @CAIRO_STATUS_INVALID_SLANT: invalid value for an input #cairo_font_slant_t (Since 1.8)"]
#[doc = " @CAIRO_STATUS_INVALID_WEIGHT: invalid value for an input #cairo_font_weight_t (Since 1.8)"]
#[doc = " @CAIRO_STATUS_INVALID_SIZE: invalid value (typically too big) for the size of the input (surface, pattern, etc.) (Since 1.10)"]
#[doc = " @CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED: user-font method not implemented (Since 1.10)"]
#[doc = " @CAIRO_STATUS_DEVICE_TYPE_MISMATCH: the device type is not appropriate for the operation (Since 1.10)"]
#[doc = " @CAIRO_STATUS_DEVICE_ERROR: an operation to the device caused an unspecified error (Since 1.10)"]
#[doc = " @CAIRO_STATUS_INVALID_MESH_CONSTRUCTION: a mesh pattern"]
#[doc = "   construction operation was used outside of a"]
#[doc = "   cairo_mesh_pattern_begin_patch()/cairo_mesh_pattern_end_patch()"]
#[doc = "   pair (Since 1.12)"]
#[doc = " @CAIRO_STATUS_DEVICE_FINISHED: target device has been finished (Since 1.12)"]
#[doc = " @CAIRO_STATUS_JBIG2_GLOBAL_MISSING: %CAIRO_MIME_TYPE_JBIG2_GLOBAL_ID has been used on at least one image"]
#[doc = "   but no image provided %CAIRO_MIME_TYPE_JBIG2_GLOBAL (Since 1.14)"]
#[doc = " @CAIRO_STATUS_PNG_ERROR: error occurred in libpng while reading from or writing to a PNG file (Since 1.16)"]
#[doc = " @CAIRO_STATUS_FREETYPE_ERROR: error occurred in libfreetype (Since 1.16)"]
#[doc = " @CAIRO_STATUS_WIN32_GDI_ERROR: error occurred in the Windows Graphics Device Interface (Since 1.16)"]
#[doc = " @CAIRO_STATUS_TAG_ERROR: invalid tag name, attributes, or nesting (Since 1.16)"]
#[doc = " @CAIRO_STATUS_LAST_STATUS: this is a special value indicating the number of"]
#[doc = "   status values defined in this enumeration.  When using this value, note"]
#[doc = "   that the version of cairo at run-time may have additional status values"]
#[doc = "   defined than the value of this symbol at compile-time. (Since 1.10)"]
#[doc = ""]
#[doc = " #cairo_status_t is used to indicate errors that can occur when"]
#[doc = " using Cairo. In some cases it is returned directly by functions."]
#[doc = " but when using #cairo_t, the last error, if any, is stored in"]
#[doc = " the context and can be retrieved with cairo_status()."]
#[doc = ""]
#[doc = " New entries may be added in future versions.  Use cairo_status_to_string()"]
#[doc = " to get a human-readable representation of an error message."]
#[doc = ""]
#[doc = " Since: 1.0"]
pub type _cairo_status = u32;
#[doc = " cairo_status_t:"]
#[doc = " @CAIRO_STATUS_SUCCESS: no error has occurred (Since 1.0)"]
#[doc = " @CAIRO_STATUS_NO_MEMORY: out of memory (Since 1.0)"]
#[doc = " @CAIRO_STATUS_INVALID_RESTORE: cairo_restore() called without matching cairo_save() (Since 1.0)"]
#[doc = " @CAIRO_STATUS_INVALID_POP_GROUP: no saved group to pop, i.e. cairo_pop_group() without matching cairo_push_group() (Since 1.0)"]
#[doc = " @CAIRO_STATUS_NO_CURRENT_POINT: no current point defined (Since 1.0)"]
#[doc = " @CAIRO_STATUS_INVALID_MATRIX: invalid matrix (not invertible) (Since 1.0)"]
#[doc = " @CAIRO_STATUS_INVALID_STATUS: invalid value for an input #cairo_status_t (Since 1.0)"]
#[doc = " @CAIRO_STATUS_NULL_POINTER: %NULL pointer (Since 1.0)"]
#[doc = " @CAIRO_STATUS_INVALID_STRING: input string not valid UTF-8 (Since 1.0)"]
#[doc = " @CAIRO_STATUS_INVALID_PATH_DATA: input path data not valid (Since 1.0)"]
#[doc = " @CAIRO_STATUS_READ_ERROR: error while reading from input stream (Since 1.0)"]
#[doc = " @CAIRO_STATUS_WRITE_ERROR: error while writing to output stream (Since 1.0)"]
#[doc = " @CAIRO_STATUS_SURFACE_FINISHED: target surface has been finished (Since 1.0)"]
#[doc = " @CAIRO_STATUS_SURFACE_TYPE_MISMATCH: the surface type is not appropriate for the operation (Since 1.0)"]
#[doc = " @CAIRO_STATUS_PATTERN_TYPE_MISMATCH: the pattern type is not appropriate for the operation (Since 1.0)"]
#[doc = " @CAIRO_STATUS_INVALID_CONTENT: invalid value for an input #cairo_content_t (Since 1.0)"]
#[doc = " @CAIRO_STATUS_INVALID_FORMAT: invalid value for an input #cairo_format_t (Since 1.0)"]
#[doc = " @CAIRO_STATUS_INVALID_VISUAL: invalid value for an input Visual* (Since 1.0)"]
#[doc = " @CAIRO_STATUS_FILE_NOT_FOUND: file not found (Since 1.0)"]
#[doc = " @CAIRO_STATUS_INVALID_DASH: invalid value for a dash setting (Since 1.0)"]
#[doc = " @CAIRO_STATUS_INVALID_DSC_COMMENT: invalid value for a DSC comment (Since 1.2)"]
#[doc = " @CAIRO_STATUS_INVALID_INDEX: invalid index passed to getter (Since 1.4)"]
#[doc = " @CAIRO_STATUS_CLIP_NOT_REPRESENTABLE: clip region not representable in desired format (Since 1.4)"]
#[doc = " @CAIRO_STATUS_TEMP_FILE_ERROR: error creating or writing to a temporary file (Since 1.6)"]
#[doc = " @CAIRO_STATUS_INVALID_STRIDE: invalid value for stride (Since 1.6)"]
#[doc = " @CAIRO_STATUS_FONT_TYPE_MISMATCH: the font type is not appropriate for the operation (Since 1.8)"]
#[doc = " @CAIRO_STATUS_USER_FONT_IMMUTABLE: the user-font is immutable (Since 1.8)"]
#[doc = " @CAIRO_STATUS_USER_FONT_ERROR: error occurred in a user-font callback function (Since 1.8)"]
#[doc = " @CAIRO_STATUS_NEGATIVE_COUNT: negative number used where it is not allowed (Since 1.8)"]
#[doc = " @CAIRO_STATUS_INVALID_CLUSTERS: input clusters do not represent the accompanying text and glyph array (Since 1.8)"]
#[doc = " @CAIRO_STATUS_INVALID_SLANT: invalid value for an input #cairo_font_slant_t (Since 1.8)"]
#[doc = " @CAIRO_STATUS_INVALID_WEIGHT: invalid value for an input #cairo_font_weight_t (Since 1.8)"]
#[doc = " @CAIRO_STATUS_INVALID_SIZE: invalid value (typically too big) for the size of the input (surface, pattern, etc.) (Since 1.10)"]
#[doc = " @CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED: user-font method not implemented (Since 1.10)"]
#[doc = " @CAIRO_STATUS_DEVICE_TYPE_MISMATCH: the device type is not appropriate for the operation (Since 1.10)"]
#[doc = " @CAIRO_STATUS_DEVICE_ERROR: an operation to the device caused an unspecified error (Since 1.10)"]
#[doc = " @CAIRO_STATUS_INVALID_MESH_CONSTRUCTION: a mesh pattern"]
#[doc = "   construction operation was used outside of a"]
#[doc = "   cairo_mesh_pattern_begin_patch()/cairo_mesh_pattern_end_patch()"]
#[doc = "   pair (Since 1.12)"]
#[doc = " @CAIRO_STATUS_DEVICE_FINISHED: target device has been finished (Since 1.12)"]
#[doc = " @CAIRO_STATUS_JBIG2_GLOBAL_MISSING: %CAIRO_MIME_TYPE_JBIG2_GLOBAL_ID has been used on at least one image"]
#[doc = "   but no image provided %CAIRO_MIME_TYPE_JBIG2_GLOBAL (Since 1.14)"]
#[doc = " @CAIRO_STATUS_PNG_ERROR: error occurred in libpng while reading from or writing to a PNG file (Since 1.16)"]
#[doc = " @CAIRO_STATUS_FREETYPE_ERROR: error occurred in libfreetype (Since 1.16)"]
#[doc = " @CAIRO_STATUS_WIN32_GDI_ERROR: error occurred in the Windows Graphics Device Interface (Since 1.16)"]
#[doc = " @CAIRO_STATUS_TAG_ERROR: invalid tag name, attributes, or nesting (Since 1.16)"]
#[doc = " @CAIRO_STATUS_LAST_STATUS: this is a special value indicating the number of"]
#[doc = "   status values defined in this enumeration.  When using this value, note"]
#[doc = "   that the version of cairo at run-time may have additional status values"]
#[doc = "   defined than the value of this symbol at compile-time. (Since 1.10)"]
#[doc = ""]
#[doc = " #cairo_status_t is used to indicate errors that can occur when"]
#[doc = " using Cairo. In some cases it is returned directly by functions."]
#[doc = " but when using #cairo_t, the last error, if any, is stored in"]
#[doc = " the context and can be retrieved with cairo_status()."]
#[doc = ""]
#[doc = " New entries may be added in future versions.  Use cairo_status_to_string()"]
#[doc = " to get a human-readable representation of an error message."]
#[doc = ""]
#[doc = " Since: 1.0"]
pub use self::_cairo_status as cairo_status_t;
pub const _cairo_content_CAIRO_CONTENT_COLOR: _cairo_content = 4096;
pub const _cairo_content_CAIRO_CONTENT_ALPHA: _cairo_content = 8192;
pub const _cairo_content_CAIRO_CONTENT_COLOR_ALPHA: _cairo_content = 12288;
#[doc = " cairo_content_t:"]
#[doc = " @CAIRO_CONTENT_COLOR: The surface will hold color content only. (Since 1.0)"]
#[doc = " @CAIRO_CONTENT_ALPHA: The surface will hold alpha content only. (Since 1.0)"]
#[doc = " @CAIRO_CONTENT_COLOR_ALPHA: The surface will hold color and alpha content. (Since 1.0)"]
#[doc = ""]
#[doc = " #cairo_content_t is used to describe the content that a surface will"]
#[doc = " contain, whether color information, alpha information (translucence"]
#[doc = " vs. opacity), or both."]
#[doc = ""]
#[doc = " Note: The large values here are designed to keep #cairo_content_t"]
#[doc = " values distinct from #cairo_format_t values so that the"]
#[doc = " implementation can detect the error if users confuse the two types."]
#[doc = ""]
#[doc = " Since: 1.0"]
pub type _cairo_content = u32;
#[doc = " cairo_content_t:"]
#[doc = " @CAIRO_CONTENT_COLOR: The surface will hold color content only. (Since 1.0)"]
#[doc = " @CAIRO_CONTENT_ALPHA: The surface will hold alpha content only. (Since 1.0)"]
#[doc = " @CAIRO_CONTENT_COLOR_ALPHA: The surface will hold color and alpha content. (Since 1.0)"]
#[doc = ""]
#[doc = " #cairo_content_t is used to describe the content that a surface will"]
#[doc = " contain, whether color information, alpha information (translucence"]
#[doc = " vs. opacity), or both."]
#[doc = ""]
#[doc = " Note: The large values here are designed to keep #cairo_content_t"]
#[doc = " values distinct from #cairo_format_t values so that the"]
#[doc = " implementation can detect the error if users confuse the two types."]
#[doc = ""]
#[doc = " Since: 1.0"]
pub use self::_cairo_content as cairo_content_t;
pub const _cairo_format_CAIRO_FORMAT_INVALID: _cairo_format = -1;
pub const _cairo_format_CAIRO_FORMAT_ARGB32: _cairo_format = 0;
pub const _cairo_format_CAIRO_FORMAT_RGB24: _cairo_format = 1;
pub const _cairo_format_CAIRO_FORMAT_A8: _cairo_format = 2;
pub const _cairo_format_CAIRO_FORMAT_A1: _cairo_format = 3;
pub const _cairo_format_CAIRO_FORMAT_RGB16_565: _cairo_format = 4;
pub const _cairo_format_CAIRO_FORMAT_RGB30: _cairo_format = 5;
pub const _cairo_format_CAIRO_FORMAT_RGB96F: _cairo_format = 6;
pub const _cairo_format_CAIRO_FORMAT_RGBA128F: _cairo_format = 7;
#[doc = " cairo_format_t:"]
#[doc = " @CAIRO_FORMAT_INVALID: no such format exists or is supported."]
#[doc = " @CAIRO_FORMAT_ARGB32: each pixel is a 32-bit quantity, with"]
#[doc = "   alpha in the upper 8 bits, then red, then green, then blue."]
#[doc = "   The 32-bit quantities are stored native-endian. Pre-multiplied"]
#[doc = "   alpha is used. (That is, 50% transparent red is 0x80800000,"]
#[doc = "   not 0x80ff0000.) (Since 1.0)"]
#[doc = " @CAIRO_FORMAT_RGB24: each pixel is a 32-bit quantity, with"]
#[doc = "   the upper 8 bits unused. Red, Green, and Blue are stored"]
#[doc = "   in the remaining 24 bits in that order. (Since 1.0)"]
#[doc = " @CAIRO_FORMAT_A8: each pixel is a 8-bit quantity holding"]
#[doc = "   an alpha value. (Since 1.0)"]
#[doc = " @CAIRO_FORMAT_A1: each pixel is a 1-bit quantity holding"]
#[doc = "   an alpha value. Pixels are packed together into 32-bit"]
#[doc = "   quantities. The ordering of the bits matches the"]
#[doc = "   endianness of the platform. On a big-endian machine, the"]
#[doc = "   first pixel is in the uppermost bit, on a little-endian"]
#[doc = "   machine the first pixel is in the least-significant bit. (Since 1.0)"]
#[doc = " @CAIRO_FORMAT_RGB16_565: each pixel is a 16-bit quantity"]
#[doc = "   with red in the upper 5 bits, then green in the middle"]
#[doc = "   6 bits, and blue in the lower 5 bits. (Since 1.2)"]
#[doc = " @CAIRO_FORMAT_RGB30: like RGB24 but with 10bpc. (Since 1.12)"]
#[doc = " @CAIRO_FORMAT_RGB96F: 3 floats, R, G, B. (Since 1.17.2)"]
#[doc = " @CAIRO_FORMAT_RGBA128F: 4 floats, R, G, B, A. (Since 1.17.2)"]
#[doc = ""]
#[doc = " #cairo_format_t is used to identify the memory format of"]
#[doc = " image data."]
#[doc = ""]
#[doc = " New entries may be added in future versions."]
#[doc = ""]
#[doc = " Since: 1.0"]
pub type _cairo_format = i32;
#[doc = " cairo_format_t:"]
#[doc = " @CAIRO_FORMAT_INVALID: no such format exists or is supported."]
#[doc = " @CAIRO_FORMAT_ARGB32: each pixel is a 32-bit quantity, with"]
#[doc = "   alpha in the upper 8 bits, then red, then green, then blue."]
#[doc = "   The 32-bit quantities are stored native-endian. Pre-multiplied"]
#[doc = "   alpha is used. (That is, 50% transparent red is 0x80800000,"]
#[doc = "   not 0x80ff0000.) (Since 1.0)"]
#[doc = " @CAIRO_FORMAT_RGB24: each pixel is a 32-bit quantity, with"]
#[doc = "   the upper 8 bits unused. Red, Green, and Blue are stored"]
#[doc = "   in the remaining 24 bits in that order. (Since 1.0)"]
#[doc = " @CAIRO_FORMAT_A8: each pixel is a 8-bit quantity holding"]
#[doc = "   an alpha value. (Since 1.0)"]
#[doc = " @CAIRO_FORMAT_A1: each pixel is a 1-bit quantity holding"]
#[doc = "   an alpha value. Pixels are packed together into 32-bit"]
#[doc = "   quantities. The ordering of the bits matches the"]
#[doc = "   endianness of the platform. On a big-endian machine, the"]
#[doc = "   first pixel is in the uppermost bit, on a little-endian"]
#[doc = "   machine the first pixel is in the least-significant bit. (Since 1.0)"]
#[doc = " @CAIRO_FORMAT_RGB16_565: each pixel is a 16-bit quantity"]
#[doc = "   with red in the upper 5 bits, then green in the middle"]
#[doc = "   6 bits, and blue in the lower 5 bits. (Since 1.2)"]
#[doc = " @CAIRO_FORMAT_RGB30: like RGB24 but with 10bpc. (Since 1.12)"]
#[doc = " @CAIRO_FORMAT_RGB96F: 3 floats, R, G, B. (Since 1.17.2)"]
#[doc = " @CAIRO_FORMAT_RGBA128F: 4 floats, R, G, B, A. (Since 1.17.2)"]
#[doc = ""]
#[doc = " #cairo_format_t is used to identify the memory format of"]
#[doc = " image data."]
#[doc = ""]
#[doc = " New entries may be added in future versions."]
#[doc = ""]
#[doc = " Since: 1.0"]
pub use self::_cairo_format as cairo_format_t;
#[doc = " cairo_write_func_t:"]
#[doc = " @closure: the output closure"]
#[doc = " @data: the buffer containing the data to write"]
#[doc = " @length: the amount of data to write"]
#[doc = ""]
#[doc = " #cairo_write_func_t is the type of function which is called when a"]
#[doc = " backend needs to write data to an output stream.  It is passed the"]
#[doc = " closure which was specified by the user at the time the write"]
#[doc = " function was registered, the data to write and the length of the"]
#[doc = " data in bytes.  The write function should return"]
#[doc = " %CAIRO_STATUS_SUCCESS if all the data was successfully written,"]
#[doc = " %CAIRO_STATUS_WRITE_ERROR otherwise."]
#[doc = ""]
#[doc = " Returns: the status code of the write operation"]
#[doc = ""]
#[doc = " Since: 1.0"]
pub type cairo_write_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        closure: *mut cty::c_void,
        data: *const cty::c_uchar,
        length: cty::c_uint,
    ) -> cairo_status_t,
>;
#[doc = " cairo_read_func_t:"]
#[doc = " @closure: the input closure"]
#[doc = " @data: the buffer into which to read the data"]
#[doc = " @length: the amount of data to read"]
#[doc = ""]
#[doc = " #cairo_read_func_t is the type of function which is called when a"]
#[doc = " backend needs to read data from an input stream.  It is passed the"]
#[doc = " closure which was specified by the user at the time the read"]
#[doc = " function was registered, the buffer to read the data into and the"]
#[doc = " length of the data in bytes.  The read function should return"]
#[doc = " %CAIRO_STATUS_SUCCESS if all the data was successfully read,"]
#[doc = " %CAIRO_STATUS_READ_ERROR otherwise."]
#[doc = ""]
#[doc = " Returns: the status code of the read operation"]
#[doc = ""]
#[doc = " Since: 1.0"]
pub type cairo_read_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        closure: *mut cty::c_void,
        data: *mut cty::c_uchar,
        length: cty::c_uint,
    ) -> cairo_status_t,
>;
#[doc = " cairo_rectangle_int_t:"]
#[doc = " @x: X coordinate of the left side of the rectangle"]
#[doc = " @y: Y coordinate of the the top side of the rectangle"]
#[doc = " @width: width of the rectangle"]
#[doc = " @height: height of the rectangle"]
#[doc = ""]
#[doc = " A data structure for holding a rectangle with integer coordinates."]
#[doc = ""]
#[doc = " Since: 1.10"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cairo_rectangle_int {
    pub x: cty::c_int,
    pub y: cty::c_int,
    pub width: cty::c_int,
    pub height: cty::c_int,
}
#[test]
fn bindgen_test_layout__cairo_rectangle_int() {
    assert_eq!(
        ::core::mem::size_of::<_cairo_rectangle_int>(),
        16usize,
        concat!("Size of: ", stringify!(_cairo_rectangle_int))
    );
    assert_eq!(
        ::core::mem::align_of::<_cairo_rectangle_int>(),
        4usize,
        concat!("Alignment of ", stringify!(_cairo_rectangle_int))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_cairo_rectangle_int>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cairo_rectangle_int),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_cairo_rectangle_int>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_cairo_rectangle_int),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_cairo_rectangle_int>())).width as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_cairo_rectangle_int),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_cairo_rectangle_int>())).height as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_cairo_rectangle_int),
            "::",
            stringify!(height)
        )
    );
}
#[doc = " cairo_rectangle_int_t:"]
#[doc = " @x: X coordinate of the left side of the rectangle"]
#[doc = " @y: Y coordinate of the the top side of the rectangle"]
#[doc = " @width: width of the rectangle"]
#[doc = " @height: height of the rectangle"]
#[doc = ""]
#[doc = " A data structure for holding a rectangle with integer coordinates."]
#[doc = ""]
#[doc = " Since: 1.10"]
pub type cairo_rectangle_int_t = _cairo_rectangle_int;
extern "C" {
    pub fn cairo_create(target: *mut cairo_surface_t) -> *mut cairo_t;
}
extern "C" {
    pub fn cairo_reference(cr: *mut cairo_t) -> *mut cairo_t;
}
extern "C" {
    pub fn cairo_destroy(cr: *mut cairo_t);
}
extern "C" {
    pub fn cairo_get_reference_count(cr: *mut cairo_t) -> cty::c_uint;
}
extern "C" {
    pub fn cairo_get_user_data(
        cr: *mut cairo_t,
        key: *const cairo_user_data_key_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn cairo_set_user_data(
        cr: *mut cairo_t,
        key: *const cairo_user_data_key_t,
        user_data: *mut cty::c_void,
        destroy: cairo_destroy_func_t,
    ) -> cairo_status_t;
}
extern "C" {
    pub fn cairo_save(cr: *mut cairo_t);
}
extern "C" {
    pub fn cairo_restore(cr: *mut cairo_t);
}
extern "C" {
    pub fn cairo_push_group(cr: *mut cairo_t);
}
extern "C" {
    pub fn cairo_push_group_with_content(cr: *mut cairo_t, content: cairo_content_t);
}
extern "C" {
    pub fn cairo_pop_group(cr: *mut cairo_t) -> *mut cairo_pattern_t;
}
extern "C" {
    pub fn cairo_pop_group_to_source(cr: *mut cairo_t);
}
pub const _cairo_operator_CAIRO_OPERATOR_CLEAR: _cairo_operator = 0;
pub const _cairo_operator_CAIRO_OPERATOR_SOURCE: _cairo_operator = 1;
pub const _cairo_operator_CAIRO_OPERATOR_OVER: _cairo_operator = 2;
pub const _cairo_operator_CAIRO_OPERATOR_IN: _cairo_operator = 3;
pub const _cairo_operator_CAIRO_OPERATOR_OUT: _cairo_operator = 4;
pub const _cairo_operator_CAIRO_OPERATOR_ATOP: _cairo_operator = 5;
pub const _cairo_operator_CAIRO_OPERATOR_DEST: _cairo_operator = 6;
pub const _cairo_operator_CAIRO_OPERATOR_DEST_OVER: _cairo_operator = 7;
pub const _cairo_operator_CAIRO_OPERATOR_DEST_IN: _cairo_operator = 8;
pub const _cairo_operator_CAIRO_OPERATOR_DEST_OUT: _cairo_operator = 9;
pub const _cairo_operator_CAIRO_OPERATOR_DEST_ATOP: _cairo_operator = 10;
pub const _cairo_operator_CAIRO_OPERATOR_XOR: _cairo_operator = 11;
pub const _cairo_operator_CAIRO_OPERATOR_ADD: _cairo_operator = 12;
pub const _cairo_operator_CAIRO_OPERATOR_SATURATE: _cairo_operator = 13;
pub const _cairo_operator_CAIRO_OPERATOR_MULTIPLY: _cairo_operator = 14;
pub const _cairo_operator_CAIRO_OPERATOR_SCREEN: _cairo_operator = 15;
pub const _cairo_operator_CAIRO_OPERATOR_OVERLAY: _cairo_operator = 16;
pub const _cairo_operator_CAIRO_OPERATOR_DARKEN: _cairo_operator = 17;
pub const _cairo_operator_CAIRO_OPERATOR_LIGHTEN: _cairo_operator = 18;
pub const _cairo_operator_CAIRO_OPERATOR_COLOR_DODGE: _cairo_operator = 19;
pub const _cairo_operator_CAIRO_OPERATOR_COLOR_BURN: _cairo_operator = 20;
pub const _cairo_operator_CAIRO_OPERATOR_HARD_LIGHT: _cairo_operator = 21;
pub const _cairo_operator_CAIRO_OPERATOR_SOFT_LIGHT: _cairo_operator = 22;
pub const _cairo_operator_CAIRO_OPERATOR_DIFFERENCE: _cairo_operator = 23;
pub const _cairo_operator_CAIRO_OPERATOR_EXCLUSION: _cairo_operator = 24;
pub const _cairo_operator_CAIRO_OPERATOR_HSL_HUE: _cairo_operator = 25;
pub const _cairo_operator_CAIRO_OPERATOR_HSL_SATURATION: _cairo_operator = 26;
pub const _cairo_operator_CAIRO_OPERATOR_HSL_COLOR: _cairo_operator = 27;
pub const _cairo_operator_CAIRO_OPERATOR_HSL_LUMINOSITY: _cairo_operator = 28;
#[doc = " cairo_operator_t:"]
#[doc = " @CAIRO_OPERATOR_CLEAR: clear destination layer (bounded) (Since 1.0)"]
#[doc = " @CAIRO_OPERATOR_SOURCE: replace destination layer (bounded) (Since 1.0)"]
#[doc = " @CAIRO_OPERATOR_OVER: draw source layer on top of destination layer"]
#[doc = " (bounded) (Since 1.0)"]
#[doc = " @CAIRO_OPERATOR_IN: draw source where there was destination content"]
#[doc = " (unbounded) (Since 1.0)"]
#[doc = " @CAIRO_OPERATOR_OUT: draw source where there was no destination"]
#[doc = " content (unbounded) (Since 1.0)"]
#[doc = " @CAIRO_OPERATOR_ATOP: draw source on top of destination content and"]
#[doc = " only there (Since 1.0)"]
#[doc = " @CAIRO_OPERATOR_DEST: ignore the source (Since 1.0)"]
#[doc = " @CAIRO_OPERATOR_DEST_OVER: draw destination on top of source (Since 1.0)"]
#[doc = " @CAIRO_OPERATOR_DEST_IN: leave destination only where there was"]
#[doc = " source content (unbounded) (Since 1.0)"]
#[doc = " @CAIRO_OPERATOR_DEST_OUT: leave destination only where there was no"]
#[doc = " source content (Since 1.0)"]
#[doc = " @CAIRO_OPERATOR_DEST_ATOP: leave destination on top of source content"]
#[doc = " and only there (unbounded) (Since 1.0)"]
#[doc = " @CAIRO_OPERATOR_XOR: source and destination are shown where there is only"]
#[doc = " one of them (Since 1.0)"]
#[doc = " @CAIRO_OPERATOR_ADD: source and destination layers are accumulated (Since 1.0)"]
#[doc = " @CAIRO_OPERATOR_SATURATE: like over, but assuming source and dest are"]
#[doc = " disjoint geometries (Since 1.0)"]
#[doc = " @CAIRO_OPERATOR_MULTIPLY: source and destination layers are multiplied."]
#[doc = " This causes the result to be at least as dark as the darker inputs. (Since 1.10)"]
#[doc = " @CAIRO_OPERATOR_SCREEN: source and destination are complemented and"]
#[doc = " multiplied. This causes the result to be at least as light as the lighter"]
#[doc = " inputs. (Since 1.10)"]
#[doc = " @CAIRO_OPERATOR_OVERLAY: multiplies or screens, depending on the"]
#[doc = " lightness of the destination color. (Since 1.10)"]
#[doc = " @CAIRO_OPERATOR_DARKEN: replaces the destination with the source if it"]
#[doc = " is darker, otherwise keeps the source. (Since 1.10)"]
#[doc = " @CAIRO_OPERATOR_LIGHTEN: replaces the destination with the source if it"]
#[doc = " is lighter, otherwise keeps the source. (Since 1.10)"]
#[doc = " @CAIRO_OPERATOR_COLOR_DODGE: brightens the destination color to reflect"]
#[doc = " the source color. (Since 1.10)"]
#[doc = " @CAIRO_OPERATOR_COLOR_BURN: darkens the destination color to reflect"]
#[doc = " the source color. (Since 1.10)"]
#[doc = " @CAIRO_OPERATOR_HARD_LIGHT: Multiplies or screens, dependent on source"]
#[doc = " color. (Since 1.10)"]
#[doc = " @CAIRO_OPERATOR_SOFT_LIGHT: Darkens or lightens, dependent on source"]
#[doc = " color. (Since 1.10)"]
#[doc = " @CAIRO_OPERATOR_DIFFERENCE: Takes the difference of the source and"]
#[doc = " destination color. (Since 1.10)"]
#[doc = " @CAIRO_OPERATOR_EXCLUSION: Produces an effect similar to difference, but"]
#[doc = " with lower contrast. (Since 1.10)"]
#[doc = " @CAIRO_OPERATOR_HSL_HUE: Creates a color with the hue of the source"]
#[doc = " and the saturation and luminosity of the target. (Since 1.10)"]
#[doc = " @CAIRO_OPERATOR_HSL_SATURATION: Creates a color with the saturation"]
#[doc = " of the source and the hue and luminosity of the target. Painting with"]
#[doc = " this mode onto a gray area produces no change. (Since 1.10)"]
#[doc = " @CAIRO_OPERATOR_HSL_COLOR: Creates a color with the hue and saturation"]
#[doc = " of the source and the luminosity of the target. This preserves the gray"]
#[doc = " levels of the target and is useful for coloring monochrome images or"]
#[doc = " tinting color images. (Since 1.10)"]
#[doc = " @CAIRO_OPERATOR_HSL_LUMINOSITY: Creates a color with the luminosity of"]
#[doc = " the source and the hue and saturation of the target. This produces an"]
#[doc = " inverse effect to @CAIRO_OPERATOR_HSL_COLOR. (Since 1.10)"]
#[doc = ""]
#[doc = " #cairo_operator_t is used to set the compositing operator for all cairo"]
#[doc = " drawing operations."]
#[doc = ""]
#[doc = " The default operator is %CAIRO_OPERATOR_OVER."]
#[doc = ""]
#[doc = " The operators marked as <firstterm>unbounded</firstterm> modify their"]
#[doc = " destination even outside of the mask layer (that is, their effect is not"]
#[doc = " bound by the mask layer).  However, their effect can still be limited by"]
#[doc = " way of clipping."]
#[doc = ""]
#[doc = " To keep things simple, the operator descriptions here"]
#[doc = " document the behavior for when both source and destination are either fully"]
#[doc = " transparent or fully opaque.  The actual implementation works for"]
#[doc = " translucent layers too."]
#[doc = " For a more detailed explanation of the effects of each operator, including"]
#[doc = " the mathematical definitions, see"]
#[doc = " <ulink url=\"https://cairographics.org/operators/\">https://cairographics.org/operators/</ulink>."]
#[doc = ""]
#[doc = " Since: 1.0"]
pub type _cairo_operator = u32;
#[doc = " cairo_operator_t:"]
#[doc = " @CAIRO_OPERATOR_CLEAR: clear destination layer (bounded) (Since 1.0)"]
#[doc = " @CAIRO_OPERATOR_SOURCE: replace destination layer (bounded) (Since 1.0)"]
#[doc = " @CAIRO_OPERATOR_OVER: draw source layer on top of destination layer"]
#[doc = " (bounded) (Since 1.0)"]
#[doc = " @CAIRO_OPERATOR_IN: draw source where there was destination content"]
#[doc = " (unbounded) (Since 1.0)"]
#[doc = " @CAIRO_OPERATOR_OUT: draw source where there was no destination"]
#[doc = " content (unbounded) (Since 1.0)"]
#[doc = " @CAIRO_OPERATOR_ATOP: draw source on top of destination content and"]
#[doc = " only there (Since 1.0)"]
#[doc = " @CAIRO_OPERATOR_DEST: ignore the source (Since 1.0)"]
#[doc = " @CAIRO_OPERATOR_DEST_OVER: draw destination on top of source (Since 1.0)"]
#[doc = " @CAIRO_OPERATOR_DEST_IN: leave destination only where there was"]
#[doc = " source content (unbounded) (Since 1.0)"]
#[doc = " @CAIRO_OPERATOR_DEST_OUT: leave destination only where there was no"]
#[doc = " source content (Since 1.0)"]
#[doc = " @CAIRO_OPERATOR_DEST_ATOP: leave destination on top of source content"]
#[doc = " and only there (unbounded) (Since 1.0)"]
#[doc = " @CAIRO_OPERATOR_XOR: source and destination are shown where there is only"]
#[doc = " one of them (Since 1.0)"]
#[doc = " @CAIRO_OPERATOR_ADD: source and destination layers are accumulated (Since 1.0)"]
#[doc = " @CAIRO_OPERATOR_SATURATE: like over, but assuming source and dest are"]
#[doc = " disjoint geometries (Since 1.0)"]
#[doc = " @CAIRO_OPERATOR_MULTIPLY: source and destination layers are multiplied."]
#[doc = " This causes the result to be at least as dark as the darker inputs. (Since 1.10)"]
#[doc = " @CAIRO_OPERATOR_SCREEN: source and destination are complemented and"]
#[doc = " multiplied. This causes the result to be at least as light as the lighter"]
#[doc = " inputs. (Since 1.10)"]
#[doc = " @CAIRO_OPERATOR_OVERLAY: multiplies or screens, depending on the"]
#[doc = " lightness of the destination color. (Since 1.10)"]
#[doc = " @CAIRO_OPERATOR_DARKEN: replaces the destination with the source if it"]
#[doc = " is darker, otherwise keeps the source. (Since 1.10)"]
#[doc = " @CAIRO_OPERATOR_LIGHTEN: replaces the destination with the source if it"]
#[doc = " is lighter, otherwise keeps the source. (Since 1.10)"]
#[doc = " @CAIRO_OPERATOR_COLOR_DODGE: brightens the destination color to reflect"]
#[doc = " the source color. (Since 1.10)"]
#[doc = " @CAIRO_OPERATOR_COLOR_BURN: darkens the destination color to reflect"]
#[doc = " the source color. (Since 1.10)"]
#[doc = " @CAIRO_OPERATOR_HARD_LIGHT: Multiplies or screens, dependent on source"]
#[doc = " color. (Since 1.10)"]
#[doc = " @CAIRO_OPERATOR_SOFT_LIGHT: Darkens or lightens, dependent on source"]
#[doc = " color. (Since 1.10)"]
#[doc = " @CAIRO_OPERATOR_DIFFERENCE: Takes the difference of the source and"]
#[doc = " destination color. (Since 1.10)"]
#[doc = " @CAIRO_OPERATOR_EXCLUSION: Produces an effect similar to difference, but"]
#[doc = " with lower contrast. (Since 1.10)"]
#[doc = " @CAIRO_OPERATOR_HSL_HUE: Creates a color with the hue of the source"]
#[doc = " and the saturation and luminosity of the target. (Since 1.10)"]
#[doc = " @CAIRO_OPERATOR_HSL_SATURATION: Creates a color with the saturation"]
#[doc = " of the source and the hue and luminosity of the target. Painting with"]
#[doc = " this mode onto a gray area produces no change. (Since 1.10)"]
#[doc = " @CAIRO_OPERATOR_HSL_COLOR: Creates a color with the hue and saturation"]
#[doc = " of the source and the luminosity of the target. This preserves the gray"]
#[doc = " levels of the target and is useful for coloring monochrome images or"]
#[doc = " tinting color images. (Since 1.10)"]
#[doc = " @CAIRO_OPERATOR_HSL_LUMINOSITY: Creates a color with the luminosity of"]
#[doc = " the source and the hue and saturation of the target. This produces an"]
#[doc = " inverse effect to @CAIRO_OPERATOR_HSL_COLOR. (Since 1.10)"]
#[doc = ""]
#[doc = " #cairo_operator_t is used to set the compositing operator for all cairo"]
#[doc = " drawing operations."]
#[doc = ""]
#[doc = " The default operator is %CAIRO_OPERATOR_OVER."]
#[doc = ""]
#[doc = " The operators marked as <firstterm>unbounded</firstterm> modify their"]
#[doc = " destination even outside of the mask layer (that is, their effect is not"]
#[doc = " bound by the mask layer).  However, their effect can still be limited by"]
#[doc = " way of clipping."]
#[doc = ""]
#[doc = " To keep things simple, the operator descriptions here"]
#[doc = " document the behavior for when both source and destination are either fully"]
#[doc = " transparent or fully opaque.  The actual implementation works for"]
#[doc = " translucent layers too."]
#[doc = " For a more detailed explanation of the effects of each operator, including"]
#[doc = " the mathematical definitions, see"]
#[doc = " <ulink url=\"https://cairographics.org/operators/\">https://cairographics.org/operators/</ulink>."]
#[doc = ""]
#[doc = " Since: 1.0"]
pub use self::_cairo_operator as cairo_operator_t;
extern "C" {
    pub fn cairo_set_operator(cr: *mut cairo_t, op: cairo_operator_t);
}
extern "C" {
    pub fn cairo_set_source(cr: *mut cairo_t, source: *mut cairo_pattern_t);
}
extern "C" {
    pub fn cairo_set_source_rgb(cr: *mut cairo_t, red: f64, green: f64, blue: f64);
}
extern "C" {
    pub fn cairo_set_source_rgba(cr: *mut cairo_t, red: f64, green: f64, blue: f64, alpha: f64);
}
extern "C" {
    pub fn cairo_set_source_surface(
        cr: *mut cairo_t,
        surface: *mut cairo_surface_t,
        x: f64,
        y: f64,
    );
}
extern "C" {
    pub fn cairo_set_tolerance(cr: *mut cairo_t, tolerance: f64);
}
pub const _cairo_antialias_CAIRO_ANTIALIAS_DEFAULT: _cairo_antialias = 0;
pub const _cairo_antialias_CAIRO_ANTIALIAS_NONE: _cairo_antialias = 1;
pub const _cairo_antialias_CAIRO_ANTIALIAS_GRAY: _cairo_antialias = 2;
pub const _cairo_antialias_CAIRO_ANTIALIAS_SUBPIXEL: _cairo_antialias = 3;
pub const _cairo_antialias_CAIRO_ANTIALIAS_FAST: _cairo_antialias = 4;
pub const _cairo_antialias_CAIRO_ANTIALIAS_GOOD: _cairo_antialias = 5;
pub const _cairo_antialias_CAIRO_ANTIALIAS_BEST: _cairo_antialias = 6;
#[doc = " cairo_antialias_t:"]
#[doc = " @CAIRO_ANTIALIAS_DEFAULT: Use the default antialiasing for"]
#[doc = "   the subsystem and target device, since 1.0"]
#[doc = " @CAIRO_ANTIALIAS_NONE: Use a bilevel alpha mask, since 1.0"]
#[doc = " @CAIRO_ANTIALIAS_GRAY: Perform single-color antialiasing (using"]
#[doc = "  shades of gray for black text on a white background, for example), since 1.0"]
#[doc = " @CAIRO_ANTIALIAS_SUBPIXEL: Perform antialiasing by taking"]
#[doc = "  advantage of the order of subpixel elements on devices"]
#[doc = "  such as LCD panels, since 1.0"]
#[doc = " @CAIRO_ANTIALIAS_FAST: Hint that the backend should perform some"]
#[doc = " antialiasing but prefer speed over quality, since 1.12"]
#[doc = " @CAIRO_ANTIALIAS_GOOD: The backend should balance quality against"]
#[doc = " performance, since 1.12"]
#[doc = " @CAIRO_ANTIALIAS_BEST: Hint that the backend should render at the highest"]
#[doc = " quality, sacrificing speed if necessary, since 1.12"]
#[doc = ""]
#[doc = " Specifies the type of antialiasing to do when rendering text or shapes."]
#[doc = ""]
#[doc = " As it is not necessarily clear from the above what advantages a particular"]
#[doc = " antialias method provides, since 1.12, there is also a set of hints:"]
#[doc = " @CAIRO_ANTIALIAS_FAST: Allow the backend to degrade raster quality for speed"]
#[doc = " @CAIRO_ANTIALIAS_GOOD: A balance between speed and quality"]
#[doc = " @CAIRO_ANTIALIAS_BEST: A high-fidelity, but potentially slow, raster mode"]
#[doc = ""]
#[doc = " These make no guarantee on how the backend will perform its rasterisation"]
#[doc = " (if it even rasterises!), nor that they have any differing effect other"]
#[doc = " than to enable some form of antialiasing. In the case of glyph rendering,"]
#[doc = " @CAIRO_ANTIALIAS_FAST and @CAIRO_ANTIALIAS_GOOD will be mapped to"]
#[doc = " @CAIRO_ANTIALIAS_GRAY, with @CAIRO_ANTALIAS_BEST being equivalent to"]
#[doc = " @CAIRO_ANTIALIAS_SUBPIXEL."]
#[doc = ""]
#[doc = " The interpretation of @CAIRO_ANTIALIAS_DEFAULT is left entirely up to"]
#[doc = " the backend, typically this will be similar to @CAIRO_ANTIALIAS_GOOD."]
#[doc = ""]
#[doc = " Since: 1.0"]
pub type _cairo_antialias = u32;
#[doc = " cairo_antialias_t:"]
#[doc = " @CAIRO_ANTIALIAS_DEFAULT: Use the default antialiasing for"]
#[doc = "   the subsystem and target device, since 1.0"]
#[doc = " @CAIRO_ANTIALIAS_NONE: Use a bilevel alpha mask, since 1.0"]
#[doc = " @CAIRO_ANTIALIAS_GRAY: Perform single-color antialiasing (using"]
#[doc = "  shades of gray for black text on a white background, for example), since 1.0"]
#[doc = " @CAIRO_ANTIALIAS_SUBPIXEL: Perform antialiasing by taking"]
#[doc = "  advantage of the order of subpixel elements on devices"]
#[doc = "  such as LCD panels, since 1.0"]
#[doc = " @CAIRO_ANTIALIAS_FAST: Hint that the backend should perform some"]
#[doc = " antialiasing but prefer speed over quality, since 1.12"]
#[doc = " @CAIRO_ANTIALIAS_GOOD: The backend should balance quality against"]
#[doc = " performance, since 1.12"]
#[doc = " @CAIRO_ANTIALIAS_BEST: Hint that the backend should render at the highest"]
#[doc = " quality, sacrificing speed if necessary, since 1.12"]
#[doc = ""]
#[doc = " Specifies the type of antialiasing to do when rendering text or shapes."]
#[doc = ""]
#[doc = " As it is not necessarily clear from the above what advantages a particular"]
#[doc = " antialias method provides, since 1.12, there is also a set of hints:"]
#[doc = " @CAIRO_ANTIALIAS_FAST: Allow the backend to degrade raster quality for speed"]
#[doc = " @CAIRO_ANTIALIAS_GOOD: A balance between speed and quality"]
#[doc = " @CAIRO_ANTIALIAS_BEST: A high-fidelity, but potentially slow, raster mode"]
#[doc = ""]
#[doc = " These make no guarantee on how the backend will perform its rasterisation"]
#[doc = " (if it even rasterises!), nor that they have any differing effect other"]
#[doc = " than to enable some form of antialiasing. In the case of glyph rendering,"]
#[doc = " @CAIRO_ANTIALIAS_FAST and @CAIRO_ANTIALIAS_GOOD will be mapped to"]
#[doc = " @CAIRO_ANTIALIAS_GRAY, with @CAIRO_ANTALIAS_BEST being equivalent to"]
#[doc = " @CAIRO_ANTIALIAS_SUBPIXEL."]
#[doc = ""]
#[doc = " The interpretation of @CAIRO_ANTIALIAS_DEFAULT is left entirely up to"]
#[doc = " the backend, typically this will be similar to @CAIRO_ANTIALIAS_GOOD."]
#[doc = ""]
#[doc = " Since: 1.0"]
pub use self::_cairo_antialias as cairo_antialias_t;
extern "C" {
    pub fn cairo_set_antialias(cr: *mut cairo_t, antialias: cairo_antialias_t);
}
pub const _cairo_fill_rule_CAIRO_FILL_RULE_WINDING: _cairo_fill_rule = 0;
pub const _cairo_fill_rule_CAIRO_FILL_RULE_EVEN_ODD: _cairo_fill_rule = 1;
#[doc = " cairo_fill_rule_t:"]
#[doc = " @CAIRO_FILL_RULE_WINDING: If the path crosses the ray from"]
#[doc = " left-to-right, counts +1. If the path crosses the ray"]
#[doc = " from right to left, counts -1. (Left and right are determined"]
#[doc = " from the perspective of looking along the ray from the starting"]
#[doc = " point.) If the total count is non-zero, the point will be filled. (Since 1.0)"]
#[doc = " @CAIRO_FILL_RULE_EVEN_ODD: Counts the total number of"]
#[doc = " intersections, without regard to the orientation of the contour. If"]
#[doc = " the total number of intersections is odd, the point will be"]
#[doc = " filled. (Since 1.0)"]
#[doc = ""]
#[doc = " #cairo_fill_rule_t is used to select how paths are filled. For both"]
#[doc = " fill rules, whether or not a point is included in the fill is"]
#[doc = " determined by taking a ray from that point to infinity and looking"]
#[doc = " at intersections with the path. The ray can be in any direction,"]
#[doc = " as long as it doesn't pass through the end point of a segment"]
#[doc = " or have a tricky intersection such as intersecting tangent to the path."]
#[doc = " (Note that filling is not actually implemented in this way. This"]
#[doc = " is just a description of the rule that is applied.)"]
#[doc = ""]
#[doc = " The default fill rule is %CAIRO_FILL_RULE_WINDING."]
#[doc = ""]
#[doc = " New entries may be added in future versions."]
#[doc = ""]
#[doc = " Since: 1.0"]
pub type _cairo_fill_rule = u32;
#[doc = " cairo_fill_rule_t:"]
#[doc = " @CAIRO_FILL_RULE_WINDING: If the path crosses the ray from"]
#[doc = " left-to-right, counts +1. If the path crosses the ray"]
#[doc = " from right to left, counts -1. (Left and right are determined"]
#[doc = " from the perspective of looking along the ray from the starting"]
#[doc = " point.) If the total count is non-zero, the point will be filled. (Since 1.0)"]
#[doc = " @CAIRO_FILL_RULE_EVEN_ODD: Counts the total number of"]
#[doc = " intersections, without regard to the orientation of the contour. If"]
#[doc = " the total number of intersections is odd, the point will be"]
#[doc = " filled. (Since 1.0)"]
#[doc = ""]
#[doc = " #cairo_fill_rule_t is used to select how paths are filled. For both"]
#[doc = " fill rules, whether or not a point is included in the fill is"]
#[doc = " determined by taking a ray from that point to infinity and looking"]
#[doc = " at intersections with the path. The ray can be in any direction,"]
#[doc = " as long as it doesn't pass through the end point of a segment"]
#[doc = " or have a tricky intersection such as intersecting tangent to the path."]
#[doc = " (Note that filling is not actually implemented in this way. This"]
#[doc = " is just a description of the rule that is applied.)"]
#[doc = ""]
#[doc = " The default fill rule is %CAIRO_FILL_RULE_WINDING."]
#[doc = ""]
#[doc = " New entries may be added in future versions."]
#[doc = ""]
#[doc = " Since: 1.0"]
pub use self::_cairo_fill_rule as cairo_fill_rule_t;
extern "C" {
    pub fn cairo_set_fill_rule(cr: *mut cairo_t, fill_rule: cairo_fill_rule_t);
}
extern "C" {
    pub fn cairo_set_line_width(cr: *mut cairo_t, width: f64);
}
pub const _cairo_line_cap_CAIRO_LINE_CAP_BUTT: _cairo_line_cap = 0;
pub const _cairo_line_cap_CAIRO_LINE_CAP_ROUND: _cairo_line_cap = 1;
pub const _cairo_line_cap_CAIRO_LINE_CAP_SQUARE: _cairo_line_cap = 2;
#[doc = " cairo_line_cap_t:"]
#[doc = " @CAIRO_LINE_CAP_BUTT: start(stop) the line exactly at the start(end) point (Since 1.0)"]
#[doc = " @CAIRO_LINE_CAP_ROUND: use a round ending, the center of the circle is the end point (Since 1.0)"]
#[doc = " @CAIRO_LINE_CAP_SQUARE: use squared ending, the center of the square is the end point (Since 1.0)"]
#[doc = ""]
#[doc = " Specifies how to render the endpoints of the path when stroking."]
#[doc = ""]
#[doc = " The default line cap style is %CAIRO_LINE_CAP_BUTT."]
#[doc = ""]
#[doc = " Since: 1.0"]
pub type _cairo_line_cap = u32;
#[doc = " cairo_line_cap_t:"]
#[doc = " @CAIRO_LINE_CAP_BUTT: start(stop) the line exactly at the start(end) point (Since 1.0)"]
#[doc = " @CAIRO_LINE_CAP_ROUND: use a round ending, the center of the circle is the end point (Since 1.0)"]
#[doc = " @CAIRO_LINE_CAP_SQUARE: use squared ending, the center of the square is the end point (Since 1.0)"]
#[doc = ""]
#[doc = " Specifies how to render the endpoints of the path when stroking."]
#[doc = ""]
#[doc = " The default line cap style is %CAIRO_LINE_CAP_BUTT."]
#[doc = ""]
#[doc = " Since: 1.0"]
pub use self::_cairo_line_cap as cairo_line_cap_t;
extern "C" {
    pub fn cairo_set_line_cap(cr: *mut cairo_t, line_cap: cairo_line_cap_t);
}
pub const _cairo_line_join_CAIRO_LINE_JOIN_MITER: _cairo_line_join = 0;
pub const _cairo_line_join_CAIRO_LINE_JOIN_ROUND: _cairo_line_join = 1;
pub const _cairo_line_join_CAIRO_LINE_JOIN_BEVEL: _cairo_line_join = 2;
#[doc = " cairo_line_join_t:"]
#[doc = " @CAIRO_LINE_JOIN_MITER: use a sharp (angled) corner, see"]
#[doc = " cairo_set_miter_limit() (Since 1.0)"]
#[doc = " @CAIRO_LINE_JOIN_ROUND: use a rounded join, the center of the circle is the"]
#[doc = " joint point (Since 1.0)"]
#[doc = " @CAIRO_LINE_JOIN_BEVEL: use a cut-off join, the join is cut off at half"]
#[doc = " the line width from the joint point (Since 1.0)"]
#[doc = ""]
#[doc = " Specifies how to render the junction of two lines when stroking."]
#[doc = ""]
#[doc = " The default line join style is %CAIRO_LINE_JOIN_MITER."]
#[doc = ""]
#[doc = " Since: 1.0"]
pub type _cairo_line_join = u32;
#[doc = " cairo_line_join_t:"]
#[doc = " @CAIRO_LINE_JOIN_MITER: use a sharp (angled) corner, see"]
#[doc = " cairo_set_miter_limit() (Since 1.0)"]
#[doc = " @CAIRO_LINE_JOIN_ROUND: use a rounded join, the center of the circle is the"]
#[doc = " joint point (Since 1.0)"]
#[doc = " @CAIRO_LINE_JOIN_BEVEL: use a cut-off join, the join is cut off at half"]
#[doc = " the line width from the joint point (Since 1.0)"]
#[doc = ""]
#[doc = " Specifies how to render the junction of two lines when stroking."]
#[doc = ""]
#[doc = " The default line join style is %CAIRO_LINE_JOIN_MITER."]
#[doc = ""]
#[doc = " Since: 1.0"]
pub use self::_cairo_line_join as cairo_line_join_t;
extern "C" {
    pub fn cairo_set_line_join(cr: *mut cairo_t, line_join: cairo_line_join_t);
}
extern "C" {
    pub fn cairo_set_dash(
        cr: *mut cairo_t,
        dashes: *const f64,
        num_dashes: cty::c_int,
        offset: f64,
    );
}
extern "C" {
    pub fn cairo_set_miter_limit(cr: *mut cairo_t, limit: f64);
}
extern "C" {
    pub fn cairo_translate(cr: *mut cairo_t, tx: f64, ty: f64);
}
extern "C" {
    pub fn cairo_scale(cr: *mut cairo_t, sx: f64, sy: f64);
}
extern "C" {
    pub fn cairo_rotate(cr: *mut cairo_t, angle: f64);
}
extern "C" {
    pub fn cairo_transform(cr: *mut cairo_t, matrix: *const cairo_matrix_t);
}
extern "C" {
    pub fn cairo_set_matrix(cr: *mut cairo_t, matrix: *const cairo_matrix_t);
}
extern "C" {
    pub fn cairo_identity_matrix(cr: *mut cairo_t);
}
extern "C" {
    pub fn cairo_user_to_device(cr: *mut cairo_t, x: *mut f64, y: *mut f64);
}
extern "C" {
    pub fn cairo_user_to_device_distance(cr: *mut cairo_t, dx: *mut f64, dy: *mut f64);
}
extern "C" {
    pub fn cairo_device_to_user(cr: *mut cairo_t, x: *mut f64, y: *mut f64);
}
extern "C" {
    pub fn cairo_device_to_user_distance(cr: *mut cairo_t, dx: *mut f64, dy: *mut f64);
}
extern "C" {
    pub fn cairo_new_path(cr: *mut cairo_t);
}
extern "C" {
    pub fn cairo_move_to(cr: *mut cairo_t, x: f64, y: f64);
}
extern "C" {
    pub fn cairo_new_sub_path(cr: *mut cairo_t);
}
extern "C" {
    pub fn cairo_line_to(cr: *mut cairo_t, x: f64, y: f64);
}
extern "C" {
    pub fn cairo_curve_to(cr: *mut cairo_t, x1: f64, y1: f64, x2: f64, y2: f64, x3: f64, y3: f64);
}
extern "C" {
    pub fn cairo_arc(cr: *mut cairo_t, xc: f64, yc: f64, radius: f64, angle1: f64, angle2: f64);
}
extern "C" {
    pub fn cairo_arc_negative(
        cr: *mut cairo_t,
        xc: f64,
        yc: f64,
        radius: f64,
        angle1: f64,
        angle2: f64,
    );
}
extern "C" {
    pub fn cairo_rel_move_to(cr: *mut cairo_t, dx: f64, dy: f64);
}
extern "C" {
    pub fn cairo_rel_line_to(cr: *mut cairo_t, dx: f64, dy: f64);
}
extern "C" {
    pub fn cairo_rel_curve_to(
        cr: *mut cairo_t,
        dx1: f64,
        dy1: f64,
        dx2: f64,
        dy2: f64,
        dx3: f64,
        dy3: f64,
    );
}
extern "C" {
    pub fn cairo_rectangle(cr: *mut cairo_t, x: f64, y: f64, width: f64, height: f64);
}
extern "C" {
    pub fn cairo_close_path(cr: *mut cairo_t);
}
extern "C" {
    pub fn cairo_path_extents(
        cr: *mut cairo_t,
        x1: *mut f64,
        y1: *mut f64,
        x2: *mut f64,
        y2: *mut f64,
    );
}
extern "C" {
    pub fn cairo_paint(cr: *mut cairo_t);
}
extern "C" {
    pub fn cairo_paint_with_alpha(cr: *mut cairo_t, alpha: f64);
}
extern "C" {
    pub fn cairo_mask(cr: *mut cairo_t, pattern: *mut cairo_pattern_t);
}
extern "C" {
    pub fn cairo_mask_surface(
        cr: *mut cairo_t,
        surface: *mut cairo_surface_t,
        surface_x: f64,
        surface_y: f64,
    );
}
extern "C" {
    pub fn cairo_stroke(cr: *mut cairo_t);
}
extern "C" {
    pub fn cairo_stroke_preserve(cr: *mut cairo_t);
}
extern "C" {
    pub fn cairo_fill(cr: *mut cairo_t);
}
extern "C" {
    pub fn cairo_fill_preserve(cr: *mut cairo_t);
}
extern "C" {
    pub fn cairo_copy_page(cr: *mut cairo_t);
}
extern "C" {
    pub fn cairo_show_page(cr: *mut cairo_t);
}
extern "C" {
    pub fn cairo_in_stroke(cr: *mut cairo_t, x: f64, y: f64) -> cairo_bool_t;
}
extern "C" {
    pub fn cairo_in_fill(cr: *mut cairo_t, x: f64, y: f64) -> cairo_bool_t;
}
extern "C" {
    pub fn cairo_in_clip(cr: *mut cairo_t, x: f64, y: f64) -> cairo_bool_t;
}
extern "C" {
    pub fn cairo_stroke_extents(
        cr: *mut cairo_t,
        x1: *mut f64,
        y1: *mut f64,
        x2: *mut f64,
        y2: *mut f64,
    );
}
extern "C" {
    pub fn cairo_fill_extents(
        cr: *mut cairo_t,
        x1: *mut f64,
        y1: *mut f64,
        x2: *mut f64,
        y2: *mut f64,
    );
}
extern "C" {
    pub fn cairo_reset_clip(cr: *mut cairo_t);
}
extern "C" {
    pub fn cairo_clip(cr: *mut cairo_t);
}
extern "C" {
    pub fn cairo_clip_preserve(cr: *mut cairo_t);
}
extern "C" {
    pub fn cairo_clip_extents(
        cr: *mut cairo_t,
        x1: *mut f64,
        y1: *mut f64,
        x2: *mut f64,
        y2: *mut f64,
    );
}
#[doc = " cairo_rectangle_t:"]
#[doc = " @x: X coordinate of the left side of the rectangle"]
#[doc = " @y: Y coordinate of the the top side of the rectangle"]
#[doc = " @width: width of the rectangle"]
#[doc = " @height: height of the rectangle"]
#[doc = ""]
#[doc = " A data structure for holding a rectangle."]
#[doc = ""]
#[doc = " Since: 1.4"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cairo_rectangle {
    pub x: f64,
    pub y: f64,
    pub width: f64,
    pub height: f64,
}
#[test]
fn bindgen_test_layout__cairo_rectangle() {
    assert_eq!(
        ::core::mem::size_of::<_cairo_rectangle>(),
        32usize,
        concat!("Size of: ", stringify!(_cairo_rectangle))
    );
    assert_eq!(
        ::core::mem::align_of::<_cairo_rectangle>(),
        8usize,
        concat!("Alignment of ", stringify!(_cairo_rectangle))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_cairo_rectangle>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cairo_rectangle),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_cairo_rectangle>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_cairo_rectangle),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_cairo_rectangle>())).width as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_cairo_rectangle),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_cairo_rectangle>())).height as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_cairo_rectangle),
            "::",
            stringify!(height)
        )
    );
}
#[doc = " cairo_rectangle_t:"]
#[doc = " @x: X coordinate of the left side of the rectangle"]
#[doc = " @y: Y coordinate of the the top side of the rectangle"]
#[doc = " @width: width of the rectangle"]
#[doc = " @height: height of the rectangle"]
#[doc = ""]
#[doc = " A data structure for holding a rectangle."]
#[doc = ""]
#[doc = " Since: 1.4"]
pub type cairo_rectangle_t = _cairo_rectangle;
#[doc = " cairo_rectangle_list_t:"]
#[doc = " @status: Error status of the rectangle list"]
#[doc = " @rectangles: Array containing the rectangles"]
#[doc = " @num_rectangles: Number of rectangles in this list"]
#[doc = ""]
#[doc = " A data structure for holding a dynamically allocated"]
#[doc = " array of rectangles."]
#[doc = ""]
#[doc = " Since: 1.4"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cairo_rectangle_list {
    pub status: cairo_status_t,
    pub rectangles: *mut cairo_rectangle_t,
    pub num_rectangles: cty::c_int,
}
#[test]
fn bindgen_test_layout__cairo_rectangle_list() {
    assert_eq!(
        ::core::mem::size_of::<_cairo_rectangle_list>(),
        24usize,
        concat!("Size of: ", stringify!(_cairo_rectangle_list))
    );
    assert_eq!(
        ::core::mem::align_of::<_cairo_rectangle_list>(),
        8usize,
        concat!("Alignment of ", stringify!(_cairo_rectangle_list))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_cairo_rectangle_list>())).status as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cairo_rectangle_list),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_cairo_rectangle_list>())).rectangles as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_cairo_rectangle_list),
            "::",
            stringify!(rectangles)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_cairo_rectangle_list>())).num_rectangles as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_cairo_rectangle_list),
            "::",
            stringify!(num_rectangles)
        )
    );
}
#[doc = " cairo_rectangle_list_t:"]
#[doc = " @status: Error status of the rectangle list"]
#[doc = " @rectangles: Array containing the rectangles"]
#[doc = " @num_rectangles: Number of rectangles in this list"]
#[doc = ""]
#[doc = " A data structure for holding a dynamically allocated"]
#[doc = " array of rectangles."]
#[doc = ""]
#[doc = " Since: 1.4"]
pub type cairo_rectangle_list_t = _cairo_rectangle_list;
extern "C" {
    pub fn cairo_copy_clip_rectangle_list(cr: *mut cairo_t) -> *mut cairo_rectangle_list_t;
}
extern "C" {
    pub fn cairo_rectangle_list_destroy(rectangle_list: *mut cairo_rectangle_list_t);
}
extern "C" {
    pub fn cairo_tag_begin(
        cr: *mut cairo_t,
        tag_name: *const cty::c_char,
        attributes: *const cty::c_char,
    );
}
extern "C" {
    pub fn cairo_tag_end(cr: *mut cairo_t, tag_name: *const cty::c_char);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cairo_scaled_font {
    _unused: [u8; 0],
}
#[doc = " cairo_scaled_font_t:"]
#[doc = ""]
#[doc = " A #cairo_scaled_font_t is a font scaled to a particular size and device"]
#[doc = " resolution. A #cairo_scaled_font_t is most useful for low-level font"]
#[doc = " usage where a library or application wants to cache a reference"]
#[doc = " to a scaled font to speed up the computation of metrics."]
#[doc = ""]
#[doc = " There are various types of scaled fonts, depending on the"]
#[doc = " <firstterm>font backend</firstterm> they use. The type of a"]
#[doc = " scaled font can be queried using cairo_scaled_font_get_type()."]
#[doc = ""]
#[doc = " Memory management of #cairo_scaled_font_t is done with"]
#[doc = " cairo_scaled_font_reference() and cairo_scaled_font_destroy()."]
#[doc = ""]
#[doc = " Since: 1.0"]
pub type cairo_scaled_font_t = _cairo_scaled_font;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cairo_font_face {
    _unused: [u8; 0],
}
#[doc = " cairo_font_face_t:"]
#[doc = ""]
#[doc = " A #cairo_font_face_t specifies all aspects of a font other"]
#[doc = " than the size or font matrix (a font matrix is used to distort"]
#[doc = " a font by shearing it or scaling it unequally in the two"]
#[doc = " directions) . A font face can be set on a #cairo_t by using"]
#[doc = " cairo_set_font_face(); the size and font matrix are set with"]
#[doc = " cairo_set_font_size() and cairo_set_font_matrix()."]
#[doc = ""]
#[doc = " There are various types of font faces, depending on the"]
#[doc = " <firstterm>font backend</firstterm> they use. The type of a"]
#[doc = " font face can be queried using cairo_font_face_get_type()."]
#[doc = ""]
#[doc = " Memory management of #cairo_font_face_t is done with"]
#[doc = " cairo_font_face_reference() and cairo_font_face_destroy()."]
#[doc = ""]
#[doc = " Since: 1.0"]
pub type cairo_font_face_t = _cairo_font_face;
#[doc = " cairo_glyph_t:"]
#[doc = " @index: glyph index in the font. The exact interpretation of the"]
#[doc = "      glyph index depends on the font technology being used."]
#[doc = " @x: the offset in the X direction between the origin used for"]
#[doc = "     drawing or measuring the string and the origin of this glyph."]
#[doc = " @y: the offset in the Y direction between the origin used for"]
#[doc = "     drawing or measuring the string and the origin of this glyph."]
#[doc = ""]
#[doc = " The #cairo_glyph_t structure holds information about a single glyph"]
#[doc = " when drawing or measuring text. A font is (in simple terms) a"]
#[doc = " collection of shapes used to draw text. A glyph is one of these"]
#[doc = " shapes. There can be multiple glyphs for a single character"]
#[doc = " (alternates to be used in different contexts, for example), or a"]
#[doc = " glyph can be a <firstterm>ligature</firstterm> of multiple"]
#[doc = " characters. Cairo doesn't expose any way of converting input text"]
#[doc = " into glyphs, so in order to use the Cairo interfaces that take"]
#[doc = " arrays of glyphs, you must directly access the appropriate"]
#[doc = " underlying font system."]
#[doc = ""]
#[doc = " Note that the offsets given by @x and @y are not cumulative. When"]
#[doc = " drawing or measuring text, each glyph is individually positioned"]
#[doc = " with respect to the overall origin"]
#[doc = ""]
#[doc = " Since: 1.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cairo_glyph_t {
    pub index: cty::c_ulong,
    pub x: f64,
    pub y: f64,
}
#[test]
fn bindgen_test_layout_cairo_glyph_t() {
    assert_eq!(
        ::core::mem::size_of::<cairo_glyph_t>(),
        24usize,
        concat!("Size of: ", stringify!(cairo_glyph_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cairo_glyph_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cairo_glyph_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cairo_glyph_t>())).index as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cairo_glyph_t),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cairo_glyph_t>())).x as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cairo_glyph_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cairo_glyph_t>())).y as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cairo_glyph_t),
            "::",
            stringify!(y)
        )
    );
}
extern "C" {
    pub fn cairo_glyph_allocate(num_glyphs: cty::c_int) -> *mut cairo_glyph_t;
}
extern "C" {
    pub fn cairo_glyph_free(glyphs: *mut cairo_glyph_t);
}
#[doc = " cairo_text_cluster_t:"]
#[doc = " @num_bytes: the number of bytes of UTF-8 text covered by cluster"]
#[doc = " @num_glyphs: the number of glyphs covered by cluster"]
#[doc = ""]
#[doc = " The #cairo_text_cluster_t structure holds information about a single"]
#[doc = " <firstterm>text cluster</firstterm>.  A text cluster is a minimal"]
#[doc = " mapping of some glyphs corresponding to some UTF-8 text."]
#[doc = ""]
#[doc = " For a cluster to be valid, both @num_bytes and @num_glyphs should"]
#[doc = " be non-negative, and at least one should be non-zero."]
#[doc = " Note that clusters with zero glyphs are not as well supported as"]
#[doc = " normal clusters.  For example, PDF rendering applications typically"]
#[doc = " ignore those clusters when PDF text is being selected."]
#[doc = ""]
#[doc = " See cairo_show_text_glyphs() for how clusters are used in advanced"]
#[doc = " text operations."]
#[doc = ""]
#[doc = " Since: 1.8"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cairo_text_cluster_t {
    pub num_bytes: cty::c_int,
    pub num_glyphs: cty::c_int,
}
#[test]
fn bindgen_test_layout_cairo_text_cluster_t() {
    assert_eq!(
        ::core::mem::size_of::<cairo_text_cluster_t>(),
        8usize,
        concat!("Size of: ", stringify!(cairo_text_cluster_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cairo_text_cluster_t>(),
        4usize,
        concat!("Alignment of ", stringify!(cairo_text_cluster_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cairo_text_cluster_t>())).num_bytes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cairo_text_cluster_t),
            "::",
            stringify!(num_bytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cairo_text_cluster_t>())).num_glyphs as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cairo_text_cluster_t),
            "::",
            stringify!(num_glyphs)
        )
    );
}
extern "C" {
    pub fn cairo_text_cluster_allocate(num_clusters: cty::c_int) -> *mut cairo_text_cluster_t;
}
extern "C" {
    pub fn cairo_text_cluster_free(clusters: *mut cairo_text_cluster_t);
}
pub const _cairo_text_cluster_flags_CAIRO_TEXT_CLUSTER_FLAG_BACKWARD: _cairo_text_cluster_flags = 1;
#[doc = " cairo_text_cluster_flags_t:"]
#[doc = " @CAIRO_TEXT_CLUSTER_FLAG_BACKWARD: The clusters in the cluster array"]
#[doc = " map to glyphs in the glyph array from end to start. (Since 1.8)"]
#[doc = ""]
#[doc = " Specifies properties of a text cluster mapping."]
#[doc = ""]
#[doc = " Since: 1.8"]
pub type _cairo_text_cluster_flags = u32;
#[doc = " cairo_text_cluster_flags_t:"]
#[doc = " @CAIRO_TEXT_CLUSTER_FLAG_BACKWARD: The clusters in the cluster array"]
#[doc = " map to glyphs in the glyph array from end to start. (Since 1.8)"]
#[doc = ""]
#[doc = " Specifies properties of a text cluster mapping."]
#[doc = ""]
#[doc = " Since: 1.8"]
pub use self::_cairo_text_cluster_flags as cairo_text_cluster_flags_t;
#[doc = " cairo_text_extents_t:"]
#[doc = " @x_bearing: the horizontal distance from the origin to the"]
#[doc = "   leftmost part of the glyphs as drawn. Positive if the"]
#[doc = "   glyphs lie entirely to the right of the origin."]
#[doc = " @y_bearing: the vertical distance from the origin to the"]
#[doc = "   topmost part of the glyphs as drawn. Positive only if the"]
#[doc = "   glyphs lie completely below the origin; will usually be"]
#[doc = "   negative."]
#[doc = " @width: width of the glyphs as drawn"]
#[doc = " @height: height of the glyphs as drawn"]
#[doc = " @x_advance:distance to advance in the X direction"]
#[doc = "    after drawing these glyphs"]
#[doc = " @y_advance: distance to advance in the Y direction"]
#[doc = "   after drawing these glyphs. Will typically be zero except"]
#[doc = "   for vertical text layout as found in East-Asian languages."]
#[doc = ""]
#[doc = " The #cairo_text_extents_t structure stores the extents of a single"]
#[doc = " glyph or a string of glyphs in user-space coordinates. Because text"]
#[doc = " extents are in user-space coordinates, they are mostly, but not"]
#[doc = " entirely, independent of the current transformation matrix. If you call"]
#[doc = " <literal>cairo_scale(cr, 2.0, 2.0)</literal>, text will"]
#[doc = " be drawn twice as big, but the reported text extents will not be"]
#[doc = " doubled. They will change slightly due to hinting (so you can't"]
#[doc = " assume that metrics are independent of the transformation matrix),"]
#[doc = " but otherwise will remain unchanged."]
#[doc = ""]
#[doc = " Since: 1.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cairo_text_extents_t {
    pub x_bearing: f64,
    pub y_bearing: f64,
    pub width: f64,
    pub height: f64,
    pub x_advance: f64,
    pub y_advance: f64,
}
#[test]
fn bindgen_test_layout_cairo_text_extents_t() {
    assert_eq!(
        ::core::mem::size_of::<cairo_text_extents_t>(),
        48usize,
        concat!("Size of: ", stringify!(cairo_text_extents_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cairo_text_extents_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cairo_text_extents_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cairo_text_extents_t>())).x_bearing as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cairo_text_extents_t),
            "::",
            stringify!(x_bearing)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cairo_text_extents_t>())).y_bearing as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cairo_text_extents_t),
            "::",
            stringify!(y_bearing)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cairo_text_extents_t>())).width as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cairo_text_extents_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cairo_text_extents_t>())).height as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cairo_text_extents_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cairo_text_extents_t>())).x_advance as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cairo_text_extents_t),
            "::",
            stringify!(x_advance)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cairo_text_extents_t>())).y_advance as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cairo_text_extents_t),
            "::",
            stringify!(y_advance)
        )
    );
}
#[doc = " cairo_font_extents_t:"]
#[doc = " @ascent: the distance that the font extends above the baseline."]
#[doc = "          Note that this is not always exactly equal to the maximum"]
#[doc = "          of the extents of all the glyphs in the font, but rather"]
#[doc = "          is picked to express the font designer's intent as to"]
#[doc = "          how the font should align with elements above it."]
#[doc = " @descent: the distance that the font extends below the baseline."]
#[doc = "           This value is positive for typical fonts that include"]
#[doc = "           portions below the baseline. Note that this is not always"]
#[doc = "           exactly equal to the maximum of the extents of all the"]
#[doc = "           glyphs in the font, but rather is picked to express the"]
#[doc = "           font designer's intent as to how the font should"]
#[doc = "           align with elements below it."]
#[doc = " @height: the recommended vertical distance between baselines when"]
#[doc = "          setting consecutive lines of text with the font. This"]
#[doc = "          is greater than @ascent+@descent by a"]
#[doc = "          quantity known as the <firstterm>line spacing</firstterm>"]
#[doc = "          or <firstterm>external leading</firstterm>. When space"]
#[doc = "          is at a premium, most fonts can be set with only"]
#[doc = "          a distance of @ascent+@descent between lines."]
#[doc = " @max_x_advance: the maximum distance in the X direction that"]
#[doc = "         the origin is advanced for any glyph in the font."]
#[doc = " @max_y_advance: the maximum distance in the Y direction that"]
#[doc = "         the origin is advanced for any glyph in the font."]
#[doc = "         This will be zero for normal fonts used for horizontal"]
#[doc = "         writing. (The scripts of East Asia are sometimes written"]
#[doc = "         vertically.)"]
#[doc = ""]
#[doc = " The #cairo_font_extents_t structure stores metric information for"]
#[doc = " a font. Values are given in the current user-space coordinate"]
#[doc = " system."]
#[doc = ""]
#[doc = " Because font metrics are in user-space coordinates, they are"]
#[doc = " mostly, but not entirely, independent of the current transformation"]
#[doc = " matrix. If you call <literal>cairo_scale(cr, 2.0, 2.0)</literal>,"]
#[doc = " text will be drawn twice as big, but the reported text extents will"]
#[doc = " not be doubled. They will change slightly due to hinting (so you"]
#[doc = " can't assume that metrics are independent of the transformation"]
#[doc = " matrix), but otherwise will remain unchanged."]
#[doc = ""]
#[doc = " Since: 1.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cairo_font_extents_t {
    pub ascent: f64,
    pub descent: f64,
    pub height: f64,
    pub max_x_advance: f64,
    pub max_y_advance: f64,
}
#[test]
fn bindgen_test_layout_cairo_font_extents_t() {
    assert_eq!(
        ::core::mem::size_of::<cairo_font_extents_t>(),
        40usize,
        concat!("Size of: ", stringify!(cairo_font_extents_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cairo_font_extents_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cairo_font_extents_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cairo_font_extents_t>())).ascent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cairo_font_extents_t),
            "::",
            stringify!(ascent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cairo_font_extents_t>())).descent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cairo_font_extents_t),
            "::",
            stringify!(descent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cairo_font_extents_t>())).height as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cairo_font_extents_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cairo_font_extents_t>())).max_x_advance as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cairo_font_extents_t),
            "::",
            stringify!(max_x_advance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cairo_font_extents_t>())).max_y_advance as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cairo_font_extents_t),
            "::",
            stringify!(max_y_advance)
        )
    );
}
pub const _cairo_font_slant_CAIRO_FONT_SLANT_NORMAL: _cairo_font_slant = 0;
pub const _cairo_font_slant_CAIRO_FONT_SLANT_ITALIC: _cairo_font_slant = 1;
pub const _cairo_font_slant_CAIRO_FONT_SLANT_OBLIQUE: _cairo_font_slant = 2;
#[doc = " cairo_font_slant_t:"]
#[doc = " @CAIRO_FONT_SLANT_NORMAL: Upright font style, since 1.0"]
#[doc = " @CAIRO_FONT_SLANT_ITALIC: Italic font style, since 1.0"]
#[doc = " @CAIRO_FONT_SLANT_OBLIQUE: Oblique font style, since 1.0"]
#[doc = ""]
#[doc = " Specifies variants of a font face based on their slant."]
#[doc = ""]
#[doc = " Since: 1.0"]
pub type _cairo_font_slant = u32;
#[doc = " cairo_font_slant_t:"]
#[doc = " @CAIRO_FONT_SLANT_NORMAL: Upright font style, since 1.0"]
#[doc = " @CAIRO_FONT_SLANT_ITALIC: Italic font style, since 1.0"]
#[doc = " @CAIRO_FONT_SLANT_OBLIQUE: Oblique font style, since 1.0"]
#[doc = ""]
#[doc = " Specifies variants of a font face based on their slant."]
#[doc = ""]
#[doc = " Since: 1.0"]
pub use self::_cairo_font_slant as cairo_font_slant_t;
pub const _cairo_font_weight_CAIRO_FONT_WEIGHT_NORMAL: _cairo_font_weight = 0;
pub const _cairo_font_weight_CAIRO_FONT_WEIGHT_BOLD: _cairo_font_weight = 1;
#[doc = " cairo_font_weight_t:"]
#[doc = " @CAIRO_FONT_WEIGHT_NORMAL: Normal font weight, since 1.0"]
#[doc = " @CAIRO_FONT_WEIGHT_BOLD: Bold font weight, since 1.0"]
#[doc = ""]
#[doc = " Specifies variants of a font face based on their weight."]
#[doc = ""]
#[doc = " Since: 1.0"]
pub type _cairo_font_weight = u32;
#[doc = " cairo_font_weight_t:"]
#[doc = " @CAIRO_FONT_WEIGHT_NORMAL: Normal font weight, since 1.0"]
#[doc = " @CAIRO_FONT_WEIGHT_BOLD: Bold font weight, since 1.0"]
#[doc = ""]
#[doc = " Specifies variants of a font face based on their weight."]
#[doc = ""]
#[doc = " Since: 1.0"]
pub use self::_cairo_font_weight as cairo_font_weight_t;
pub const _cairo_subpixel_order_CAIRO_SUBPIXEL_ORDER_DEFAULT: _cairo_subpixel_order = 0;
pub const _cairo_subpixel_order_CAIRO_SUBPIXEL_ORDER_RGB: _cairo_subpixel_order = 1;
pub const _cairo_subpixel_order_CAIRO_SUBPIXEL_ORDER_BGR: _cairo_subpixel_order = 2;
pub const _cairo_subpixel_order_CAIRO_SUBPIXEL_ORDER_VRGB: _cairo_subpixel_order = 3;
pub const _cairo_subpixel_order_CAIRO_SUBPIXEL_ORDER_VBGR: _cairo_subpixel_order = 4;
#[doc = " cairo_subpixel_order_t:"]
#[doc = " @CAIRO_SUBPIXEL_ORDER_DEFAULT: Use the default subpixel order for"]
#[doc = "   for the target device, since 1.0"]
#[doc = " @CAIRO_SUBPIXEL_ORDER_RGB: Subpixel elements are arranged horizontally"]
#[doc = "   with red at the left, since 1.0"]
#[doc = " @CAIRO_SUBPIXEL_ORDER_BGR:  Subpixel elements are arranged horizontally"]
#[doc = "   with blue at the left, since 1.0"]
#[doc = " @CAIRO_SUBPIXEL_ORDER_VRGB: Subpixel elements are arranged vertically"]
#[doc = "   with red at the top, since 1.0"]
#[doc = " @CAIRO_SUBPIXEL_ORDER_VBGR: Subpixel elements are arranged vertically"]
#[doc = "   with blue at the top, since 1.0"]
#[doc = ""]
#[doc = " The subpixel order specifies the order of color elements within"]
#[doc = " each pixel on the display device when rendering with an"]
#[doc = " antialiasing mode of %CAIRO_ANTIALIAS_SUBPIXEL."]
#[doc = ""]
#[doc = " Since: 1.0"]
pub type _cairo_subpixel_order = u32;
#[doc = " cairo_subpixel_order_t:"]
#[doc = " @CAIRO_SUBPIXEL_ORDER_DEFAULT: Use the default subpixel order for"]
#[doc = "   for the target device, since 1.0"]
#[doc = " @CAIRO_SUBPIXEL_ORDER_RGB: Subpixel elements are arranged horizontally"]
#[doc = "   with red at the left, since 1.0"]
#[doc = " @CAIRO_SUBPIXEL_ORDER_BGR:  Subpixel elements are arranged horizontally"]
#[doc = "   with blue at the left, since 1.0"]
#[doc = " @CAIRO_SUBPIXEL_ORDER_VRGB: Subpixel elements are arranged vertically"]
#[doc = "   with red at the top, since 1.0"]
#[doc = " @CAIRO_SUBPIXEL_ORDER_VBGR: Subpixel elements are arranged vertically"]
#[doc = "   with blue at the top, since 1.0"]
#[doc = ""]
#[doc = " The subpixel order specifies the order of color elements within"]
#[doc = " each pixel on the display device when rendering with an"]
#[doc = " antialiasing mode of %CAIRO_ANTIALIAS_SUBPIXEL."]
#[doc = ""]
#[doc = " Since: 1.0"]
pub use self::_cairo_subpixel_order as cairo_subpixel_order_t;
pub const _cairo_hint_style_CAIRO_HINT_STYLE_DEFAULT: _cairo_hint_style = 0;
pub const _cairo_hint_style_CAIRO_HINT_STYLE_NONE: _cairo_hint_style = 1;
pub const _cairo_hint_style_CAIRO_HINT_STYLE_SLIGHT: _cairo_hint_style = 2;
pub const _cairo_hint_style_CAIRO_HINT_STYLE_MEDIUM: _cairo_hint_style = 3;
pub const _cairo_hint_style_CAIRO_HINT_STYLE_FULL: _cairo_hint_style = 4;
#[doc = " cairo_hint_style_t:"]
#[doc = " @CAIRO_HINT_STYLE_DEFAULT: Use the default hint style for"]
#[doc = "   font backend and target device, since 1.0"]
#[doc = " @CAIRO_HINT_STYLE_NONE: Do not hint outlines, since 1.0"]
#[doc = " @CAIRO_HINT_STYLE_SLIGHT: Hint outlines slightly to improve"]
#[doc = "   contrast while retaining good fidelity to the original"]
#[doc = "   shapes, since 1.0"]
#[doc = " @CAIRO_HINT_STYLE_MEDIUM: Hint outlines with medium strength"]
#[doc = "   giving a compromise between fidelity to the original shapes"]
#[doc = "   and contrast, since 1.0"]
#[doc = " @CAIRO_HINT_STYLE_FULL: Hint outlines to maximize contrast, since 1.0"]
#[doc = ""]
#[doc = " Specifies the type of hinting to do on font outlines. Hinting"]
#[doc = " is the process of fitting outlines to the pixel grid in order"]
#[doc = " to improve the appearance of the result. Since hinting outlines"]
#[doc = " involves distorting them, it also reduces the faithfulness"]
#[doc = " to the original outline shapes. Not all of the outline hinting"]
#[doc = " styles are supported by all font backends."]
#[doc = ""]
#[doc = " New entries may be added in future versions."]
#[doc = ""]
#[doc = " Since: 1.0"]
pub type _cairo_hint_style = u32;
#[doc = " cairo_hint_style_t:"]
#[doc = " @CAIRO_HINT_STYLE_DEFAULT: Use the default hint style for"]
#[doc = "   font backend and target device, since 1.0"]
#[doc = " @CAIRO_HINT_STYLE_NONE: Do not hint outlines, since 1.0"]
#[doc = " @CAIRO_HINT_STYLE_SLIGHT: Hint outlines slightly to improve"]
#[doc = "   contrast while retaining good fidelity to the original"]
#[doc = "   shapes, since 1.0"]
#[doc = " @CAIRO_HINT_STYLE_MEDIUM: Hint outlines with medium strength"]
#[doc = "   giving a compromise between fidelity to the original shapes"]
#[doc = "   and contrast, since 1.0"]
#[doc = " @CAIRO_HINT_STYLE_FULL: Hint outlines to maximize contrast, since 1.0"]
#[doc = ""]
#[doc = " Specifies the type of hinting to do on font outlines. Hinting"]
#[doc = " is the process of fitting outlines to the pixel grid in order"]
#[doc = " to improve the appearance of the result. Since hinting outlines"]
#[doc = " involves distorting them, it also reduces the faithfulness"]
#[doc = " to the original outline shapes. Not all of the outline hinting"]
#[doc = " styles are supported by all font backends."]
#[doc = ""]
#[doc = " New entries may be added in future versions."]
#[doc = ""]
#[doc = " Since: 1.0"]
pub use self::_cairo_hint_style as cairo_hint_style_t;
pub const _cairo_hint_metrics_CAIRO_HINT_METRICS_DEFAULT: _cairo_hint_metrics = 0;
pub const _cairo_hint_metrics_CAIRO_HINT_METRICS_OFF: _cairo_hint_metrics = 1;
pub const _cairo_hint_metrics_CAIRO_HINT_METRICS_ON: _cairo_hint_metrics = 2;
#[doc = " cairo_hint_metrics_t:"]
#[doc = " @CAIRO_HINT_METRICS_DEFAULT: Hint metrics in the default"]
#[doc = "  manner for the font backend and target device, since 1.0"]
#[doc = " @CAIRO_HINT_METRICS_OFF: Do not hint font metrics, since 1.0"]
#[doc = " @CAIRO_HINT_METRICS_ON: Hint font metrics, since 1.0"]
#[doc = ""]
#[doc = " Specifies whether to hint font metrics; hinting font metrics"]
#[doc = " means quantizing them so that they are integer values in"]
#[doc = " device space. Doing this improves the consistency of"]
#[doc = " letter and line spacing, however it also means that text"]
#[doc = " will be laid out differently at different zoom factors."]
#[doc = ""]
#[doc = " Since: 1.0"]
pub type _cairo_hint_metrics = u32;
#[doc = " cairo_hint_metrics_t:"]
#[doc = " @CAIRO_HINT_METRICS_DEFAULT: Hint metrics in the default"]
#[doc = "  manner for the font backend and target device, since 1.0"]
#[doc = " @CAIRO_HINT_METRICS_OFF: Do not hint font metrics, since 1.0"]
#[doc = " @CAIRO_HINT_METRICS_ON: Hint font metrics, since 1.0"]
#[doc = ""]
#[doc = " Specifies whether to hint font metrics; hinting font metrics"]
#[doc = " means quantizing them so that they are integer values in"]
#[doc = " device space. Doing this improves the consistency of"]
#[doc = " letter and line spacing, however it also means that text"]
#[doc = " will be laid out differently at different zoom factors."]
#[doc = ""]
#[doc = " Since: 1.0"]
pub use self::_cairo_hint_metrics as cairo_hint_metrics_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cairo_font_options {
    _unused: [u8; 0],
}
#[doc = " cairo_font_options_t:"]
#[doc = ""]
#[doc = " An opaque structure holding all options that are used when"]
#[doc = " rendering fonts."]
#[doc = ""]
#[doc = " Individual features of a #cairo_font_options_t can be set or"]
#[doc = " accessed using functions named"]
#[doc = " <function>cairo_font_options_set_<emphasis>feature_name</emphasis>()</function> and"]
#[doc = " <function>cairo_font_options_get_<emphasis>feature_name</emphasis>()</function>, like"]
#[doc = " cairo_font_options_set_antialias() and"]
#[doc = " cairo_font_options_get_antialias()."]
#[doc = ""]
#[doc = " New features may be added to a #cairo_font_options_t in the"]
#[doc = " future.  For this reason, cairo_font_options_copy(),"]
#[doc = " cairo_font_options_equal(), cairo_font_options_merge(), and"]
#[doc = " cairo_font_options_hash() should be used to copy, check"]
#[doc = " for equality, merge, or compute a hash value of"]
#[doc = " #cairo_font_options_t objects."]
#[doc = ""]
#[doc = " Since: 1.0"]
pub type cairo_font_options_t = _cairo_font_options;
extern "C" {
    pub fn cairo_font_options_create() -> *mut cairo_font_options_t;
}
extern "C" {
    pub fn cairo_font_options_copy(
        original: *const cairo_font_options_t,
    ) -> *mut cairo_font_options_t;
}
extern "C" {
    pub fn cairo_font_options_destroy(options: *mut cairo_font_options_t);
}
extern "C" {
    pub fn cairo_font_options_status(options: *mut cairo_font_options_t) -> cairo_status_t;
}
extern "C" {
    pub fn cairo_font_options_merge(
        options: *mut cairo_font_options_t,
        other: *const cairo_font_options_t,
    );
}
extern "C" {
    pub fn cairo_font_options_equal(
        options: *const cairo_font_options_t,
        other: *const cairo_font_options_t,
    ) -> cairo_bool_t;
}
extern "C" {
    pub fn cairo_font_options_hash(options: *const cairo_font_options_t) -> cty::c_ulong;
}
extern "C" {
    pub fn cairo_font_options_set_antialias(
        options: *mut cairo_font_options_t,
        antialias: cairo_antialias_t,
    );
}
extern "C" {
    pub fn cairo_font_options_get_antialias(
        options: *const cairo_font_options_t,
    ) -> cairo_antialias_t;
}
extern "C" {
    pub fn cairo_font_options_set_subpixel_order(
        options: *mut cairo_font_options_t,
        subpixel_order: cairo_subpixel_order_t,
    );
}
extern "C" {
    pub fn cairo_font_options_get_subpixel_order(
        options: *const cairo_font_options_t,
    ) -> cairo_subpixel_order_t;
}
extern "C" {
    pub fn cairo_font_options_set_hint_style(
        options: *mut cairo_font_options_t,
        hint_style: cairo_hint_style_t,
    );
}
extern "C" {
    pub fn cairo_font_options_get_hint_style(
        options: *const cairo_font_options_t,
    ) -> cairo_hint_style_t;
}
extern "C" {
    pub fn cairo_font_options_set_hint_metrics(
        options: *mut cairo_font_options_t,
        hint_metrics: cairo_hint_metrics_t,
    );
}
extern "C" {
    pub fn cairo_font_options_get_hint_metrics(
        options: *const cairo_font_options_t,
    ) -> cairo_hint_metrics_t;
}
extern "C" {
    pub fn cairo_font_options_get_variations(
        options: *mut cairo_font_options_t,
    ) -> *const cty::c_char;
}
extern "C" {
    pub fn cairo_font_options_set_variations(
        options: *mut cairo_font_options_t,
        variations: *const cty::c_char,
    );
}
extern "C" {
    pub fn cairo_select_font_face(
        cr: *mut cairo_t,
        family: *const cty::c_char,
        slant: cairo_font_slant_t,
        weight: cairo_font_weight_t,
    );
}
extern "C" {
    pub fn cairo_set_font_size(cr: *mut cairo_t, size: f64);
}
extern "C" {
    pub fn cairo_set_font_matrix(cr: *mut cairo_t, matrix: *const cairo_matrix_t);
}
extern "C" {
    pub fn cairo_get_font_matrix(cr: *mut cairo_t, matrix: *mut cairo_matrix_t);
}
extern "C" {
    pub fn cairo_set_font_options(cr: *mut cairo_t, options: *const cairo_font_options_t);
}
extern "C" {
    pub fn cairo_get_font_options(cr: *mut cairo_t, options: *mut cairo_font_options_t);
}
extern "C" {
    pub fn cairo_set_font_face(cr: *mut cairo_t, font_face: *mut cairo_font_face_t);
}
extern "C" {
    pub fn cairo_get_font_face(cr: *mut cairo_t) -> *mut cairo_font_face_t;
}
extern "C" {
    pub fn cairo_set_scaled_font(cr: *mut cairo_t, scaled_font: *const cairo_scaled_font_t);
}
extern "C" {
    pub fn cairo_get_scaled_font(cr: *mut cairo_t) -> *mut cairo_scaled_font_t;
}
extern "C" {
    pub fn cairo_show_text(cr: *mut cairo_t, utf8: *const cty::c_char);
}
extern "C" {
    pub fn cairo_show_glyphs(
        cr: *mut cairo_t,
        glyphs: *const cairo_glyph_t,
        num_glyphs: cty::c_int,
    );
}
extern "C" {
    pub fn cairo_show_text_glyphs(
        cr: *mut cairo_t,
        utf8: *const cty::c_char,
        utf8_len: cty::c_int,
        glyphs: *const cairo_glyph_t,
        num_glyphs: cty::c_int,
        clusters: *const cairo_text_cluster_t,
        num_clusters: cty::c_int,
        cluster_flags: cairo_text_cluster_flags_t,
    );
}
extern "C" {
    pub fn cairo_text_path(cr: *mut cairo_t, utf8: *const cty::c_char);
}
extern "C" {
    pub fn cairo_glyph_path(cr: *mut cairo_t, glyphs: *const cairo_glyph_t, num_glyphs: cty::c_int);
}
extern "C" {
    pub fn cairo_text_extents(
        cr: *mut cairo_t,
        utf8: *const cty::c_char,
        extents: *mut cairo_text_extents_t,
    );
}
extern "C" {
    pub fn cairo_glyph_extents(
        cr: *mut cairo_t,
        glyphs: *const cairo_glyph_t,
        num_glyphs: cty::c_int,
        extents: *mut cairo_text_extents_t,
    );
}
extern "C" {
    pub fn cairo_font_extents(cr: *mut cairo_t, extents: *mut cairo_font_extents_t);
}
extern "C" {
    pub fn cairo_font_face_reference(font_face: *mut cairo_font_face_t) -> *mut cairo_font_face_t;
}
extern "C" {
    pub fn cairo_font_face_destroy(font_face: *mut cairo_font_face_t);
}
extern "C" {
    pub fn cairo_font_face_get_reference_count(font_face: *mut cairo_font_face_t) -> cty::c_uint;
}
extern "C" {
    pub fn cairo_font_face_status(font_face: *mut cairo_font_face_t) -> cairo_status_t;
}
pub const _cairo_font_type_CAIRO_FONT_TYPE_TOY: _cairo_font_type = 0;
pub const _cairo_font_type_CAIRO_FONT_TYPE_FT: _cairo_font_type = 1;
pub const _cairo_font_type_CAIRO_FONT_TYPE_WIN32: _cairo_font_type = 2;
pub const _cairo_font_type_CAIRO_FONT_TYPE_QUARTZ: _cairo_font_type = 3;
pub const _cairo_font_type_CAIRO_FONT_TYPE_USER: _cairo_font_type = 4;
#[doc = " cairo_font_type_t:"]
#[doc = " @CAIRO_FONT_TYPE_TOY: The font was created using cairo's toy font api (Since: 1.2)"]
#[doc = " @CAIRO_FONT_TYPE_FT: The font is of type FreeType (Since: 1.2)"]
#[doc = " @CAIRO_FONT_TYPE_WIN32: The font is of type Win32 (Since: 1.2)"]
#[doc = " @CAIRO_FONT_TYPE_QUARTZ: The font is of type Quartz (Since: 1.6, in 1.2 and"]
#[doc = " 1.4 it was named CAIRO_FONT_TYPE_ATSUI)"]
#[doc = " @CAIRO_FONT_TYPE_USER: The font was create using cairo's user font api (Since: 1.8)"]
#[doc = ""]
#[doc = " #cairo_font_type_t is used to describe the type of a given font"]
#[doc = " face or scaled font. The font types are also known as \"font"]
#[doc = " backends\" within cairo."]
#[doc = ""]
#[doc = " The type of a font face is determined by the function used to"]
#[doc = " create it, which will generally be of the form"]
#[doc = " <function>cairo_<emphasis>type</emphasis>_font_face_create(<!-- -->)</function>."]
#[doc = " The font face type can be queried with cairo_font_face_get_type()"]
#[doc = ""]
#[doc = " The various #cairo_font_face_t functions can be used with a font face"]
#[doc = " of any type."]
#[doc = ""]
#[doc = " The type of a scaled font is determined by the type of the font"]
#[doc = " face passed to cairo_scaled_font_create(). The scaled font type can"]
#[doc = " be queried with cairo_scaled_font_get_type()"]
#[doc = ""]
#[doc = " The various #cairo_scaled_font_t functions can be used with scaled"]
#[doc = " fonts of any type, but some font backends also provide"]
#[doc = " type-specific functions that must only be called with a scaled font"]
#[doc = " of the appropriate type. These functions have names that begin with"]
#[doc = " <function>cairo_<emphasis>type</emphasis>_scaled_font(<!-- -->)</function>"]
#[doc = " such as cairo_ft_scaled_font_lock_face()."]
#[doc = ""]
#[doc = " The behavior of calling a type-specific function with a scaled font"]
#[doc = " of the wrong type is undefined."]
#[doc = ""]
#[doc = " New entries may be added in future versions."]
#[doc = ""]
#[doc = " Since: 1.2"]
pub type _cairo_font_type = u32;
#[doc = " cairo_font_type_t:"]
#[doc = " @CAIRO_FONT_TYPE_TOY: The font was created using cairo's toy font api (Since: 1.2)"]
#[doc = " @CAIRO_FONT_TYPE_FT: The font is of type FreeType (Since: 1.2)"]
#[doc = " @CAIRO_FONT_TYPE_WIN32: The font is of type Win32 (Since: 1.2)"]
#[doc = " @CAIRO_FONT_TYPE_QUARTZ: The font is of type Quartz (Since: 1.6, in 1.2 and"]
#[doc = " 1.4 it was named CAIRO_FONT_TYPE_ATSUI)"]
#[doc = " @CAIRO_FONT_TYPE_USER: The font was create using cairo's user font api (Since: 1.8)"]
#[doc = ""]
#[doc = " #cairo_font_type_t is used to describe the type of a given font"]
#[doc = " face or scaled font. The font types are also known as \"font"]
#[doc = " backends\" within cairo."]
#[doc = ""]
#[doc = " The type of a font face is determined by the function used to"]
#[doc = " create it, which will generally be of the form"]
#[doc = " <function>cairo_<emphasis>type</emphasis>_font_face_create(<!-- -->)</function>."]
#[doc = " The font face type can be queried with cairo_font_face_get_type()"]
#[doc = ""]
#[doc = " The various #cairo_font_face_t functions can be used with a font face"]
#[doc = " of any type."]
#[doc = ""]
#[doc = " The type of a scaled font is determined by the type of the font"]
#[doc = " face passed to cairo_scaled_font_create(). The scaled font type can"]
#[doc = " be queried with cairo_scaled_font_get_type()"]
#[doc = ""]
#[doc = " The various #cairo_scaled_font_t functions can be used with scaled"]
#[doc = " fonts of any type, but some font backends also provide"]
#[doc = " type-specific functions that must only be called with a scaled font"]
#[doc = " of the appropriate type. These functions have names that begin with"]
#[doc = " <function>cairo_<emphasis>type</emphasis>_scaled_font(<!-- -->)</function>"]
#[doc = " such as cairo_ft_scaled_font_lock_face()."]
#[doc = ""]
#[doc = " The behavior of calling a type-specific function with a scaled font"]
#[doc = " of the wrong type is undefined."]
#[doc = ""]
#[doc = " New entries may be added in future versions."]
#[doc = ""]
#[doc = " Since: 1.2"]
pub use self::_cairo_font_type as cairo_font_type_t;
extern "C" {
    pub fn cairo_font_face_get_type(font_face: *mut cairo_font_face_t) -> cairo_font_type_t;
}
extern "C" {
    pub fn cairo_font_face_get_user_data(
        font_face: *mut cairo_font_face_t,
        key: *const cairo_user_data_key_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn cairo_font_face_set_user_data(
        font_face: *mut cairo_font_face_t,
        key: *const cairo_user_data_key_t,
        user_data: *mut cty::c_void,
        destroy: cairo_destroy_func_t,
    ) -> cairo_status_t;
}
extern "C" {
    pub fn cairo_scaled_font_create(
        font_face: *mut cairo_font_face_t,
        font_matrix: *const cairo_matrix_t,
        ctm: *const cairo_matrix_t,
        options: *const cairo_font_options_t,
    ) -> *mut cairo_scaled_font_t;
}
extern "C" {
    pub fn cairo_scaled_font_reference(
        scaled_font: *mut cairo_scaled_font_t,
    ) -> *mut cairo_scaled_font_t;
}
extern "C" {
    pub fn cairo_scaled_font_destroy(scaled_font: *mut cairo_scaled_font_t);
}
extern "C" {
    pub fn cairo_scaled_font_get_reference_count(
        scaled_font: *mut cairo_scaled_font_t,
    ) -> cty::c_uint;
}
extern "C" {
    pub fn cairo_scaled_font_status(scaled_font: *mut cairo_scaled_font_t) -> cairo_status_t;
}
extern "C" {
    pub fn cairo_scaled_font_get_type(scaled_font: *mut cairo_scaled_font_t) -> cairo_font_type_t;
}
extern "C" {
    pub fn cairo_scaled_font_get_user_data(
        scaled_font: *mut cairo_scaled_font_t,
        key: *const cairo_user_data_key_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn cairo_scaled_font_set_user_data(
        scaled_font: *mut cairo_scaled_font_t,
        key: *const cairo_user_data_key_t,
        user_data: *mut cty::c_void,
        destroy: cairo_destroy_func_t,
    ) -> cairo_status_t;
}
extern "C" {
    pub fn cairo_scaled_font_extents(
        scaled_font: *mut cairo_scaled_font_t,
        extents: *mut cairo_font_extents_t,
    );
}
extern "C" {
    pub fn cairo_scaled_font_text_extents(
        scaled_font: *mut cairo_scaled_font_t,
        utf8: *const cty::c_char,
        extents: *mut cairo_text_extents_t,
    );
}
extern "C" {
    pub fn cairo_scaled_font_glyph_extents(
        scaled_font: *mut cairo_scaled_font_t,
        glyphs: *const cairo_glyph_t,
        num_glyphs: cty::c_int,
        extents: *mut cairo_text_extents_t,
    );
}
extern "C" {
    pub fn cairo_scaled_font_text_to_glyphs(
        scaled_font: *mut cairo_scaled_font_t,
        x: f64,
        y: f64,
        utf8: *const cty::c_char,
        utf8_len: cty::c_int,
        glyphs: *mut *mut cairo_glyph_t,
        num_glyphs: *mut cty::c_int,
        clusters: *mut *mut cairo_text_cluster_t,
        num_clusters: *mut cty::c_int,
        cluster_flags: *mut cairo_text_cluster_flags_t,
    ) -> cairo_status_t;
}
extern "C" {
    pub fn cairo_scaled_font_get_font_face(
        scaled_font: *mut cairo_scaled_font_t,
    ) -> *mut cairo_font_face_t;
}
extern "C" {
    pub fn cairo_scaled_font_get_font_matrix(
        scaled_font: *mut cairo_scaled_font_t,
        font_matrix: *mut cairo_matrix_t,
    );
}
extern "C" {
    pub fn cairo_scaled_font_get_ctm(
        scaled_font: *mut cairo_scaled_font_t,
        ctm: *mut cairo_matrix_t,
    );
}
extern "C" {
    pub fn cairo_scaled_font_get_scale_matrix(
        scaled_font: *mut cairo_scaled_font_t,
        scale_matrix: *mut cairo_matrix_t,
    );
}
extern "C" {
    pub fn cairo_scaled_font_get_font_options(
        scaled_font: *mut cairo_scaled_font_t,
        options: *mut cairo_font_options_t,
    );
}
extern "C" {
    pub fn cairo_toy_font_face_create(
        family: *const cty::c_char,
        slant: cairo_font_slant_t,
        weight: cairo_font_weight_t,
    ) -> *mut cairo_font_face_t;
}
extern "C" {
    pub fn cairo_toy_font_face_get_family(font_face: *mut cairo_font_face_t) -> *const cty::c_char;
}
extern "C" {
    pub fn cairo_toy_font_face_get_slant(font_face: *mut cairo_font_face_t) -> cairo_font_slant_t;
}
extern "C" {
    pub fn cairo_toy_font_face_get_weight(font_face: *mut cairo_font_face_t)
        -> cairo_font_weight_t;
}
extern "C" {
    pub fn cairo_user_font_face_create() -> *mut cairo_font_face_t;
}
#[doc = " cairo_user_scaled_font_init_func_t:"]
#[doc = " @scaled_font: the scaled-font being created"]
#[doc = " @cr: a cairo context, in font space"]
#[doc = " @extents: font extents to fill in, in font space"]
#[doc = ""]
#[doc = " #cairo_user_scaled_font_init_func_t is the type of function which is"]
#[doc = " called when a scaled-font needs to be created for a user font-face."]
#[doc = ""]
#[doc = " The cairo context @cr is not used by the caller, but is prepared in font"]
#[doc = " space, similar to what the cairo contexts passed to the render_glyph"]
#[doc = " method will look like.  The callback can use this context for extents"]
#[doc = " computation for example.  After the callback is called, @cr is checked"]
#[doc = " for any error status."]
#[doc = ""]
#[doc = " The @extents argument is where the user font sets the font extents for"]
#[doc = " @scaled_font.  It is in font space, which means that for most cases its"]
#[doc = " ascent and descent members should add to 1.0.  @extents is preset to"]
#[doc = " hold a value of 1.0 for ascent, height, and max_x_advance, and 0.0 for"]
#[doc = " descent and max_y_advance members."]
#[doc = ""]
#[doc = " The callback is optional.  If not set, default font extents as described"]
#[doc = " in the previous paragraph will be used."]
#[doc = ""]
#[doc = " Note that @scaled_font is not fully initialized at this"]
#[doc = " point and trying to use it for text operations in the callback will result"]
#[doc = " in deadlock."]
#[doc = ""]
#[doc = " Returns: %CAIRO_STATUS_SUCCESS upon success, or an error status on error."]
#[doc = ""]
#[doc = " Since: 1.8"]
pub type cairo_user_scaled_font_init_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        scaled_font: *mut cairo_scaled_font_t,
        cr: *mut cairo_t,
        extents: *mut cairo_font_extents_t,
    ) -> cairo_status_t,
>;
#[doc = " cairo_user_scaled_font_render_glyph_func_t:"]
#[doc = " @scaled_font: user scaled-font"]
#[doc = " @glyph: glyph code to render"]
#[doc = " @cr: cairo context to draw to, in font space"]
#[doc = " @extents: glyph extents to fill in, in font space"]
#[doc = ""]
#[doc = " #cairo_user_scaled_font_render_glyph_func_t is the type of function which"]
#[doc = " is called when a user scaled-font needs to render a glyph."]
#[doc = ""]
#[doc = " The callback is mandatory, and expected to draw the glyph with code @glyph to"]
#[doc = " the cairo context @cr.  @cr is prepared such that the glyph drawing is done in"]
#[doc = " font space.  That is, the matrix set on @cr is the scale matrix of @scaled_font,"]
#[doc = " The @extents argument is where the user font sets the font extents for"]
#[doc = " @scaled_font.  However, if user prefers to draw in user space, they can"]
#[doc = " achieve that by changing the matrix on @cr.  All cairo rendering operations"]
#[doc = " to @cr are permitted, however, the result is undefined if any source other"]
#[doc = " than the default source on @cr is used.  That means, glyph bitmaps should"]
#[doc = " be rendered using cairo_mask() instead of cairo_paint()."]
#[doc = ""]
#[doc = " Other non-default settings on @cr include a font size of 1.0 (given that"]
#[doc = " it is set up to be in font space), and font options corresponding to"]
#[doc = " @scaled_font."]
#[doc = ""]
#[doc = " The @extents argument is preset to have <literal>x_bearing</literal>,"]
#[doc = " <literal>width</literal>, and <literal>y_advance</literal> of zero,"]
#[doc = " <literal>y_bearing</literal> set to <literal>-font_extents.ascent</literal>,"]
#[doc = " <literal>height</literal> to <literal>font_extents.ascent+font_extents.descent</literal>,"]
#[doc = " and <literal>x_advance</literal> to <literal>font_extents.max_x_advance</literal>."]
#[doc = " The only field user needs to set in majority of cases is"]
#[doc = " <literal>x_advance</literal>."]
#[doc = " If the <literal>width</literal> field is zero upon the callback returning"]
#[doc = " (which is its preset value), the glyph extents are automatically computed"]
#[doc = " based on the drawings done to @cr.  This is in most cases exactly what the"]
#[doc = " desired behavior is.  However, if for any reason the callback sets the"]
#[doc = " extents, it must be ink extents, and include the extents of all drawing"]
#[doc = " done to @cr in the callback."]
#[doc = ""]
#[doc = " Returns: %CAIRO_STATUS_SUCCESS upon success, or"]
#[doc = " %CAIRO_STATUS_USER_FONT_ERROR or any other error status on error."]
#[doc = ""]
#[doc = " Since: 1.8"]
pub type cairo_user_scaled_font_render_glyph_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        scaled_font: *mut cairo_scaled_font_t,
        glyph: cty::c_ulong,
        cr: *mut cairo_t,
        extents: *mut cairo_text_extents_t,
    ) -> cairo_status_t,
>;
#[doc = " cairo_user_scaled_font_text_to_glyphs_func_t:"]
#[doc = " @scaled_font: the scaled-font being created"]
#[doc = " @utf8: a string of text encoded in UTF-8"]
#[doc = " @utf8_len: length of @utf8 in bytes"]
#[doc = " @glyphs: pointer to array of glyphs to fill, in font space"]
#[doc = " @num_glyphs: pointer to number of glyphs"]
#[doc = " @clusters: pointer to array of cluster mapping information to fill, or %NULL"]
#[doc = " @num_clusters: pointer to number of clusters"]
#[doc = " @cluster_flags: pointer to location to store cluster flags corresponding to the"]
#[doc = "                 output @clusters"]
#[doc = ""]
#[doc = " #cairo_user_scaled_font_text_to_glyphs_func_t is the type of function which"]
#[doc = " is called to convert input text to an array of glyphs.  This is used by the"]
#[doc = " cairo_show_text() operation."]
#[doc = ""]
#[doc = " Using this callback the user-font has full control on glyphs and their"]
#[doc = " positions.  That means, it allows for features like ligatures and kerning,"]
#[doc = " as well as complex <firstterm>shaping</firstterm> required for scripts like"]
#[doc = " Arabic and Indic."]
#[doc = ""]
#[doc = " The @num_glyphs argument is preset to the number of glyph entries available"]
#[doc = " in the @glyphs buffer. If the @glyphs buffer is %NULL, the value of"]
#[doc = " @num_glyphs will be zero.  If the provided glyph array is too short for"]
#[doc = " the conversion (or for convenience), a new glyph array may be allocated"]
#[doc = " using cairo_glyph_allocate() and placed in @glyphs.  Upon return,"]
#[doc = " @num_glyphs should contain the number of generated glyphs.  If the value"]
#[doc = " @glyphs points at has changed after the call, the caller will free the"]
#[doc = " allocated glyph array using cairo_glyph_free().  The caller will also free"]
#[doc = " the original value of @glyphs, so the callback shouldn't do so."]
#[doc = " The callback should populate the glyph indices and positions (in font space)"]
#[doc = " assuming that the text is to be shown at the origin."]
#[doc = ""]
#[doc = " If @clusters is not %NULL, @num_clusters and @cluster_flags are also"]
#[doc = " non-%NULL, and cluster mapping should be computed. The semantics of how"]
#[doc = " cluster array allocation works is similar to the glyph array.  That is,"]
#[doc = " if @clusters initially points to a non-%NULL value, that array may be used"]
#[doc = " as a cluster buffer, and @num_clusters points to the number of cluster"]
#[doc = " entries available there.  If the provided cluster array is too short for"]
#[doc = " the conversion (or for convenience), a new cluster array may be allocated"]
#[doc = " using cairo_text_cluster_allocate() and placed in @clusters.  In this case,"]
#[doc = " the original value of @clusters will still be freed by the caller.  Upon"]
#[doc = " return, @num_clusters should contain the number of generated clusters."]
#[doc = " If the value @clusters points at has changed after the call, the caller"]
#[doc = " will free the allocated cluster array using cairo_text_cluster_free()."]
#[doc = ""]
#[doc = " The callback is optional.  If @num_glyphs is negative upon"]
#[doc = " the callback returning or if the return value"]
#[doc = " is %CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED, the unicode_to_glyph callback"]
#[doc = " is tried.  See #cairo_user_scaled_font_unicode_to_glyph_func_t."]
#[doc = ""]
#[doc = " Note: While cairo does not impose any limitation on glyph indices,"]
#[doc = " some applications may assume that a glyph index fits in a 16-bit"]
#[doc = " unsigned integer.  As such, it is advised that user-fonts keep their"]
#[doc = " glyphs in the 0 to 65535 range.  Furthermore, some applications may"]
#[doc = " assume that glyph 0 is a special glyph-not-found glyph.  User-fonts"]
#[doc = " are advised to use glyph 0 for such purposes and do not use that"]
#[doc = " glyph value for other purposes."]
#[doc = ""]
#[doc = " Returns: %CAIRO_STATUS_SUCCESS upon success,"]
#[doc = " %CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED if fallback options should be tried,"]
#[doc = " or %CAIRO_STATUS_USER_FONT_ERROR or any other error status on error."]
#[doc = ""]
#[doc = " Since: 1.8"]
pub type cairo_user_scaled_font_text_to_glyphs_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        scaled_font: *mut cairo_scaled_font_t,
        utf8: *const cty::c_char,
        utf8_len: cty::c_int,
        glyphs: *mut *mut cairo_glyph_t,
        num_glyphs: *mut cty::c_int,
        clusters: *mut *mut cairo_text_cluster_t,
        num_clusters: *mut cty::c_int,
        cluster_flags: *mut cairo_text_cluster_flags_t,
    ) -> cairo_status_t,
>;
#[doc = " cairo_user_scaled_font_unicode_to_glyph_func_t:"]
#[doc = " @scaled_font: the scaled-font being created"]
#[doc = " @unicode: input unicode character code-point"]
#[doc = " @glyph_index: output glyph index"]
#[doc = ""]
#[doc = " #cairo_user_scaled_font_unicode_to_glyph_func_t is the type of function which"]
#[doc = " is called to convert an input Unicode character to a single glyph."]
#[doc = " This is used by the cairo_show_text() operation."]
#[doc = ""]
#[doc = " This callback is used to provide the same functionality as the"]
#[doc = " text_to_glyphs callback does (see #cairo_user_scaled_font_text_to_glyphs_func_t)"]
#[doc = " but has much less control on the output,"]
#[doc = " in exchange for increased ease of use.  The inherent assumption to using"]
#[doc = " this callback is that each character maps to one glyph, and that the"]
#[doc = " mapping is context independent.  It also assumes that glyphs are positioned"]
#[doc = " according to their advance width.  These mean no ligatures, kerning, or"]
#[doc = " complex scripts can be implemented using this callback."]
#[doc = ""]
#[doc = " The callback is optional, and only used if text_to_glyphs callback is not"]
#[doc = " set or fails to return glyphs.  If this callback is not set or if it returns"]
#[doc = " %CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED, an identity mapping from Unicode"]
#[doc = " code-points to glyph indices is assumed."]
#[doc = ""]
#[doc = " Note: While cairo does not impose any limitation on glyph indices,"]
#[doc = " some applications may assume that a glyph index fits in a 16-bit"]
#[doc = " unsigned integer.  As such, it is advised that user-fonts keep their"]
#[doc = " glyphs in the 0 to 65535 range.  Furthermore, some applications may"]
#[doc = " assume that glyph 0 is a special glyph-not-found glyph.  User-fonts"]
#[doc = " are advised to use glyph 0 for such purposes and do not use that"]
#[doc = " glyph value for other purposes."]
#[doc = ""]
#[doc = " Returns: %CAIRO_STATUS_SUCCESS upon success,"]
#[doc = " %CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED if fallback options should be tried,"]
#[doc = " or %CAIRO_STATUS_USER_FONT_ERROR or any other error status on error."]
#[doc = ""]
#[doc = " Since: 1.8"]
pub type cairo_user_scaled_font_unicode_to_glyph_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        scaled_font: *mut cairo_scaled_font_t,
        unicode: cty::c_ulong,
        glyph_index: *mut cty::c_ulong,
    ) -> cairo_status_t,
>;
extern "C" {
    pub fn cairo_user_font_face_set_init_func(
        font_face: *mut cairo_font_face_t,
        init_func: cairo_user_scaled_font_init_func_t,
    );
}
extern "C" {
    pub fn cairo_user_font_face_set_render_glyph_func(
        font_face: *mut cairo_font_face_t,
        render_glyph_func: cairo_user_scaled_font_render_glyph_func_t,
    );
}
extern "C" {
    pub fn cairo_user_font_face_set_text_to_glyphs_func(
        font_face: *mut cairo_font_face_t,
        text_to_glyphs_func: cairo_user_scaled_font_text_to_glyphs_func_t,
    );
}
extern "C" {
    pub fn cairo_user_font_face_set_unicode_to_glyph_func(
        font_face: *mut cairo_font_face_t,
        unicode_to_glyph_func: cairo_user_scaled_font_unicode_to_glyph_func_t,
    );
}
extern "C" {
    pub fn cairo_user_font_face_get_init_func(
        font_face: *mut cairo_font_face_t,
    ) -> cairo_user_scaled_font_init_func_t;
}
extern "C" {
    pub fn cairo_user_font_face_get_render_glyph_func(
        font_face: *mut cairo_font_face_t,
    ) -> cairo_user_scaled_font_render_glyph_func_t;
}
extern "C" {
    pub fn cairo_user_font_face_get_text_to_glyphs_func(
        font_face: *mut cairo_font_face_t,
    ) -> cairo_user_scaled_font_text_to_glyphs_func_t;
}
extern "C" {
    pub fn cairo_user_font_face_get_unicode_to_glyph_func(
        font_face: *mut cairo_font_face_t,
    ) -> cairo_user_scaled_font_unicode_to_glyph_func_t;
}
extern "C" {
    pub fn cairo_get_operator(cr: *mut cairo_t) -> cairo_operator_t;
}
extern "C" {
    pub fn cairo_get_source(cr: *mut cairo_t) -> *mut cairo_pattern_t;
}
extern "C" {
    pub fn cairo_get_tolerance(cr: *mut cairo_t) -> f64;
}
extern "C" {
    pub fn cairo_get_antialias(cr: *mut cairo_t) -> cairo_antialias_t;
}
extern "C" {
    pub fn cairo_has_current_point(cr: *mut cairo_t) -> cairo_bool_t;
}
extern "C" {
    pub fn cairo_get_current_point(cr: *mut cairo_t, x: *mut f64, y: *mut f64);
}
extern "C" {
    pub fn cairo_get_fill_rule(cr: *mut cairo_t) -> cairo_fill_rule_t;
}
extern "C" {
    pub fn cairo_get_line_width(cr: *mut cairo_t) -> f64;
}
extern "C" {
    pub fn cairo_get_line_cap(cr: *mut cairo_t) -> cairo_line_cap_t;
}
extern "C" {
    pub fn cairo_get_line_join(cr: *mut cairo_t) -> cairo_line_join_t;
}
extern "C" {
    pub fn cairo_get_miter_limit(cr: *mut cairo_t) -> f64;
}
extern "C" {
    pub fn cairo_get_dash_count(cr: *mut cairo_t) -> cty::c_int;
}
extern "C" {
    pub fn cairo_get_dash(cr: *mut cairo_t, dashes: *mut f64, offset: *mut f64);
}
extern "C" {
    pub fn cairo_get_matrix(cr: *mut cairo_t, matrix: *mut cairo_matrix_t);
}
extern "C" {
    pub fn cairo_get_target(cr: *mut cairo_t) -> *mut cairo_surface_t;
}
extern "C" {
    pub fn cairo_get_group_target(cr: *mut cairo_t) -> *mut cairo_surface_t;
}
pub const _cairo_path_data_type_CAIRO_PATH_MOVE_TO: _cairo_path_data_type = 0;
pub const _cairo_path_data_type_CAIRO_PATH_LINE_TO: _cairo_path_data_type = 1;
pub const _cairo_path_data_type_CAIRO_PATH_CURVE_TO: _cairo_path_data_type = 2;
pub const _cairo_path_data_type_CAIRO_PATH_CLOSE_PATH: _cairo_path_data_type = 3;
#[doc = " cairo_path_data_type_t:"]
#[doc = " @CAIRO_PATH_MOVE_TO: A move-to operation, since 1.0"]
#[doc = " @CAIRO_PATH_LINE_TO: A line-to operation, since 1.0"]
#[doc = " @CAIRO_PATH_CURVE_TO: A curve-to operation, since 1.0"]
#[doc = " @CAIRO_PATH_CLOSE_PATH: A close-path operation, since 1.0"]
#[doc = ""]
#[doc = " #cairo_path_data_t is used to describe the type of one portion"]
#[doc = " of a path when represented as a #cairo_path_t."]
#[doc = " See #cairo_path_data_t for details."]
#[doc = ""]
#[doc = " Since: 1.0"]
pub type _cairo_path_data_type = u32;
#[doc = " cairo_path_data_type_t:"]
#[doc = " @CAIRO_PATH_MOVE_TO: A move-to operation, since 1.0"]
#[doc = " @CAIRO_PATH_LINE_TO: A line-to operation, since 1.0"]
#[doc = " @CAIRO_PATH_CURVE_TO: A curve-to operation, since 1.0"]
#[doc = " @CAIRO_PATH_CLOSE_PATH: A close-path operation, since 1.0"]
#[doc = ""]
#[doc = " #cairo_path_data_t is used to describe the type of one portion"]
#[doc = " of a path when represented as a #cairo_path_t."]
#[doc = " See #cairo_path_data_t for details."]
#[doc = ""]
#[doc = " Since: 1.0"]
pub use self::_cairo_path_data_type as cairo_path_data_type_t;
#[doc = " cairo_path_data_t:"]
#[doc = ""]
#[doc = " #cairo_path_data_t is used to represent the path data inside a"]
#[doc = " #cairo_path_t."]
#[doc = ""]
#[doc = " The data structure is designed to try to balance the demands of"]
#[doc = " efficiency and ease-of-use. A path is represented as an array of"]
#[doc = " #cairo_path_data_t, which is a union of headers and points."]
#[doc = ""]
#[doc = " Each portion of the path is represented by one or more elements in"]
#[doc = " the array, (one header followed by 0 or more points). The length"]
#[doc = " value of the header is the number of array elements for the current"]
#[doc = " portion including the header, (ie. length == 1 + # of points), and"]
#[doc = " where the number of points for each element type is as follows:"]
#[doc = ""]
#[doc = " <programlisting>"]
#[doc = "     %CAIRO_PATH_MOVE_TO:     1 point"]
#[doc = "     %CAIRO_PATH_LINE_TO:     1 point"]
#[doc = "     %CAIRO_PATH_CURVE_TO:    3 points"]
#[doc = "     %CAIRO_PATH_CLOSE_PATH:  0 points"]
#[doc = " </programlisting>"]
#[doc = ""]
#[doc = " The semantics and ordering of the coordinate values are consistent"]
#[doc = " with cairo_move_to(), cairo_line_to(), cairo_curve_to(), and"]
#[doc = " cairo_close_path()."]
#[doc = ""]
#[doc = " Here is sample code for iterating through a #cairo_path_t:"]
#[doc = ""]
#[doc = " <informalexample><programlisting>"]
#[doc = "      int i;"]
#[doc = "      cairo_path_t *path;"]
#[doc = "      cairo_path_data_t *data;"]
#[doc = " &nbsp;"]
#[doc = "      path = cairo_copy_path (cr);"]
#[doc = " &nbsp;"]
#[doc = "      for (i=0; i < path->num_data; i += path->data[i].header.length) {"]
#[doc = "          data = &amp;path->data[i];"]
#[doc = "          switch (data->header.type) {"]
#[doc = "          case CAIRO_PATH_MOVE_TO:"]
#[doc = "              do_move_to_things (data[1].point.x, data[1].point.y);"]
#[doc = "              break;"]
#[doc = "          case CAIRO_PATH_LINE_TO:"]
#[doc = "              do_line_to_things (data[1].point.x, data[1].point.y);"]
#[doc = "              break;"]
#[doc = "          case CAIRO_PATH_CURVE_TO:"]
#[doc = "              do_curve_to_things (data[1].point.x, data[1].point.y,"]
#[doc = "                                  data[2].point.x, data[2].point.y,"]
#[doc = "                                  data[3].point.x, data[3].point.y);"]
#[doc = "              break;"]
#[doc = "          case CAIRO_PATH_CLOSE_PATH:"]
#[doc = "              do_close_path_things ();"]
#[doc = "              break;"]
#[doc = "          }"]
#[doc = "      }"]
#[doc = "      cairo_path_destroy (path);"]
#[doc = " </programlisting></informalexample>"]
#[doc = ""]
#[doc = " As of cairo 1.4, cairo does not mind if there are more elements in"]
#[doc = " a portion of the path than needed.  Such elements can be used by"]
#[doc = " users of the cairo API to hold extra values in the path data"]
#[doc = " structure.  For this reason, it is recommended that applications"]
#[doc = " always use <literal>data->header.length</literal> to"]
#[doc = " iterate over the path data, instead of hardcoding the number of"]
#[doc = " elements for each element type."]
#[doc = ""]
#[doc = " Since: 1.0"]
pub type cairo_path_data_t = _cairo_path_data_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _cairo_path_data_t {
    pub header: _cairo_path_data_t__bindgen_ty_1,
    pub point: _cairo_path_data_t__bindgen_ty_2,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cairo_path_data_t__bindgen_ty_1 {
    pub type_: cairo_path_data_type_t,
    pub length: cty::c_int,
}
#[test]
fn bindgen_test_layout__cairo_path_data_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_cairo_path_data_t__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_cairo_path_data_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_cairo_path_data_t__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_cairo_path_data_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_cairo_path_data_t__bindgen_ty_1>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cairo_path_data_t__bindgen_ty_1),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_cairo_path_data_t__bindgen_ty_1>())).length as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_cairo_path_data_t__bindgen_ty_1),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cairo_path_data_t__bindgen_ty_2 {
    pub x: f64,
    pub y: f64,
}
#[test]
fn bindgen_test_layout__cairo_path_data_t__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<_cairo_path_data_t__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(_cairo_path_data_t__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<_cairo_path_data_t__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_cairo_path_data_t__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_cairo_path_data_t__bindgen_ty_2>())).x as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cairo_path_data_t__bindgen_ty_2),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_cairo_path_data_t__bindgen_ty_2>())).y as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_cairo_path_data_t__bindgen_ty_2),
            "::",
            stringify!(y)
        )
    );
}
#[test]
fn bindgen_test_layout__cairo_path_data_t() {
    assert_eq!(
        ::core::mem::size_of::<_cairo_path_data_t>(),
        16usize,
        concat!("Size of: ", stringify!(_cairo_path_data_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cairo_path_data_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cairo_path_data_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_cairo_path_data_t>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cairo_path_data_t),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_cairo_path_data_t>())).point as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cairo_path_data_t),
            "::",
            stringify!(point)
        )
    );
}
#[doc = " cairo_path_t:"]
#[doc = " @status: the current error status"]
#[doc = " @data: the elements in the path"]
#[doc = " @num_data: the number of elements in the data array"]
#[doc = ""]
#[doc = " A data structure for holding a path. This data structure serves as"]
#[doc = " the return value for cairo_copy_path() and"]
#[doc = " cairo_copy_path_flat() as well the input value for"]
#[doc = " cairo_append_path()."]
#[doc = ""]
#[doc = " See #cairo_path_data_t for hints on how to iterate over the"]
#[doc = " actual data within the path."]
#[doc = ""]
#[doc = " The num_data member gives the number of elements in the data"]
#[doc = " array. This number is larger than the number of independent path"]
#[doc = " portions (defined in #cairo_path_data_type_t), since the data"]
#[doc = " includes both headers and coordinates for each portion."]
#[doc = ""]
#[doc = " Since: 1.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cairo_path {
    pub status: cairo_status_t,
    pub data: *mut cairo_path_data_t,
    pub num_data: cty::c_int,
}
#[test]
fn bindgen_test_layout_cairo_path() {
    assert_eq!(
        ::core::mem::size_of::<cairo_path>(),
        24usize,
        concat!("Size of: ", stringify!(cairo_path))
    );
    assert_eq!(
        ::core::mem::align_of::<cairo_path>(),
        8usize,
        concat!("Alignment of ", stringify!(cairo_path))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cairo_path>())).status as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cairo_path),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cairo_path>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cairo_path),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cairo_path>())).num_data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cairo_path),
            "::",
            stringify!(num_data)
        )
    );
}
#[doc = " cairo_path_t:"]
#[doc = " @status: the current error status"]
#[doc = " @data: the elements in the path"]
#[doc = " @num_data: the number of elements in the data array"]
#[doc = ""]
#[doc = " A data structure for holding a path. This data structure serves as"]
#[doc = " the return value for cairo_copy_path() and"]
#[doc = " cairo_copy_path_flat() as well the input value for"]
#[doc = " cairo_append_path()."]
#[doc = ""]
#[doc = " See #cairo_path_data_t for hints on how to iterate over the"]
#[doc = " actual data within the path."]
#[doc = ""]
#[doc = " The num_data member gives the number of elements in the data"]
#[doc = " array. This number is larger than the number of independent path"]
#[doc = " portions (defined in #cairo_path_data_type_t), since the data"]
#[doc = " includes both headers and coordinates for each portion."]
#[doc = ""]
#[doc = " Since: 1.0"]
pub type cairo_path_t = cairo_path;
extern "C" {
    pub fn cairo_copy_path(cr: *mut cairo_t) -> *mut cairo_path_t;
}
extern "C" {
    pub fn cairo_copy_path_flat(cr: *mut cairo_t) -> *mut cairo_path_t;
}
extern "C" {
    pub fn cairo_append_path(cr: *mut cairo_t, path: *const cairo_path_t);
}
extern "C" {
    pub fn cairo_path_destroy(path: *mut cairo_path_t);
}
extern "C" {
    pub fn cairo_status(cr: *mut cairo_t) -> cairo_status_t;
}
extern "C" {
    pub fn cairo_status_to_string(status: cairo_status_t) -> *const cty::c_char;
}
extern "C" {
    pub fn cairo_device_reference(device: *mut cairo_device_t) -> *mut cairo_device_t;
}
pub const _cairo_device_type_CAIRO_DEVICE_TYPE_DRM: _cairo_device_type = 0;
pub const _cairo_device_type_CAIRO_DEVICE_TYPE_GL: _cairo_device_type = 1;
pub const _cairo_device_type_CAIRO_DEVICE_TYPE_SCRIPT: _cairo_device_type = 2;
pub const _cairo_device_type_CAIRO_DEVICE_TYPE_XCB: _cairo_device_type = 3;
pub const _cairo_device_type_CAIRO_DEVICE_TYPE_XLIB: _cairo_device_type = 4;
pub const _cairo_device_type_CAIRO_DEVICE_TYPE_XML: _cairo_device_type = 5;
pub const _cairo_device_type_CAIRO_DEVICE_TYPE_COGL: _cairo_device_type = 6;
pub const _cairo_device_type_CAIRO_DEVICE_TYPE_WIN32: _cairo_device_type = 7;
pub const _cairo_device_type_CAIRO_DEVICE_TYPE_INVALID: _cairo_device_type = -1;
#[doc = " cairo_device_type_t:"]
#[doc = " @CAIRO_DEVICE_TYPE_DRM: The device is of type Direct Render Manager, since 1.10"]
#[doc = " @CAIRO_DEVICE_TYPE_GL: The device is of type OpenGL, since 1.10"]
#[doc = " @CAIRO_DEVICE_TYPE_SCRIPT: The device is of type script, since 1.10"]
#[doc = " @CAIRO_DEVICE_TYPE_XCB: The device is of type xcb, since 1.10"]
#[doc = " @CAIRO_DEVICE_TYPE_XLIB: The device is of type xlib, since 1.10"]
#[doc = " @CAIRO_DEVICE_TYPE_XML: The device is of type XML, since 1.10"]
#[doc = " @CAIRO_DEVICE_TYPE_COGL: The device is of type cogl, since 1.12"]
#[doc = " @CAIRO_DEVICE_TYPE_WIN32: The device is of type win32, since 1.12"]
#[doc = " @CAIRO_DEVICE_TYPE_INVALID: The device is invalid, since 1.10"]
#[doc = ""]
#[doc = " #cairo_device_type_t is used to describe the type of a given"]
#[doc = " device. The devices types are also known as \"backends\" within cairo."]
#[doc = ""]
#[doc = " The device type can be queried with cairo_device_get_type()"]
#[doc = ""]
#[doc = " The various #cairo_device_t functions can be used with devices of"]
#[doc = " any type, but some backends also provide type-specific functions"]
#[doc = " that must only be called with a device of the appropriate"]
#[doc = " type. These functions have names that begin with"]
#[doc = " <literal>cairo_<emphasis>type</emphasis>_device</literal> such as"]
#[doc = " cairo_xcb_device_debug_cap_xrender_version()."]
#[doc = ""]
#[doc = " The behavior of calling a type-specific function with a device of"]
#[doc = " the wrong type is undefined."]
#[doc = ""]
#[doc = " New entries may be added in future versions."]
#[doc = ""]
#[doc = " Since: 1.10"]
pub type _cairo_device_type = i32;
#[doc = " cairo_device_type_t:"]
#[doc = " @CAIRO_DEVICE_TYPE_DRM: The device is of type Direct Render Manager, since 1.10"]
#[doc = " @CAIRO_DEVICE_TYPE_GL: The device is of type OpenGL, since 1.10"]
#[doc = " @CAIRO_DEVICE_TYPE_SCRIPT: The device is of type script, since 1.10"]
#[doc = " @CAIRO_DEVICE_TYPE_XCB: The device is of type xcb, since 1.10"]
#[doc = " @CAIRO_DEVICE_TYPE_XLIB: The device is of type xlib, since 1.10"]
#[doc = " @CAIRO_DEVICE_TYPE_XML: The device is of type XML, since 1.10"]
#[doc = " @CAIRO_DEVICE_TYPE_COGL: The device is of type cogl, since 1.12"]
#[doc = " @CAIRO_DEVICE_TYPE_WIN32: The device is of type win32, since 1.12"]
#[doc = " @CAIRO_DEVICE_TYPE_INVALID: The device is invalid, since 1.10"]
#[doc = ""]
#[doc = " #cairo_device_type_t is used to describe the type of a given"]
#[doc = " device. The devices types are also known as \"backends\" within cairo."]
#[doc = ""]
#[doc = " The device type can be queried with cairo_device_get_type()"]
#[doc = ""]
#[doc = " The various #cairo_device_t functions can be used with devices of"]
#[doc = " any type, but some backends also provide type-specific functions"]
#[doc = " that must only be called with a device of the appropriate"]
#[doc = " type. These functions have names that begin with"]
#[doc = " <literal>cairo_<emphasis>type</emphasis>_device</literal> such as"]
#[doc = " cairo_xcb_device_debug_cap_xrender_version()."]
#[doc = ""]
#[doc = " The behavior of calling a type-specific function with a device of"]
#[doc = " the wrong type is undefined."]
#[doc = ""]
#[doc = " New entries may be added in future versions."]
#[doc = ""]
#[doc = " Since: 1.10"]
pub use self::_cairo_device_type as cairo_device_type_t;
extern "C" {
    pub fn cairo_device_get_type(device: *mut cairo_device_t) -> cairo_device_type_t;
}
extern "C" {
    pub fn cairo_device_status(device: *mut cairo_device_t) -> cairo_status_t;
}
extern "C" {
    pub fn cairo_device_acquire(device: *mut cairo_device_t) -> cairo_status_t;
}
extern "C" {
    pub fn cairo_device_release(device: *mut cairo_device_t);
}
extern "C" {
    pub fn cairo_device_flush(device: *mut cairo_device_t);
}
extern "C" {
    pub fn cairo_device_finish(device: *mut cairo_device_t);
}
extern "C" {
    pub fn cairo_device_destroy(device: *mut cairo_device_t);
}
extern "C" {
    pub fn cairo_device_get_reference_count(device: *mut cairo_device_t) -> cty::c_uint;
}
extern "C" {
    pub fn cairo_device_get_user_data(
        device: *mut cairo_device_t,
        key: *const cairo_user_data_key_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn cairo_device_set_user_data(
        device: *mut cairo_device_t,
        key: *const cairo_user_data_key_t,
        user_data: *mut cty::c_void,
        destroy: cairo_destroy_func_t,
    ) -> cairo_status_t;
}
extern "C" {
    pub fn cairo_surface_create_similar(
        other: *mut cairo_surface_t,
        content: cairo_content_t,
        width: cty::c_int,
        height: cty::c_int,
    ) -> *mut cairo_surface_t;
}
extern "C" {
    pub fn cairo_surface_create_similar_image(
        other: *mut cairo_surface_t,
        format: cairo_format_t,
        width: cty::c_int,
        height: cty::c_int,
    ) -> *mut cairo_surface_t;
}
extern "C" {
    pub fn cairo_surface_map_to_image(
        surface: *mut cairo_surface_t,
        extents: *const cairo_rectangle_int_t,
    ) -> *mut cairo_surface_t;
}
extern "C" {
    pub fn cairo_surface_unmap_image(surface: *mut cairo_surface_t, image: *mut cairo_surface_t);
}
extern "C" {
    pub fn cairo_surface_create_for_rectangle(
        target: *mut cairo_surface_t,
        x: f64,
        y: f64,
        width: f64,
        height: f64,
    ) -> *mut cairo_surface_t;
}
pub const cairo_surface_observer_mode_t_CAIRO_SURFACE_OBSERVER_NORMAL:
    cairo_surface_observer_mode_t = 0;
pub const cairo_surface_observer_mode_t_CAIRO_SURFACE_OBSERVER_RECORD_OPERATIONS:
    cairo_surface_observer_mode_t = 1;
#[doc = " cairo_surface_observer_mode_t:"]
#[doc = " @CAIRO_SURFACE_OBSERVER_NORMAL: no recording is done"]
#[doc = " @CAIRO_SURFACE_OBSERVER_RECORD_OPERATIONS: operations are recorded"]
#[doc = ""]
#[doc = " Whether operations should be recorded."]
#[doc = ""]
#[doc = " Since: 1.12"]
pub type cairo_surface_observer_mode_t = u32;
extern "C" {
    pub fn cairo_surface_create_observer(
        target: *mut cairo_surface_t,
        mode: cairo_surface_observer_mode_t,
    ) -> *mut cairo_surface_t;
}
pub type cairo_surface_observer_callback_t = ::core::option::Option<
    unsafe extern "C" fn(
        observer: *mut cairo_surface_t,
        target: *mut cairo_surface_t,
        data: *mut cty::c_void,
    ),
>;
extern "C" {
    pub fn cairo_surface_observer_add_paint_callback(
        abstract_surface: *mut cairo_surface_t,
        func: cairo_surface_observer_callback_t,
        data: *mut cty::c_void,
    ) -> cairo_status_t;
}
extern "C" {
    pub fn cairo_surface_observer_add_mask_callback(
        abstract_surface: *mut cairo_surface_t,
        func: cairo_surface_observer_callback_t,
        data: *mut cty::c_void,
    ) -> cairo_status_t;
}
extern "C" {
    pub fn cairo_surface_observer_add_fill_callback(
        abstract_surface: *mut cairo_surface_t,
        func: cairo_surface_observer_callback_t,
        data: *mut cty::c_void,
    ) -> cairo_status_t;
}
extern "C" {
    pub fn cairo_surface_observer_add_stroke_callback(
        abstract_surface: *mut cairo_surface_t,
        func: cairo_surface_observer_callback_t,
        data: *mut cty::c_void,
    ) -> cairo_status_t;
}
extern "C" {
    pub fn cairo_surface_observer_add_glyphs_callback(
        abstract_surface: *mut cairo_surface_t,
        func: cairo_surface_observer_callback_t,
        data: *mut cty::c_void,
    ) -> cairo_status_t;
}
extern "C" {
    pub fn cairo_surface_observer_add_flush_callback(
        abstract_surface: *mut cairo_surface_t,
        func: cairo_surface_observer_callback_t,
        data: *mut cty::c_void,
    ) -> cairo_status_t;
}
extern "C" {
    pub fn cairo_surface_observer_add_finish_callback(
        abstract_surface: *mut cairo_surface_t,
        func: cairo_surface_observer_callback_t,
        data: *mut cty::c_void,
    ) -> cairo_status_t;
}
extern "C" {
    pub fn cairo_surface_observer_print(
        surface: *mut cairo_surface_t,
        write_func: cairo_write_func_t,
        closure: *mut cty::c_void,
    ) -> cairo_status_t;
}
extern "C" {
    pub fn cairo_surface_observer_elapsed(surface: *mut cairo_surface_t) -> f64;
}
extern "C" {
    pub fn cairo_device_observer_print(
        device: *mut cairo_device_t,
        write_func: cairo_write_func_t,
        closure: *mut cty::c_void,
    ) -> cairo_status_t;
}
extern "C" {
    pub fn cairo_device_observer_elapsed(device: *mut cairo_device_t) -> f64;
}
extern "C" {
    pub fn cairo_device_observer_paint_elapsed(device: *mut cairo_device_t) -> f64;
}
extern "C" {
    pub fn cairo_device_observer_mask_elapsed(device: *mut cairo_device_t) -> f64;
}
extern "C" {
    pub fn cairo_device_observer_fill_elapsed(device: *mut cairo_device_t) -> f64;
}
extern "C" {
    pub fn cairo_device_observer_stroke_elapsed(device: *mut cairo_device_t) -> f64;
}
extern "C" {
    pub fn cairo_device_observer_glyphs_elapsed(device: *mut cairo_device_t) -> f64;
}
extern "C" {
    pub fn cairo_surface_reference(surface: *mut cairo_surface_t) -> *mut cairo_surface_t;
}
extern "C" {
    pub fn cairo_surface_finish(surface: *mut cairo_surface_t);
}
extern "C" {
    pub fn cairo_surface_destroy(surface: *mut cairo_surface_t);
}
extern "C" {
    pub fn cairo_surface_get_device(surface: *mut cairo_surface_t) -> *mut cairo_device_t;
}
extern "C" {
    pub fn cairo_surface_get_reference_count(surface: *mut cairo_surface_t) -> cty::c_uint;
}
extern "C" {
    pub fn cairo_surface_status(surface: *mut cairo_surface_t) -> cairo_status_t;
}
pub const _cairo_surface_type_CAIRO_SURFACE_TYPE_IMAGE: _cairo_surface_type = 0;
pub const _cairo_surface_type_CAIRO_SURFACE_TYPE_PDF: _cairo_surface_type = 1;
pub const _cairo_surface_type_CAIRO_SURFACE_TYPE_PS: _cairo_surface_type = 2;
pub const _cairo_surface_type_CAIRO_SURFACE_TYPE_XLIB: _cairo_surface_type = 3;
pub const _cairo_surface_type_CAIRO_SURFACE_TYPE_XCB: _cairo_surface_type = 4;
pub const _cairo_surface_type_CAIRO_SURFACE_TYPE_GLITZ: _cairo_surface_type = 5;
pub const _cairo_surface_type_CAIRO_SURFACE_TYPE_QUARTZ: _cairo_surface_type = 6;
pub const _cairo_surface_type_CAIRO_SURFACE_TYPE_WIN32: _cairo_surface_type = 7;
pub const _cairo_surface_type_CAIRO_SURFACE_TYPE_BEOS: _cairo_surface_type = 8;
pub const _cairo_surface_type_CAIRO_SURFACE_TYPE_DIRECTFB: _cairo_surface_type = 9;
pub const _cairo_surface_type_CAIRO_SURFACE_TYPE_SVG: _cairo_surface_type = 10;
pub const _cairo_surface_type_CAIRO_SURFACE_TYPE_OS2: _cairo_surface_type = 11;
pub const _cairo_surface_type_CAIRO_SURFACE_TYPE_WIN32_PRINTING: _cairo_surface_type = 12;
pub const _cairo_surface_type_CAIRO_SURFACE_TYPE_QUARTZ_IMAGE: _cairo_surface_type = 13;
pub const _cairo_surface_type_CAIRO_SURFACE_TYPE_SCRIPT: _cairo_surface_type = 14;
pub const _cairo_surface_type_CAIRO_SURFACE_TYPE_QT: _cairo_surface_type = 15;
pub const _cairo_surface_type_CAIRO_SURFACE_TYPE_RECORDING: _cairo_surface_type = 16;
pub const _cairo_surface_type_CAIRO_SURFACE_TYPE_VG: _cairo_surface_type = 17;
pub const _cairo_surface_type_CAIRO_SURFACE_TYPE_GL: _cairo_surface_type = 18;
pub const _cairo_surface_type_CAIRO_SURFACE_TYPE_DRM: _cairo_surface_type = 19;
pub const _cairo_surface_type_CAIRO_SURFACE_TYPE_TEE: _cairo_surface_type = 20;
pub const _cairo_surface_type_CAIRO_SURFACE_TYPE_XML: _cairo_surface_type = 21;
pub const _cairo_surface_type_CAIRO_SURFACE_TYPE_SKIA: _cairo_surface_type = 22;
pub const _cairo_surface_type_CAIRO_SURFACE_TYPE_SUBSURFACE: _cairo_surface_type = 23;
pub const _cairo_surface_type_CAIRO_SURFACE_TYPE_COGL: _cairo_surface_type = 24;
#[doc = " cairo_surface_type_t:"]
#[doc = " @CAIRO_SURFACE_TYPE_IMAGE: The surface is of type image, since 1.2"]
#[doc = " @CAIRO_SURFACE_TYPE_PDF: The surface is of type pdf, since 1.2"]
#[doc = " @CAIRO_SURFACE_TYPE_PS: The surface is of type ps, since 1.2"]
#[doc = " @CAIRO_SURFACE_TYPE_XLIB: The surface is of type xlib, since 1.2"]
#[doc = " @CAIRO_SURFACE_TYPE_XCB: The surface is of type xcb, since 1.2"]
#[doc = " @CAIRO_SURFACE_TYPE_GLITZ: The surface is of type glitz, since 1.2"]
#[doc = " @CAIRO_SURFACE_TYPE_QUARTZ: The surface is of type quartz, since 1.2"]
#[doc = " @CAIRO_SURFACE_TYPE_WIN32: The surface is of type win32, since 1.2"]
#[doc = " @CAIRO_SURFACE_TYPE_BEOS: The surface is of type beos, since 1.2"]
#[doc = " @CAIRO_SURFACE_TYPE_DIRECTFB: The surface is of type directfb, since 1.2"]
#[doc = " @CAIRO_SURFACE_TYPE_SVG: The surface is of type svg, since 1.2"]
#[doc = " @CAIRO_SURFACE_TYPE_OS2: The surface is of type os2, since 1.4"]
#[doc = " @CAIRO_SURFACE_TYPE_WIN32_PRINTING: The surface is a win32 printing surface, since 1.6"]
#[doc = " @CAIRO_SURFACE_TYPE_QUARTZ_IMAGE: The surface is of type quartz_image, since 1.6"]
#[doc = " @CAIRO_SURFACE_TYPE_SCRIPT: The surface is of type script, since 1.10"]
#[doc = " @CAIRO_SURFACE_TYPE_QT: The surface is of type Qt, since 1.10"]
#[doc = " @CAIRO_SURFACE_TYPE_RECORDING: The surface is of type recording, since 1.10"]
#[doc = " @CAIRO_SURFACE_TYPE_VG: The surface is a OpenVG surface, since 1.10"]
#[doc = " @CAIRO_SURFACE_TYPE_GL: The surface is of type OpenGL, since 1.10"]
#[doc = " @CAIRO_SURFACE_TYPE_DRM: The surface is of type Direct Render Manager, since 1.10"]
#[doc = " @CAIRO_SURFACE_TYPE_TEE: The surface is of type 'tee' (a multiplexing surface), since 1.10"]
#[doc = " @CAIRO_SURFACE_TYPE_XML: The surface is of type XML (for debugging), since 1.10"]
#[doc = " @CAIRO_SURFACE_TYPE_SUBSURFACE: The surface is a subsurface created with"]
#[doc = "   cairo_surface_create_for_rectangle(), since 1.10"]
#[doc = " @CAIRO_SURFACE_TYPE_COGL: This surface is of type Cogl, since 1.12"]
#[doc = ""]
#[doc = " #cairo_surface_type_t is used to describe the type of a given"]
#[doc = " surface. The surface types are also known as \"backends\" or \"surface"]
#[doc = " backends\" within cairo."]
#[doc = ""]
#[doc = " The type of a surface is determined by the function used to create"]
#[doc = " it, which will generally be of the form"]
#[doc = " <function>cairo_<emphasis>type</emphasis>_surface_create(<!-- -->)</function>,"]
#[doc = " (though see cairo_surface_create_similar() as well)."]
#[doc = ""]
#[doc = " The surface type can be queried with cairo_surface_get_type()"]
#[doc = ""]
#[doc = " The various #cairo_surface_t functions can be used with surfaces of"]
#[doc = " any type, but some backends also provide type-specific functions"]
#[doc = " that must only be called with a surface of the appropriate"]
#[doc = " type. These functions have names that begin with"]
#[doc = " <literal>cairo_<emphasis>type</emphasis>_surface</literal> such as cairo_image_surface_get_width()."]
#[doc = ""]
#[doc = " The behavior of calling a type-specific function with a surface of"]
#[doc = " the wrong type is undefined."]
#[doc = ""]
#[doc = " New entries may be added in future versions."]
#[doc = ""]
#[doc = " Since: 1.2"]
pub type _cairo_surface_type = u32;
#[doc = " cairo_surface_type_t:"]
#[doc = " @CAIRO_SURFACE_TYPE_IMAGE: The surface is of type image, since 1.2"]
#[doc = " @CAIRO_SURFACE_TYPE_PDF: The surface is of type pdf, since 1.2"]
#[doc = " @CAIRO_SURFACE_TYPE_PS: The surface is of type ps, since 1.2"]
#[doc = " @CAIRO_SURFACE_TYPE_XLIB: The surface is of type xlib, since 1.2"]
#[doc = " @CAIRO_SURFACE_TYPE_XCB: The surface is of type xcb, since 1.2"]
#[doc = " @CAIRO_SURFACE_TYPE_GLITZ: The surface is of type glitz, since 1.2"]
#[doc = " @CAIRO_SURFACE_TYPE_QUARTZ: The surface is of type quartz, since 1.2"]
#[doc = " @CAIRO_SURFACE_TYPE_WIN32: The surface is of type win32, since 1.2"]
#[doc = " @CAIRO_SURFACE_TYPE_BEOS: The surface is of type beos, since 1.2"]
#[doc = " @CAIRO_SURFACE_TYPE_DIRECTFB: The surface is of type directfb, since 1.2"]
#[doc = " @CAIRO_SURFACE_TYPE_SVG: The surface is of type svg, since 1.2"]
#[doc = " @CAIRO_SURFACE_TYPE_OS2: The surface is of type os2, since 1.4"]
#[doc = " @CAIRO_SURFACE_TYPE_WIN32_PRINTING: The surface is a win32 printing surface, since 1.6"]
#[doc = " @CAIRO_SURFACE_TYPE_QUARTZ_IMAGE: The surface is of type quartz_image, since 1.6"]
#[doc = " @CAIRO_SURFACE_TYPE_SCRIPT: The surface is of type script, since 1.10"]
#[doc = " @CAIRO_SURFACE_TYPE_QT: The surface is of type Qt, since 1.10"]
#[doc = " @CAIRO_SURFACE_TYPE_RECORDING: The surface is of type recording, since 1.10"]
#[doc = " @CAIRO_SURFACE_TYPE_VG: The surface is a OpenVG surface, since 1.10"]
#[doc = " @CAIRO_SURFACE_TYPE_GL: The surface is of type OpenGL, since 1.10"]
#[doc = " @CAIRO_SURFACE_TYPE_DRM: The surface is of type Direct Render Manager, since 1.10"]
#[doc = " @CAIRO_SURFACE_TYPE_TEE: The surface is of type 'tee' (a multiplexing surface), since 1.10"]
#[doc = " @CAIRO_SURFACE_TYPE_XML: The surface is of type XML (for debugging), since 1.10"]
#[doc = " @CAIRO_SURFACE_TYPE_SUBSURFACE: The surface is a subsurface created with"]
#[doc = "   cairo_surface_create_for_rectangle(), since 1.10"]
#[doc = " @CAIRO_SURFACE_TYPE_COGL: This surface is of type Cogl, since 1.12"]
#[doc = ""]
#[doc = " #cairo_surface_type_t is used to describe the type of a given"]
#[doc = " surface. The surface types are also known as \"backends\" or \"surface"]
#[doc = " backends\" within cairo."]
#[doc = ""]
#[doc = " The type of a surface is determined by the function used to create"]
#[doc = " it, which will generally be of the form"]
#[doc = " <function>cairo_<emphasis>type</emphasis>_surface_create(<!-- -->)</function>,"]
#[doc = " (though see cairo_surface_create_similar() as well)."]
#[doc = ""]
#[doc = " The surface type can be queried with cairo_surface_get_type()"]
#[doc = ""]
#[doc = " The various #cairo_surface_t functions can be used with surfaces of"]
#[doc = " any type, but some backends also provide type-specific functions"]
#[doc = " that must only be called with a surface of the appropriate"]
#[doc = " type. These functions have names that begin with"]
#[doc = " <literal>cairo_<emphasis>type</emphasis>_surface</literal> such as cairo_image_surface_get_width()."]
#[doc = ""]
#[doc = " The behavior of calling a type-specific function with a surface of"]
#[doc = " the wrong type is undefined."]
#[doc = ""]
#[doc = " New entries may be added in future versions."]
#[doc = ""]
#[doc = " Since: 1.2"]
pub use self::_cairo_surface_type as cairo_surface_type_t;
extern "C" {
    pub fn cairo_surface_get_type(surface: *mut cairo_surface_t) -> cairo_surface_type_t;
}
extern "C" {
    pub fn cairo_surface_get_content(surface: *mut cairo_surface_t) -> cairo_content_t;
}
extern "C" {
    pub fn cairo_surface_write_to_png(
        surface: *mut cairo_surface_t,
        filename: *const cty::c_char,
    ) -> cairo_status_t;
}
extern "C" {
    pub fn cairo_surface_write_to_png_stream(
        surface: *mut cairo_surface_t,
        write_func: cairo_write_func_t,
        closure: *mut cty::c_void,
    ) -> cairo_status_t;
}
extern "C" {
    pub fn cairo_surface_get_user_data(
        surface: *mut cairo_surface_t,
        key: *const cairo_user_data_key_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn cairo_surface_set_user_data(
        surface: *mut cairo_surface_t,
        key: *const cairo_user_data_key_t,
        user_data: *mut cty::c_void,
        destroy: cairo_destroy_func_t,
    ) -> cairo_status_t;
}
extern "C" {
    pub fn cairo_surface_get_mime_data(
        surface: *mut cairo_surface_t,
        mime_type: *const cty::c_char,
        data: *mut *const cty::c_uchar,
        length: *mut cty::c_ulong,
    );
}
extern "C" {
    pub fn cairo_surface_set_mime_data(
        surface: *mut cairo_surface_t,
        mime_type: *const cty::c_char,
        data: *const cty::c_uchar,
        length: cty::c_ulong,
        destroy: cairo_destroy_func_t,
        closure: *mut cty::c_void,
    ) -> cairo_status_t;
}
extern "C" {
    pub fn cairo_surface_supports_mime_type(
        surface: *mut cairo_surface_t,
        mime_type: *const cty::c_char,
    ) -> cairo_bool_t;
}
extern "C" {
    pub fn cairo_surface_get_font_options(
        surface: *mut cairo_surface_t,
        options: *mut cairo_font_options_t,
    );
}
extern "C" {
    pub fn cairo_surface_flush(surface: *mut cairo_surface_t);
}
extern "C" {
    pub fn cairo_surface_mark_dirty(surface: *mut cairo_surface_t);
}
extern "C" {
    pub fn cairo_surface_mark_dirty_rectangle(
        surface: *mut cairo_surface_t,
        x: cty::c_int,
        y: cty::c_int,
        width: cty::c_int,
        height: cty::c_int,
    );
}
extern "C" {
    pub fn cairo_surface_set_device_scale(
        surface: *mut cairo_surface_t,
        x_scale: f64,
        y_scale: f64,
    );
}
extern "C" {
    pub fn cairo_surface_get_device_scale(
        surface: *mut cairo_surface_t,
        x_scale: *mut f64,
        y_scale: *mut f64,
    );
}
extern "C" {
    pub fn cairo_surface_set_device_offset(
        surface: *mut cairo_surface_t,
        x_offset: f64,
        y_offset: f64,
    );
}
extern "C" {
    pub fn cairo_surface_get_device_offset(
        surface: *mut cairo_surface_t,
        x_offset: *mut f64,
        y_offset: *mut f64,
    );
}
extern "C" {
    pub fn cairo_surface_set_fallback_resolution(
        surface: *mut cairo_surface_t,
        x_pixels_per_inch: f64,
        y_pixels_per_inch: f64,
    );
}
extern "C" {
    pub fn cairo_surface_get_fallback_resolution(
        surface: *mut cairo_surface_t,
        x_pixels_per_inch: *mut f64,
        y_pixels_per_inch: *mut f64,
    );
}
extern "C" {
    pub fn cairo_surface_copy_page(surface: *mut cairo_surface_t);
}
extern "C" {
    pub fn cairo_surface_show_page(surface: *mut cairo_surface_t);
}
extern "C" {
    pub fn cairo_surface_has_show_text_glyphs(surface: *mut cairo_surface_t) -> cairo_bool_t;
}
extern "C" {
    pub fn cairo_image_surface_create(
        format: cairo_format_t,
        width: cty::c_int,
        height: cty::c_int,
    ) -> *mut cairo_surface_t;
}
extern "C" {
    pub fn cairo_format_stride_for_width(format: cairo_format_t, width: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn cairo_image_surface_create_for_data(
        data: *mut cty::c_uchar,
        format: cairo_format_t,
        width: cty::c_int,
        height: cty::c_int,
        stride: cty::c_int,
    ) -> *mut cairo_surface_t;
}
extern "C" {
    pub fn cairo_image_surface_get_data(surface: *mut cairo_surface_t) -> *mut cty::c_uchar;
}
extern "C" {
    pub fn cairo_image_surface_get_format(surface: *mut cairo_surface_t) -> cairo_format_t;
}
extern "C" {
    pub fn cairo_image_surface_get_width(surface: *mut cairo_surface_t) -> cty::c_int;
}
extern "C" {
    pub fn cairo_image_surface_get_height(surface: *mut cairo_surface_t) -> cty::c_int;
}
extern "C" {
    pub fn cairo_image_surface_get_stride(surface: *mut cairo_surface_t) -> cty::c_int;
}
extern "C" {
    pub fn cairo_image_surface_create_from_png(
        filename: *const cty::c_char,
    ) -> *mut cairo_surface_t;
}
extern "C" {
    pub fn cairo_image_surface_create_from_png_stream(
        read_func: cairo_read_func_t,
        closure: *mut cty::c_void,
    ) -> *mut cairo_surface_t;
}
extern "C" {
    pub fn cairo_recording_surface_create(
        content: cairo_content_t,
        extents: *const cairo_rectangle_t,
    ) -> *mut cairo_surface_t;
}
extern "C" {
    pub fn cairo_recording_surface_ink_extents(
        surface: *mut cairo_surface_t,
        x0: *mut f64,
        y0: *mut f64,
        width: *mut f64,
        height: *mut f64,
    );
}
extern "C" {
    pub fn cairo_recording_surface_get_extents(
        surface: *mut cairo_surface_t,
        extents: *mut cairo_rectangle_t,
    ) -> cairo_bool_t;
}
#[doc = " cairo_raster_source_acquire_func_t:"]
#[doc = " @pattern: the pattern being rendered from"]
#[doc = " @callback_data: the user data supplied during creation"]
#[doc = " @target: the rendering target surface"]
#[doc = " @extents: rectangular region of interest in pixels in sample space"]
#[doc = ""]
#[doc = " #cairo_raster_source_acquire_func_t is the type of function which is"]
#[doc = " called when a pattern is being rendered from. It should create a surface"]
#[doc = " that provides the pixel data for the region of interest as defined by"]
#[doc = " extents, though the surface itself does not have to be limited to that"]
#[doc = " area. For convenience the surface should probably be of image type,"]
#[doc = " created with cairo_surface_create_similar_image() for the target (which"]
#[doc = " enables the number of copies to be reduced during transfer to the"]
#[doc = " device). Another option, might be to return a similar surface to the"]
#[doc = " target for explicit handling by the application of a set of cached sources"]
#[doc = " on the device. The region of sample data provided should be defined using"]
#[doc = " cairo_surface_set_device_offset() to specify the top-left corner of the"]
#[doc = " sample data (along with width and height of the surface)."]
#[doc = ""]
#[doc = " Returns: a #cairo_surface_t"]
#[doc = ""]
#[doc = " Since: 1.12"]
pub type cairo_raster_source_acquire_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        pattern: *mut cairo_pattern_t,
        callback_data: *mut cty::c_void,
        target: *mut cairo_surface_t,
        extents: *const cairo_rectangle_int_t,
    ) -> *mut cairo_surface_t,
>;
#[doc = " cairo_raster_source_release_func_t:"]
#[doc = " @pattern: the pattern being rendered from"]
#[doc = " @callback_data: the user data supplied during creation"]
#[doc = " @surface: the surface created during acquire"]
#[doc = ""]
#[doc = " #cairo_raster_source_release_func_t is the type of function which is"]
#[doc = " called when the pixel data is no longer being access by the pattern"]
#[doc = " for the rendering operation. Typically this function will simply"]
#[doc = " destroy the surface created during acquire."]
#[doc = ""]
#[doc = " Since: 1.12"]
pub type cairo_raster_source_release_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        pattern: *mut cairo_pattern_t,
        callback_data: *mut cty::c_void,
        surface: *mut cairo_surface_t,
    ),
>;
#[doc = " cairo_raster_source_snapshot_func_t:"]
#[doc = " @pattern: the pattern being rendered from"]
#[doc = " @callback_data: the user data supplied during creation"]
#[doc = ""]
#[doc = " #cairo_raster_source_snapshot_func_t is the type of function which is"]
#[doc = " called when the pixel data needs to be preserved for later use"]
#[doc = " during printing. This pattern will be accessed again later, and it"]
#[doc = " is expected to provide the pixel data that was current at the time"]
#[doc = " of snapshotting."]
#[doc = ""]
#[doc = " Return value: CAIRO_STATUS_SUCCESS on success, or one of the"]
#[doc = " #cairo_status_t error codes for failure."]
#[doc = ""]
#[doc = " Since: 1.12"]
pub type cairo_raster_source_snapshot_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        pattern: *mut cairo_pattern_t,
        callback_data: *mut cty::c_void,
    ) -> cairo_status_t,
>;
#[doc = " cairo_raster_source_copy_func_t:"]
#[doc = " @pattern: the #cairo_pattern_t that was copied to"]
#[doc = " @callback_data: the user data supplied during creation"]
#[doc = " @other: the #cairo_pattern_t being used as the source for the copy"]
#[doc = ""]
#[doc = " #cairo_raster_source_copy_func_t is the type of function which is"]
#[doc = " called when the pattern gets copied as a normal part of rendering."]
#[doc = ""]
#[doc = " Return value: CAIRO_STATUS_SUCCESS on success, or one of the"]
#[doc = " #cairo_status_t error codes for failure."]
#[doc = ""]
#[doc = " Since: 1.12"]
pub type cairo_raster_source_copy_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        pattern: *mut cairo_pattern_t,
        callback_data: *mut cty::c_void,
        other: *const cairo_pattern_t,
    ) -> cairo_status_t,
>;
#[doc = " cairo_raster_source_finish_func_t:"]
#[doc = " @pattern: the pattern being rendered from"]
#[doc = " @callback_data: the user data supplied during creation"]
#[doc = ""]
#[doc = " #cairo_raster_source_finish_func_t is the type of function which is"]
#[doc = " called when the pattern (or a copy thereof) is no longer required."]
#[doc = ""]
#[doc = " Since: 1.12"]
pub type cairo_raster_source_finish_func_t = ::core::option::Option<
    unsafe extern "C" fn(pattern: *mut cairo_pattern_t, callback_data: *mut cty::c_void),
>;
extern "C" {
    pub fn cairo_pattern_create_raster_source(
        user_data: *mut cty::c_void,
        content: cairo_content_t,
        width: cty::c_int,
        height: cty::c_int,
    ) -> *mut cairo_pattern_t;
}
extern "C" {
    pub fn cairo_raster_source_pattern_set_callback_data(
        pattern: *mut cairo_pattern_t,
        data: *mut cty::c_void,
    );
}
extern "C" {
    pub fn cairo_raster_source_pattern_get_callback_data(
        pattern: *mut cairo_pattern_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn cairo_raster_source_pattern_set_acquire(
        pattern: *mut cairo_pattern_t,
        acquire: cairo_raster_source_acquire_func_t,
        release: cairo_raster_source_release_func_t,
    );
}
extern "C" {
    pub fn cairo_raster_source_pattern_get_acquire(
        pattern: *mut cairo_pattern_t,
        acquire: *mut cairo_raster_source_acquire_func_t,
        release: *mut cairo_raster_source_release_func_t,
    );
}
extern "C" {
    pub fn cairo_raster_source_pattern_set_snapshot(
        pattern: *mut cairo_pattern_t,
        snapshot: cairo_raster_source_snapshot_func_t,
    );
}
extern "C" {
    pub fn cairo_raster_source_pattern_get_snapshot(
        pattern: *mut cairo_pattern_t,
    ) -> cairo_raster_source_snapshot_func_t;
}
extern "C" {
    pub fn cairo_raster_source_pattern_set_copy(
        pattern: *mut cairo_pattern_t,
        copy: cairo_raster_source_copy_func_t,
    );
}
extern "C" {
    pub fn cairo_raster_source_pattern_get_copy(
        pattern: *mut cairo_pattern_t,
    ) -> cairo_raster_source_copy_func_t;
}
extern "C" {
    pub fn cairo_raster_source_pattern_set_finish(
        pattern: *mut cairo_pattern_t,
        finish: cairo_raster_source_finish_func_t,
    );
}
extern "C" {
    pub fn cairo_raster_source_pattern_get_finish(
        pattern: *mut cairo_pattern_t,
    ) -> cairo_raster_source_finish_func_t;
}
extern "C" {
    pub fn cairo_pattern_create_rgb(red: f64, green: f64, blue: f64) -> *mut cairo_pattern_t;
}
extern "C" {
    pub fn cairo_pattern_create_rgba(
        red: f64,
        green: f64,
        blue: f64,
        alpha: f64,
    ) -> *mut cairo_pattern_t;
}
extern "C" {
    pub fn cairo_pattern_create_for_surface(surface: *mut cairo_surface_t) -> *mut cairo_pattern_t;
}
extern "C" {
    pub fn cairo_pattern_create_linear(x0: f64, y0: f64, x1: f64, y1: f64) -> *mut cairo_pattern_t;
}
extern "C" {
    pub fn cairo_pattern_create_radial(
        cx0: f64,
        cy0: f64,
        radius0: f64,
        cx1: f64,
        cy1: f64,
        radius1: f64,
    ) -> *mut cairo_pattern_t;
}
extern "C" {
    pub fn cairo_pattern_create_mesh() -> *mut cairo_pattern_t;
}
extern "C" {
    pub fn cairo_pattern_reference(pattern: *mut cairo_pattern_t) -> *mut cairo_pattern_t;
}
extern "C" {
    pub fn cairo_pattern_destroy(pattern: *mut cairo_pattern_t);
}
extern "C" {
    pub fn cairo_pattern_get_reference_count(pattern: *mut cairo_pattern_t) -> cty::c_uint;
}
extern "C" {
    pub fn cairo_pattern_status(pattern: *mut cairo_pattern_t) -> cairo_status_t;
}
extern "C" {
    pub fn cairo_pattern_get_user_data(
        pattern: *mut cairo_pattern_t,
        key: *const cairo_user_data_key_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn cairo_pattern_set_user_data(
        pattern: *mut cairo_pattern_t,
        key: *const cairo_user_data_key_t,
        user_data: *mut cty::c_void,
        destroy: cairo_destroy_func_t,
    ) -> cairo_status_t;
}
pub const _cairo_pattern_type_CAIRO_PATTERN_TYPE_SOLID: _cairo_pattern_type = 0;
pub const _cairo_pattern_type_CAIRO_PATTERN_TYPE_SURFACE: _cairo_pattern_type = 1;
pub const _cairo_pattern_type_CAIRO_PATTERN_TYPE_LINEAR: _cairo_pattern_type = 2;
pub const _cairo_pattern_type_CAIRO_PATTERN_TYPE_RADIAL: _cairo_pattern_type = 3;
pub const _cairo_pattern_type_CAIRO_PATTERN_TYPE_MESH: _cairo_pattern_type = 4;
pub const _cairo_pattern_type_CAIRO_PATTERN_TYPE_RASTER_SOURCE: _cairo_pattern_type = 5;
#[doc = " cairo_pattern_type_t:"]
#[doc = " @CAIRO_PATTERN_TYPE_SOLID: The pattern is a solid (uniform)"]
#[doc = " color. It may be opaque or translucent, since 1.2."]
#[doc = " @CAIRO_PATTERN_TYPE_SURFACE: The pattern is a based on a surface (an image), since 1.2."]
#[doc = " @CAIRO_PATTERN_TYPE_LINEAR: The pattern is a linear gradient, since 1.2."]
#[doc = " @CAIRO_PATTERN_TYPE_RADIAL: The pattern is a radial gradient, since 1.2."]
#[doc = " @CAIRO_PATTERN_TYPE_MESH: The pattern is a mesh, since 1.12."]
#[doc = " @CAIRO_PATTERN_TYPE_RASTER_SOURCE: The pattern is a user pattern providing raster data, since 1.12."]
#[doc = ""]
#[doc = " #cairo_pattern_type_t is used to describe the type of a given pattern."]
#[doc = ""]
#[doc = " The type of a pattern is determined by the function used to create"]
#[doc = " it. The cairo_pattern_create_rgb() and cairo_pattern_create_rgba()"]
#[doc = " functions create SOLID patterns. The remaining"]
#[doc = " cairo_pattern_create<!-- --> functions map to pattern types in obvious"]
#[doc = " ways."]
#[doc = ""]
#[doc = " The pattern type can be queried with cairo_pattern_get_type()"]
#[doc = ""]
#[doc = " Most #cairo_pattern_t functions can be called with a pattern of any"]
#[doc = " type, (though trying to change the extend or filter for a solid"]
#[doc = " pattern will have no effect). A notable exception is"]
#[doc = " cairo_pattern_add_color_stop_rgb() and"]
#[doc = " cairo_pattern_add_color_stop_rgba() which must only be called with"]
#[doc = " gradient patterns (either LINEAR or RADIAL). Otherwise the pattern"]
#[doc = " will be shutdown and put into an error state."]
#[doc = ""]
#[doc = " New entries may be added in future versions."]
#[doc = ""]
#[doc = " Since: 1.2"]
pub type _cairo_pattern_type = u32;
#[doc = " cairo_pattern_type_t:"]
#[doc = " @CAIRO_PATTERN_TYPE_SOLID: The pattern is a solid (uniform)"]
#[doc = " color. It may be opaque or translucent, since 1.2."]
#[doc = " @CAIRO_PATTERN_TYPE_SURFACE: The pattern is a based on a surface (an image), since 1.2."]
#[doc = " @CAIRO_PATTERN_TYPE_LINEAR: The pattern is a linear gradient, since 1.2."]
#[doc = " @CAIRO_PATTERN_TYPE_RADIAL: The pattern is a radial gradient, since 1.2."]
#[doc = " @CAIRO_PATTERN_TYPE_MESH: The pattern is a mesh, since 1.12."]
#[doc = " @CAIRO_PATTERN_TYPE_RASTER_SOURCE: The pattern is a user pattern providing raster data, since 1.12."]
#[doc = ""]
#[doc = " #cairo_pattern_type_t is used to describe the type of a given pattern."]
#[doc = ""]
#[doc = " The type of a pattern is determined by the function used to create"]
#[doc = " it. The cairo_pattern_create_rgb() and cairo_pattern_create_rgba()"]
#[doc = " functions create SOLID patterns. The remaining"]
#[doc = " cairo_pattern_create<!-- --> functions map to pattern types in obvious"]
#[doc = " ways."]
#[doc = ""]
#[doc = " The pattern type can be queried with cairo_pattern_get_type()"]
#[doc = ""]
#[doc = " Most #cairo_pattern_t functions can be called with a pattern of any"]
#[doc = " type, (though trying to change the extend or filter for a solid"]
#[doc = " pattern will have no effect). A notable exception is"]
#[doc = " cairo_pattern_add_color_stop_rgb() and"]
#[doc = " cairo_pattern_add_color_stop_rgba() which must only be called with"]
#[doc = " gradient patterns (either LINEAR or RADIAL). Otherwise the pattern"]
#[doc = " will be shutdown and put into an error state."]
#[doc = ""]
#[doc = " New entries may be added in future versions."]
#[doc = ""]
#[doc = " Since: 1.2"]
pub use self::_cairo_pattern_type as cairo_pattern_type_t;
extern "C" {
    pub fn cairo_pattern_get_type(pattern: *mut cairo_pattern_t) -> cairo_pattern_type_t;
}
extern "C" {
    pub fn cairo_pattern_add_color_stop_rgb(
        pattern: *mut cairo_pattern_t,
        offset: f64,
        red: f64,
        green: f64,
        blue: f64,
    );
}
extern "C" {
    pub fn cairo_pattern_add_color_stop_rgba(
        pattern: *mut cairo_pattern_t,
        offset: f64,
        red: f64,
        green: f64,
        blue: f64,
        alpha: f64,
    );
}
extern "C" {
    pub fn cairo_mesh_pattern_begin_patch(pattern: *mut cairo_pattern_t);
}
extern "C" {
    pub fn cairo_mesh_pattern_end_patch(pattern: *mut cairo_pattern_t);
}
extern "C" {
    pub fn cairo_mesh_pattern_curve_to(
        pattern: *mut cairo_pattern_t,
        x1: f64,
        y1: f64,
        x2: f64,
        y2: f64,
        x3: f64,
        y3: f64,
    );
}
extern "C" {
    pub fn cairo_mesh_pattern_line_to(pattern: *mut cairo_pattern_t, x: f64, y: f64);
}
extern "C" {
    pub fn cairo_mesh_pattern_move_to(pattern: *mut cairo_pattern_t, x: f64, y: f64);
}
extern "C" {
    pub fn cairo_mesh_pattern_set_control_point(
        pattern: *mut cairo_pattern_t,
        point_num: cty::c_uint,
        x: f64,
        y: f64,
    );
}
extern "C" {
    pub fn cairo_mesh_pattern_set_corner_color_rgb(
        pattern: *mut cairo_pattern_t,
        corner_num: cty::c_uint,
        red: f64,
        green: f64,
        blue: f64,
    );
}
extern "C" {
    pub fn cairo_mesh_pattern_set_corner_color_rgba(
        pattern: *mut cairo_pattern_t,
        corner_num: cty::c_uint,
        red: f64,
        green: f64,
        blue: f64,
        alpha: f64,
    );
}
extern "C" {
    pub fn cairo_pattern_set_matrix(pattern: *mut cairo_pattern_t, matrix: *const cairo_matrix_t);
}
extern "C" {
    pub fn cairo_pattern_get_matrix(pattern: *mut cairo_pattern_t, matrix: *mut cairo_matrix_t);
}
pub const _cairo_extend_CAIRO_EXTEND_NONE: _cairo_extend = 0;
pub const _cairo_extend_CAIRO_EXTEND_REPEAT: _cairo_extend = 1;
pub const _cairo_extend_CAIRO_EXTEND_REFLECT: _cairo_extend = 2;
pub const _cairo_extend_CAIRO_EXTEND_PAD: _cairo_extend = 3;
#[doc = " cairo_extend_t:"]
#[doc = " @CAIRO_EXTEND_NONE: pixels outside of the source pattern"]
#[doc = "   are fully transparent (Since 1.0)"]
#[doc = " @CAIRO_EXTEND_REPEAT: the pattern is tiled by repeating (Since 1.0)"]
#[doc = " @CAIRO_EXTEND_REFLECT: the pattern is tiled by reflecting"]
#[doc = "   at the edges (Since 1.0; but only implemented for surface patterns since 1.6)"]
#[doc = " @CAIRO_EXTEND_PAD: pixels outside of the pattern copy"]
#[doc = "   the closest pixel from the source (Since 1.2; but only"]
#[doc = "   implemented for surface patterns since 1.6)"]
#[doc = ""]
#[doc = " #cairo_extend_t is used to describe how pattern color/alpha will be"]
#[doc = " determined for areas \"outside\" the pattern's natural area, (for"]
#[doc = " example, outside the surface bounds or outside the gradient"]
#[doc = " geometry)."]
#[doc = ""]
#[doc = " Mesh patterns are not affected by the extend mode."]
#[doc = ""]
#[doc = " The default extend mode is %CAIRO_EXTEND_NONE for surface patterns"]
#[doc = " and %CAIRO_EXTEND_PAD for gradient patterns."]
#[doc = ""]
#[doc = " New entries may be added in future versions."]
#[doc = ""]
#[doc = " Since: 1.0"]
pub type _cairo_extend = u32;
#[doc = " cairo_extend_t:"]
#[doc = " @CAIRO_EXTEND_NONE: pixels outside of the source pattern"]
#[doc = "   are fully transparent (Since 1.0)"]
#[doc = " @CAIRO_EXTEND_REPEAT: the pattern is tiled by repeating (Since 1.0)"]
#[doc = " @CAIRO_EXTEND_REFLECT: the pattern is tiled by reflecting"]
#[doc = "   at the edges (Since 1.0; but only implemented for surface patterns since 1.6)"]
#[doc = " @CAIRO_EXTEND_PAD: pixels outside of the pattern copy"]
#[doc = "   the closest pixel from the source (Since 1.2; but only"]
#[doc = "   implemented for surface patterns since 1.6)"]
#[doc = ""]
#[doc = " #cairo_extend_t is used to describe how pattern color/alpha will be"]
#[doc = " determined for areas \"outside\" the pattern's natural area, (for"]
#[doc = " example, outside the surface bounds or outside the gradient"]
#[doc = " geometry)."]
#[doc = ""]
#[doc = " Mesh patterns are not affected by the extend mode."]
#[doc = ""]
#[doc = " The default extend mode is %CAIRO_EXTEND_NONE for surface patterns"]
#[doc = " and %CAIRO_EXTEND_PAD for gradient patterns."]
#[doc = ""]
#[doc = " New entries may be added in future versions."]
#[doc = ""]
#[doc = " Since: 1.0"]
pub use self::_cairo_extend as cairo_extend_t;
extern "C" {
    pub fn cairo_pattern_set_extend(pattern: *mut cairo_pattern_t, extend: cairo_extend_t);
}
extern "C" {
    pub fn cairo_pattern_get_extend(pattern: *mut cairo_pattern_t) -> cairo_extend_t;
}
pub const _cairo_filter_CAIRO_FILTER_FAST: _cairo_filter = 0;
pub const _cairo_filter_CAIRO_FILTER_GOOD: _cairo_filter = 1;
pub const _cairo_filter_CAIRO_FILTER_BEST: _cairo_filter = 2;
pub const _cairo_filter_CAIRO_FILTER_NEAREST: _cairo_filter = 3;
pub const _cairo_filter_CAIRO_FILTER_BILINEAR: _cairo_filter = 4;
pub const _cairo_filter_CAIRO_FILTER_GAUSSIAN: _cairo_filter = 5;
#[doc = " cairo_filter_t:"]
#[doc = " @CAIRO_FILTER_FAST: A high-performance filter, with quality similar"]
#[doc = "     to %CAIRO_FILTER_NEAREST (Since 1.0)"]
#[doc = " @CAIRO_FILTER_GOOD: A reasonable-performance filter, with quality"]
#[doc = "     similar to %CAIRO_FILTER_BILINEAR (Since 1.0)"]
#[doc = " @CAIRO_FILTER_BEST: The highest-quality available, performance may"]
#[doc = "     not be suitable for interactive use. (Since 1.0)"]
#[doc = " @CAIRO_FILTER_NEAREST: Nearest-neighbor filtering (Since 1.0)"]
#[doc = " @CAIRO_FILTER_BILINEAR: Linear interpolation in two dimensions (Since 1.0)"]
#[doc = " @CAIRO_FILTER_GAUSSIAN: This filter value is currently"]
#[doc = "     unimplemented, and should not be used in current code. (Since 1.0)"]
#[doc = ""]
#[doc = " #cairo_filter_t is used to indicate what filtering should be"]
#[doc = " applied when reading pixel values from patterns. See"]
#[doc = " cairo_pattern_set_filter() for indicating the desired filter to be"]
#[doc = " used with a particular pattern."]
#[doc = ""]
#[doc = " Since: 1.0"]
pub type _cairo_filter = u32;
#[doc = " cairo_filter_t:"]
#[doc = " @CAIRO_FILTER_FAST: A high-performance filter, with quality similar"]
#[doc = "     to %CAIRO_FILTER_NEAREST (Since 1.0)"]
#[doc = " @CAIRO_FILTER_GOOD: A reasonable-performance filter, with quality"]
#[doc = "     similar to %CAIRO_FILTER_BILINEAR (Since 1.0)"]
#[doc = " @CAIRO_FILTER_BEST: The highest-quality available, performance may"]
#[doc = "     not be suitable for interactive use. (Since 1.0)"]
#[doc = " @CAIRO_FILTER_NEAREST: Nearest-neighbor filtering (Since 1.0)"]
#[doc = " @CAIRO_FILTER_BILINEAR: Linear interpolation in two dimensions (Since 1.0)"]
#[doc = " @CAIRO_FILTER_GAUSSIAN: This filter value is currently"]
#[doc = "     unimplemented, and should not be used in current code. (Since 1.0)"]
#[doc = ""]
#[doc = " #cairo_filter_t is used to indicate what filtering should be"]
#[doc = " applied when reading pixel values from patterns. See"]
#[doc = " cairo_pattern_set_filter() for indicating the desired filter to be"]
#[doc = " used with a particular pattern."]
#[doc = ""]
#[doc = " Since: 1.0"]
pub use self::_cairo_filter as cairo_filter_t;
extern "C" {
    pub fn cairo_pattern_set_filter(pattern: *mut cairo_pattern_t, filter: cairo_filter_t);
}
extern "C" {
    pub fn cairo_pattern_get_filter(pattern: *mut cairo_pattern_t) -> cairo_filter_t;
}
extern "C" {
    pub fn cairo_pattern_get_rgba(
        pattern: *mut cairo_pattern_t,
        red: *mut f64,
        green: *mut f64,
        blue: *mut f64,
        alpha: *mut f64,
    ) -> cairo_status_t;
}
extern "C" {
    pub fn cairo_pattern_get_surface(
        pattern: *mut cairo_pattern_t,
        surface: *mut *mut cairo_surface_t,
    ) -> cairo_status_t;
}
extern "C" {
    pub fn cairo_pattern_get_color_stop_rgba(
        pattern: *mut cairo_pattern_t,
        index: cty::c_int,
        offset: *mut f64,
        red: *mut f64,
        green: *mut f64,
        blue: *mut f64,
        alpha: *mut f64,
    ) -> cairo_status_t;
}
extern "C" {
    pub fn cairo_pattern_get_color_stop_count(
        pattern: *mut cairo_pattern_t,
        count: *mut cty::c_int,
    ) -> cairo_status_t;
}
extern "C" {
    pub fn cairo_pattern_get_linear_points(
        pattern: *mut cairo_pattern_t,
        x0: *mut f64,
        y0: *mut f64,
        x1: *mut f64,
        y1: *mut f64,
    ) -> cairo_status_t;
}
extern "C" {
    pub fn cairo_pattern_get_radial_circles(
        pattern: *mut cairo_pattern_t,
        x0: *mut f64,
        y0: *mut f64,
        r0: *mut f64,
        x1: *mut f64,
        y1: *mut f64,
        r1: *mut f64,
    ) -> cairo_status_t;
}
extern "C" {
    pub fn cairo_mesh_pattern_get_patch_count(
        pattern: *mut cairo_pattern_t,
        count: *mut cty::c_uint,
    ) -> cairo_status_t;
}
extern "C" {
    pub fn cairo_mesh_pattern_get_path(
        pattern: *mut cairo_pattern_t,
        patch_num: cty::c_uint,
    ) -> *mut cairo_path_t;
}
extern "C" {
    pub fn cairo_mesh_pattern_get_corner_color_rgba(
        pattern: *mut cairo_pattern_t,
        patch_num: cty::c_uint,
        corner_num: cty::c_uint,
        red: *mut f64,
        green: *mut f64,
        blue: *mut f64,
        alpha: *mut f64,
    ) -> cairo_status_t;
}
extern "C" {
    pub fn cairo_mesh_pattern_get_control_point(
        pattern: *mut cairo_pattern_t,
        patch_num: cty::c_uint,
        point_num: cty::c_uint,
        x: *mut f64,
        y: *mut f64,
    ) -> cairo_status_t;
}
extern "C" {
    pub fn cairo_matrix_init(
        matrix: *mut cairo_matrix_t,
        xx: f64,
        yx: f64,
        xy: f64,
        yy: f64,
        x0: f64,
        y0: f64,
    );
}
extern "C" {
    pub fn cairo_matrix_init_identity(matrix: *mut cairo_matrix_t);
}
extern "C" {
    pub fn cairo_matrix_init_translate(matrix: *mut cairo_matrix_t, tx: f64, ty: f64);
}
extern "C" {
    pub fn cairo_matrix_init_scale(matrix: *mut cairo_matrix_t, sx: f64, sy: f64);
}
extern "C" {
    pub fn cairo_matrix_init_rotate(matrix: *mut cairo_matrix_t, radians: f64);
}
extern "C" {
    pub fn cairo_matrix_translate(matrix: *mut cairo_matrix_t, tx: f64, ty: f64);
}
extern "C" {
    pub fn cairo_matrix_scale(matrix: *mut cairo_matrix_t, sx: f64, sy: f64);
}
extern "C" {
    pub fn cairo_matrix_rotate(matrix: *mut cairo_matrix_t, radians: f64);
}
extern "C" {
    pub fn cairo_matrix_invert(matrix: *mut cairo_matrix_t) -> cairo_status_t;
}
extern "C" {
    pub fn cairo_matrix_multiply(
        result: *mut cairo_matrix_t,
        a: *const cairo_matrix_t,
        b: *const cairo_matrix_t,
    );
}
extern "C" {
    pub fn cairo_matrix_transform_distance(
        matrix: *const cairo_matrix_t,
        dx: *mut f64,
        dy: *mut f64,
    );
}
extern "C" {
    pub fn cairo_matrix_transform_point(matrix: *const cairo_matrix_t, x: *mut f64, y: *mut f64);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cairo_region {
    _unused: [u8; 0],
}
#[doc = " cairo_region_t:"]
#[doc = ""]
#[doc = " A #cairo_region_t represents a set of integer-aligned rectangles."]
#[doc = ""]
#[doc = " It allows set-theoretical operations like cairo_region_union() and"]
#[doc = " cairo_region_intersect() to be performed on them."]
#[doc = ""]
#[doc = " Memory management of #cairo_region_t is done with"]
#[doc = " cairo_region_reference() and cairo_region_destroy()."]
#[doc = ""]
#[doc = " Since: 1.10"]
pub type cairo_region_t = _cairo_region;
pub const _cairo_region_overlap_CAIRO_REGION_OVERLAP_IN: _cairo_region_overlap = 0;
pub const _cairo_region_overlap_CAIRO_REGION_OVERLAP_OUT: _cairo_region_overlap = 1;
pub const _cairo_region_overlap_CAIRO_REGION_OVERLAP_PART: _cairo_region_overlap = 2;
#[doc = " cairo_region_overlap_t:"]
#[doc = " @CAIRO_REGION_OVERLAP_IN: The contents are entirely inside the region. (Since 1.10)"]
#[doc = " @CAIRO_REGION_OVERLAP_OUT: The contents are entirely outside the region. (Since 1.10)"]
#[doc = " @CAIRO_REGION_OVERLAP_PART: The contents are partially inside and"]
#[doc = "     partially outside the region. (Since 1.10)"]
#[doc = ""]
#[doc = " Used as the return value for cairo_region_contains_rectangle()."]
#[doc = ""]
#[doc = " Since: 1.10"]
pub type _cairo_region_overlap = u32;
#[doc = " cairo_region_overlap_t:"]
#[doc = " @CAIRO_REGION_OVERLAP_IN: The contents are entirely inside the region. (Since 1.10)"]
#[doc = " @CAIRO_REGION_OVERLAP_OUT: The contents are entirely outside the region. (Since 1.10)"]
#[doc = " @CAIRO_REGION_OVERLAP_PART: The contents are partially inside and"]
#[doc = "     partially outside the region. (Since 1.10)"]
#[doc = ""]
#[doc = " Used as the return value for cairo_region_contains_rectangle()."]
#[doc = ""]
#[doc = " Since: 1.10"]
pub use self::_cairo_region_overlap as cairo_region_overlap_t;
extern "C" {
    pub fn cairo_region_create() -> *mut cairo_region_t;
}
extern "C" {
    pub fn cairo_region_create_rectangle(
        rectangle: *const cairo_rectangle_int_t,
    ) -> *mut cairo_region_t;
}
extern "C" {
    pub fn cairo_region_create_rectangles(
        rects: *const cairo_rectangle_int_t,
        count: cty::c_int,
    ) -> *mut cairo_region_t;
}
extern "C" {
    pub fn cairo_region_copy(original: *const cairo_region_t) -> *mut cairo_region_t;
}
extern "C" {
    pub fn cairo_region_reference(region: *mut cairo_region_t) -> *mut cairo_region_t;
}
extern "C" {
    pub fn cairo_region_destroy(region: *mut cairo_region_t);
}
extern "C" {
    pub fn cairo_region_equal(a: *const cairo_region_t, b: *const cairo_region_t) -> cairo_bool_t;
}
extern "C" {
    pub fn cairo_region_status(region: *const cairo_region_t) -> cairo_status_t;
}
extern "C" {
    pub fn cairo_region_get_extents(
        region: *const cairo_region_t,
        extents: *mut cairo_rectangle_int_t,
    );
}
extern "C" {
    pub fn cairo_region_num_rectangles(region: *const cairo_region_t) -> cty::c_int;
}
extern "C" {
    pub fn cairo_region_get_rectangle(
        region: *const cairo_region_t,
        nth: cty::c_int,
        rectangle: *mut cairo_rectangle_int_t,
    );
}
extern "C" {
    pub fn cairo_region_is_empty(region: *const cairo_region_t) -> cairo_bool_t;
}
extern "C" {
    pub fn cairo_region_contains_rectangle(
        region: *const cairo_region_t,
        rectangle: *const cairo_rectangle_int_t,
    ) -> cairo_region_overlap_t;
}
extern "C" {
    pub fn cairo_region_contains_point(
        region: *const cairo_region_t,
        x: cty::c_int,
        y: cty::c_int,
    ) -> cairo_bool_t;
}
extern "C" {
    pub fn cairo_region_translate(region: *mut cairo_region_t, dx: cty::c_int, dy: cty::c_int);
}
extern "C" {
    pub fn cairo_region_subtract(
        dst: *mut cairo_region_t,
        other: *const cairo_region_t,
    ) -> cairo_status_t;
}
extern "C" {
    pub fn cairo_region_subtract_rectangle(
        dst: *mut cairo_region_t,
        rectangle: *const cairo_rectangle_int_t,
    ) -> cairo_status_t;
}
extern "C" {
    pub fn cairo_region_intersect(
        dst: *mut cairo_region_t,
        other: *const cairo_region_t,
    ) -> cairo_status_t;
}
extern "C" {
    pub fn cairo_region_intersect_rectangle(
        dst: *mut cairo_region_t,
        rectangle: *const cairo_rectangle_int_t,
    ) -> cairo_status_t;
}
extern "C" {
    pub fn cairo_region_union(
        dst: *mut cairo_region_t,
        other: *const cairo_region_t,
    ) -> cairo_status_t;
}
extern "C" {
    pub fn cairo_region_union_rectangle(
        dst: *mut cairo_region_t,
        rectangle: *const cairo_rectangle_int_t,
    ) -> cairo_status_t;
}
extern "C" {
    pub fn cairo_region_xor(
        dst: *mut cairo_region_t,
        other: *const cairo_region_t,
    ) -> cairo_status_t;
}
extern "C" {
    pub fn cairo_region_xor_rectangle(
        dst: *mut cairo_region_t,
        rectangle: *const cairo_rectangle_int_t,
    ) -> cairo_status_t;
}
extern "C" {
    pub fn cairo_debug_reset_static_data();
}
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = cty::c_schar;
pub type int_fast16_t = cty::c_long;
pub type int_fast32_t = cty::c_long;
pub type int_fast64_t = cty::c_long;
pub type uint_fast8_t = cty::c_uchar;
pub type uint_fast16_t = cty::c_ulong;
pub type uint_fast32_t = cty::c_ulong;
pub type uint_fast64_t = cty::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut cty::c_void,
    pub iov_len: size_t,
}
#[test]
fn bindgen_test_layout_iovec() {
    assert_eq!(
        ::core::mem::size_of::<iovec>(),
        16usize,
        concat!("Size of: ", stringify!(iovec))
    );
    assert_eq!(
        ::core::mem::align_of::<iovec>(),
        8usize,
        concat!("Alignment of ", stringify!(iovec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iovec>())).iov_base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iovec>())).iov_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_len)
        )
    );
}
extern "C" {
    pub fn readv(__fd: cty::c_int, __iovec: *const iovec, __count: cty::c_int) -> ssize_t;
}
extern "C" {
    pub fn writev(__fd: cty::c_int, __iovec: *const iovec, __count: cty::c_int) -> ssize_t;
}
extern "C" {
    pub fn preadv(
        __fd: cty::c_int,
        __iovec: *const iovec,
        __count: cty::c_int,
        __offset: __off_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn pwritev(
        __fd: cty::c_int,
        __iovec: *const iovec,
        __count: cty::c_int,
        __offset: __off_t,
    ) -> ssize_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_connection_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_generic_iterator_t {
    pub data: *mut cty::c_void,
    pub rem: cty::c_int,
    pub index: cty::c_int,
}
#[test]
fn bindgen_test_layout_xcb_generic_iterator_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_generic_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_generic_iterator_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_generic_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_generic_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_generic_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_generic_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_generic_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_generic_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
}
#[test]
fn bindgen_test_layout_xcb_generic_reply_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_generic_reply_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_generic_reply_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_generic_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_generic_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_generic_reply_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_generic_reply_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_generic_reply_t>())).sequence as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_generic_reply_t>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_reply_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_generic_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub pad: [u32; 7usize],
    pub full_sequence: u32,
}
#[test]
fn bindgen_test_layout_xcb_generic_event_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_generic_event_t>(),
        36usize,
        concat!("Size of: ", stringify!(xcb_generic_event_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_generic_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_generic_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_generic_event_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_generic_event_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_generic_event_t>())).sequence as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_generic_event_t>())).pad as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_event_t),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_generic_event_t>())).full_sequence as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_event_t),
            "::",
            stringify!(full_sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_raw_generic_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub pad: [u32; 7usize],
}
#[test]
fn bindgen_test_layout_xcb_raw_generic_event_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_raw_generic_event_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_raw_generic_event_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_raw_generic_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_raw_generic_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_raw_generic_event_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_raw_generic_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_raw_generic_event_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_raw_generic_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_raw_generic_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_raw_generic_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_raw_generic_event_t>())).pad as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_raw_generic_event_t),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_ge_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub event_type: u16,
    pub pad1: u16,
    pub pad: [u32; 5usize],
    pub full_sequence: u32,
}
#[test]
fn bindgen_test_layout_xcb_ge_event_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_ge_event_t>(),
        36usize,
        concat!("Size of: ", stringify!(xcb_ge_event_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_ge_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_ge_event_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_ge_event_t>())).response_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_ge_event_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_ge_event_t>())).sequence as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_ge_event_t>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_event_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_ge_event_t>())).event_type as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_event_t),
            "::",
            stringify!(event_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_ge_event_t>())).pad1 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_event_t),
            "::",
            stringify!(pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_ge_event_t>())).pad as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_event_t),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_ge_event_t>())).full_sequence as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_event_t),
            "::",
            stringify!(full_sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_generic_error_t {
    pub response_type: u8,
    pub error_code: u8,
    pub sequence: u16,
    pub resource_id: u32,
    pub minor_code: u16,
    pub major_code: u8,
    pub pad0: u8,
    pub pad: [u32; 5usize],
    pub full_sequence: u32,
}
#[test]
fn bindgen_test_layout_xcb_generic_error_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_generic_error_t>(),
        36usize,
        concat!("Size of: ", stringify!(xcb_generic_error_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_generic_error_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_generic_error_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_generic_error_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_error_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_generic_error_t>())).error_code as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_error_t),
            "::",
            stringify!(error_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_generic_error_t>())).sequence as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_error_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_generic_error_t>())).resource_id as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_error_t),
            "::",
            stringify!(resource_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_generic_error_t>())).minor_code as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_error_t),
            "::",
            stringify!(minor_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_generic_error_t>())).major_code as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_error_t),
            "::",
            stringify!(major_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_generic_error_t>())).pad0 as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_error_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_generic_error_t>())).pad as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_error_t),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_generic_error_t>())).full_sequence as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_generic_error_t),
            "::",
            stringify!(full_sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_void_cookie_t {
    pub sequence: cty::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_void_cookie_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_void_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_void_cookie_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_void_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_void_cookie_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_void_cookie_t>())).sequence as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_void_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_char2b_t {
    pub byte1: u8,
    pub byte2: u8,
}
#[test]
fn bindgen_test_layout_xcb_char2b_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_char2b_t>(),
        2usize,
        concat!("Size of: ", stringify!(xcb_char2b_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_char2b_t>(),
        1usize,
        concat!("Alignment of ", stringify!(xcb_char2b_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_char2b_t>())).byte1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_char2b_t),
            "::",
            stringify!(byte1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_char2b_t>())).byte2 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_char2b_t),
            "::",
            stringify!(byte2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_char2b_iterator_t {
    pub data: *mut xcb_char2b_t,
    pub rem: cty::c_int,
    pub index: cty::c_int,
}
#[test]
fn bindgen_test_layout_xcb_char2b_iterator_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_char2b_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_char2b_iterator_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_char2b_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_char2b_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_char2b_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_char2b_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_char2b_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_char2b_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_char2b_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_char2b_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_window_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_window_iterator_t {
    pub data: *mut xcb_window_t,
    pub rem: cty::c_int,
    pub index: cty::c_int,
}
#[test]
fn bindgen_test_layout_xcb_window_iterator_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_window_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_window_iterator_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_window_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_window_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_window_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_window_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_window_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_window_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_window_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_window_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_pixmap_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_pixmap_iterator_t {
    pub data: *mut xcb_pixmap_t,
    pub rem: cty::c_int,
    pub index: cty::c_int,
}
#[test]
fn bindgen_test_layout_xcb_pixmap_iterator_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_pixmap_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_pixmap_iterator_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_pixmap_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_pixmap_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_pixmap_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_pixmap_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_pixmap_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_pixmap_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_pixmap_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_pixmap_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_cursor_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_cursor_iterator_t {
    pub data: *mut xcb_cursor_t,
    pub rem: cty::c_int,
    pub index: cty::c_int,
}
#[test]
fn bindgen_test_layout_xcb_cursor_iterator_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_cursor_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_cursor_iterator_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_cursor_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_cursor_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_cursor_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_cursor_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_cursor_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_cursor_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_cursor_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_cursor_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_font_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_font_iterator_t {
    pub data: *mut xcb_font_t,
    pub rem: cty::c_int,
    pub index: cty::c_int,
}
#[test]
fn bindgen_test_layout_xcb_font_iterator_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_font_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_font_iterator_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_font_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_font_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_font_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_font_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_font_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_font_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_font_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_font_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_gcontext_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_gcontext_iterator_t {
    pub data: *mut xcb_gcontext_t,
    pub rem: cty::c_int,
    pub index: cty::c_int,
}
#[test]
fn bindgen_test_layout_xcb_gcontext_iterator_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_gcontext_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_gcontext_iterator_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_gcontext_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_gcontext_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_gcontext_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_gcontext_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_gcontext_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_gcontext_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_gcontext_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_gcontext_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_colormap_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_colormap_iterator_t {
    pub data: *mut xcb_colormap_t,
    pub rem: cty::c_int,
    pub index: cty::c_int,
}
#[test]
fn bindgen_test_layout_xcb_colormap_iterator_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_colormap_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_colormap_iterator_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_colormap_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_colormap_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_colormap_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_colormap_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_colormap_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_colormap_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_colormap_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_colormap_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_atom_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_atom_iterator_t {
    pub data: *mut xcb_atom_t,
    pub rem: cty::c_int,
    pub index: cty::c_int,
}
#[test]
fn bindgen_test_layout_xcb_atom_iterator_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_atom_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_atom_iterator_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_atom_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_atom_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_atom_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_atom_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_atom_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_atom_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_atom_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_atom_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_drawable_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_drawable_iterator_t {
    pub data: *mut xcb_drawable_t,
    pub rem: cty::c_int,
    pub index: cty::c_int,
}
#[test]
fn bindgen_test_layout_xcb_drawable_iterator_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_drawable_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_drawable_iterator_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_drawable_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_drawable_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_drawable_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_drawable_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_drawable_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_drawable_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_drawable_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_drawable_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_fontable_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_fontable_iterator_t {
    pub data: *mut xcb_fontable_t,
    pub rem: cty::c_int,
    pub index: cty::c_int,
}
#[test]
fn bindgen_test_layout_xcb_fontable_iterator_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_fontable_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_fontable_iterator_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_fontable_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_fontable_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_fontable_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fontable_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_fontable_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fontable_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_fontable_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fontable_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_bool32_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_bool32_iterator_t {
    pub data: *mut xcb_bool32_t,
    pub rem: cty::c_int,
    pub index: cty::c_int,
}
#[test]
fn bindgen_test_layout_xcb_bool32_iterator_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_bool32_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_bool32_iterator_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_bool32_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_bool32_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_bool32_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_bool32_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_bool32_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_bool32_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_bool32_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_bool32_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_visualid_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_visualid_iterator_t {
    pub data: *mut xcb_visualid_t,
    pub rem: cty::c_int,
    pub index: cty::c_int,
}
#[test]
fn bindgen_test_layout_xcb_visualid_iterator_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_visualid_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_visualid_iterator_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_visualid_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_visualid_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_visualid_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visualid_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_visualid_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visualid_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_visualid_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visualid_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_timestamp_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_timestamp_iterator_t {
    pub data: *mut xcb_timestamp_t,
    pub rem: cty::c_int,
    pub index: cty::c_int,
}
#[test]
fn bindgen_test_layout_xcb_timestamp_iterator_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_timestamp_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_timestamp_iterator_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_timestamp_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_timestamp_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_timestamp_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_timestamp_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_timestamp_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_timestamp_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_timestamp_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_timestamp_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_keysym_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_keysym_iterator_t {
    pub data: *mut xcb_keysym_t,
    pub rem: cty::c_int,
    pub index: cty::c_int,
}
#[test]
fn bindgen_test_layout_xcb_keysym_iterator_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_keysym_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_keysym_iterator_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_keysym_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_keysym_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_keysym_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_keysym_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_keysym_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_keysym_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_keysym_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_keysym_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_keycode_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_keycode_iterator_t {
    pub data: *mut xcb_keycode_t,
    pub rem: cty::c_int,
    pub index: cty::c_int,
}
#[test]
fn bindgen_test_layout_xcb_keycode_iterator_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_keycode_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_keycode_iterator_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_keycode_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_keycode_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_keycode_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_keycode_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_keycode_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_keycode_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_keycode_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_keycode_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_keycode32_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_keycode32_iterator_t {
    pub data: *mut xcb_keycode32_t,
    pub rem: cty::c_int,
    pub index: cty::c_int,
}
#[test]
fn bindgen_test_layout_xcb_keycode32_iterator_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_keycode32_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_keycode32_iterator_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_keycode32_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_keycode32_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_keycode32_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_keycode32_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_keycode32_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_keycode32_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_keycode32_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_keycode32_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub type xcb_button_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_button_iterator_t {
    pub data: *mut xcb_button_t,
    pub rem: cty::c_int,
    pub index: cty::c_int,
}
#[test]
fn bindgen_test_layout_xcb_button_iterator_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_button_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_button_iterator_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_button_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_button_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_button_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_button_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_button_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_point_t {
    pub x: i16,
    pub y: i16,
}
#[test]
fn bindgen_test_layout_xcb_point_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_point_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_point_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_point_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_point_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_point_t>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_point_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_point_t>())).y as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_point_t),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_point_iterator_t {
    pub data: *mut xcb_point_t,
    pub rem: cty::c_int,
    pub index: cty::c_int,
}
#[test]
fn bindgen_test_layout_xcb_point_iterator_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_point_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_point_iterator_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_point_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_point_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_point_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_point_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_point_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_point_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_point_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_point_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_rectangle_t {
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
}
#[test]
fn bindgen_test_layout_xcb_rectangle_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_rectangle_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_rectangle_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_rectangle_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_rectangle_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_rectangle_t>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rectangle_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_rectangle_t>())).y as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rectangle_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_rectangle_t>())).width as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rectangle_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_rectangle_t>())).height as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rectangle_t),
            "::",
            stringify!(height)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_rectangle_iterator_t {
    pub data: *mut xcb_rectangle_t,
    pub rem: cty::c_int,
    pub index: cty::c_int,
}
#[test]
fn bindgen_test_layout_xcb_rectangle_iterator_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_rectangle_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_rectangle_iterator_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_rectangle_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_rectangle_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_rectangle_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rectangle_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_rectangle_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rectangle_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_rectangle_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rectangle_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_arc_t {
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
    pub angle1: i16,
    pub angle2: i16,
}
#[test]
fn bindgen_test_layout_xcb_arc_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_arc_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_arc_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_arc_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_arc_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_arc_t>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_arc_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_arc_t>())).y as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_arc_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_arc_t>())).width as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_arc_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_arc_t>())).height as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_arc_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_arc_t>())).angle1 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_arc_t),
            "::",
            stringify!(angle1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_arc_t>())).angle2 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_arc_t),
            "::",
            stringify!(angle2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_arc_iterator_t {
    pub data: *mut xcb_arc_t,
    pub rem: cty::c_int,
    pub index: cty::c_int,
}
#[test]
fn bindgen_test_layout_xcb_arc_iterator_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_arc_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_arc_iterator_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_arc_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_arc_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_arc_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_arc_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_arc_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_arc_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_arc_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_arc_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_format_t {
    pub depth: u8,
    pub bits_per_pixel: u8,
    pub scanline_pad: u8,
    pub pad0: [u8; 5usize],
}
#[test]
fn bindgen_test_layout_xcb_format_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_format_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_format_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_format_t>(),
        1usize,
        concat!("Alignment of ", stringify!(xcb_format_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_format_t>())).depth as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_format_t),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_format_t>())).bits_per_pixel as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_format_t),
            "::",
            stringify!(bits_per_pixel)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_format_t>())).scanline_pad as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_format_t),
            "::",
            stringify!(scanline_pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_format_t>())).pad0 as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_format_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_format_iterator_t {
    pub data: *mut xcb_format_t,
    pub rem: cty::c_int,
    pub index: cty::c_int,
}
#[test]
fn bindgen_test_layout_xcb_format_iterator_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_format_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_format_iterator_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_format_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_format_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_format_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_format_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_format_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_format_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_format_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_format_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub const xcb_visual_class_t_XCB_VISUAL_CLASS_STATIC_GRAY: xcb_visual_class_t = 0;
pub const xcb_visual_class_t_XCB_VISUAL_CLASS_GRAY_SCALE: xcb_visual_class_t = 1;
pub const xcb_visual_class_t_XCB_VISUAL_CLASS_STATIC_COLOR: xcb_visual_class_t = 2;
pub const xcb_visual_class_t_XCB_VISUAL_CLASS_PSEUDO_COLOR: xcb_visual_class_t = 3;
pub const xcb_visual_class_t_XCB_VISUAL_CLASS_TRUE_COLOR: xcb_visual_class_t = 4;
pub const xcb_visual_class_t_XCB_VISUAL_CLASS_DIRECT_COLOR: xcb_visual_class_t = 5;
pub type xcb_visual_class_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_visualtype_t {
    pub visual_id: xcb_visualid_t,
    pub _class: u8,
    pub bits_per_rgb_value: u8,
    pub colormap_entries: u16,
    pub red_mask: u32,
    pub green_mask: u32,
    pub blue_mask: u32,
    pub pad0: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_xcb_visualtype_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_visualtype_t>(),
        24usize,
        concat!("Size of: ", stringify!(xcb_visualtype_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_visualtype_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_visualtype_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_visualtype_t>())).visual_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visualtype_t),
            "::",
            stringify!(visual_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_visualtype_t>()))._class as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visualtype_t),
            "::",
            stringify!(_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_visualtype_t>())).bits_per_rgb_value as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visualtype_t),
            "::",
            stringify!(bits_per_rgb_value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_visualtype_t>())).colormap_entries as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visualtype_t),
            "::",
            stringify!(colormap_entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_visualtype_t>())).red_mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visualtype_t),
            "::",
            stringify!(red_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_visualtype_t>())).green_mask as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visualtype_t),
            "::",
            stringify!(green_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_visualtype_t>())).blue_mask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visualtype_t),
            "::",
            stringify!(blue_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_visualtype_t>())).pad0 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visualtype_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_visualtype_iterator_t {
    pub data: *mut xcb_visualtype_t,
    pub rem: cty::c_int,
    pub index: cty::c_int,
}
#[test]
fn bindgen_test_layout_xcb_visualtype_iterator_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_visualtype_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_visualtype_iterator_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_visualtype_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_visualtype_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_visualtype_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visualtype_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_visualtype_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visualtype_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_visualtype_iterator_t>())).index as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visualtype_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_depth_t {
    pub depth: u8,
    pub pad0: u8,
    pub visuals_len: u16,
    pub pad1: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_xcb_depth_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_depth_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_depth_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_depth_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_depth_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_depth_t>())).depth as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_depth_t),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_depth_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_depth_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_depth_t>())).visuals_len as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_depth_t),
            "::",
            stringify!(visuals_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_depth_t>())).pad1 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_depth_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_depth_iterator_t {
    pub data: *mut xcb_depth_t,
    pub rem: cty::c_int,
    pub index: cty::c_int,
}
#[test]
fn bindgen_test_layout_xcb_depth_iterator_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_depth_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_depth_iterator_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_depth_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_depth_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_depth_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_depth_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_depth_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_depth_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_depth_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_depth_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub const xcb_event_mask_t_XCB_EVENT_MASK_NO_EVENT: xcb_event_mask_t = 0;
pub const xcb_event_mask_t_XCB_EVENT_MASK_KEY_PRESS: xcb_event_mask_t = 1;
pub const xcb_event_mask_t_XCB_EVENT_MASK_KEY_RELEASE: xcb_event_mask_t = 2;
pub const xcb_event_mask_t_XCB_EVENT_MASK_BUTTON_PRESS: xcb_event_mask_t = 4;
pub const xcb_event_mask_t_XCB_EVENT_MASK_BUTTON_RELEASE: xcb_event_mask_t = 8;
pub const xcb_event_mask_t_XCB_EVENT_MASK_ENTER_WINDOW: xcb_event_mask_t = 16;
pub const xcb_event_mask_t_XCB_EVENT_MASK_LEAVE_WINDOW: xcb_event_mask_t = 32;
pub const xcb_event_mask_t_XCB_EVENT_MASK_POINTER_MOTION: xcb_event_mask_t = 64;
pub const xcb_event_mask_t_XCB_EVENT_MASK_POINTER_MOTION_HINT: xcb_event_mask_t = 128;
pub const xcb_event_mask_t_XCB_EVENT_MASK_BUTTON_1_MOTION: xcb_event_mask_t = 256;
pub const xcb_event_mask_t_XCB_EVENT_MASK_BUTTON_2_MOTION: xcb_event_mask_t = 512;
pub const xcb_event_mask_t_XCB_EVENT_MASK_BUTTON_3_MOTION: xcb_event_mask_t = 1024;
pub const xcb_event_mask_t_XCB_EVENT_MASK_BUTTON_4_MOTION: xcb_event_mask_t = 2048;
pub const xcb_event_mask_t_XCB_EVENT_MASK_BUTTON_5_MOTION: xcb_event_mask_t = 4096;
pub const xcb_event_mask_t_XCB_EVENT_MASK_BUTTON_MOTION: xcb_event_mask_t = 8192;
pub const xcb_event_mask_t_XCB_EVENT_MASK_KEYMAP_STATE: xcb_event_mask_t = 16384;
pub const xcb_event_mask_t_XCB_EVENT_MASK_EXPOSURE: xcb_event_mask_t = 32768;
pub const xcb_event_mask_t_XCB_EVENT_MASK_VISIBILITY_CHANGE: xcb_event_mask_t = 65536;
pub const xcb_event_mask_t_XCB_EVENT_MASK_STRUCTURE_NOTIFY: xcb_event_mask_t = 131072;
pub const xcb_event_mask_t_XCB_EVENT_MASK_RESIZE_REDIRECT: xcb_event_mask_t = 262144;
pub const xcb_event_mask_t_XCB_EVENT_MASK_SUBSTRUCTURE_NOTIFY: xcb_event_mask_t = 524288;
pub const xcb_event_mask_t_XCB_EVENT_MASK_SUBSTRUCTURE_REDIRECT: xcb_event_mask_t = 1048576;
pub const xcb_event_mask_t_XCB_EVENT_MASK_FOCUS_CHANGE: xcb_event_mask_t = 2097152;
pub const xcb_event_mask_t_XCB_EVENT_MASK_PROPERTY_CHANGE: xcb_event_mask_t = 4194304;
pub const xcb_event_mask_t_XCB_EVENT_MASK_COLOR_MAP_CHANGE: xcb_event_mask_t = 8388608;
pub const xcb_event_mask_t_XCB_EVENT_MASK_OWNER_GRAB_BUTTON: xcb_event_mask_t = 16777216;
pub type xcb_event_mask_t = u32;
pub const xcb_backing_store_t_XCB_BACKING_STORE_NOT_USEFUL: xcb_backing_store_t = 0;
pub const xcb_backing_store_t_XCB_BACKING_STORE_WHEN_MAPPED: xcb_backing_store_t = 1;
pub const xcb_backing_store_t_XCB_BACKING_STORE_ALWAYS: xcb_backing_store_t = 2;
pub type xcb_backing_store_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_screen_t {
    pub root: xcb_window_t,
    pub default_colormap: xcb_colormap_t,
    pub white_pixel: u32,
    pub black_pixel: u32,
    pub current_input_masks: u32,
    pub width_in_pixels: u16,
    pub height_in_pixels: u16,
    pub width_in_millimeters: u16,
    pub height_in_millimeters: u16,
    pub min_installed_maps: u16,
    pub max_installed_maps: u16,
    pub root_visual: xcb_visualid_t,
    pub backing_stores: u8,
    pub save_unders: u8,
    pub root_depth: u8,
    pub allowed_depths_len: u8,
}
#[test]
fn bindgen_test_layout_xcb_screen_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_screen_t>(),
        40usize,
        concat!("Size of: ", stringify!(xcb_screen_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_screen_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_screen_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_screen_t>())).root as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_screen_t>())).default_colormap as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(default_colormap)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_screen_t>())).white_pixel as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(white_pixel)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_screen_t>())).black_pixel as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(black_pixel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_screen_t>())).current_input_masks as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(current_input_masks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_screen_t>())).width_in_pixels as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(width_in_pixels)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_screen_t>())).height_in_pixels as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(height_in_pixels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_screen_t>())).width_in_millimeters as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(width_in_millimeters)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_screen_t>())).height_in_millimeters as *const _ as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(height_in_millimeters)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_screen_t>())).min_installed_maps as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(min_installed_maps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_screen_t>())).max_installed_maps as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(max_installed_maps)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_screen_t>())).root_visual as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(root_visual)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_screen_t>())).backing_stores as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(backing_stores)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_screen_t>())).save_unders as *const _ as usize },
        37usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(save_unders)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_screen_t>())).root_depth as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(root_depth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_screen_t>())).allowed_depths_len as *const _ as usize
        },
        39usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_t),
            "::",
            stringify!(allowed_depths_len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_screen_iterator_t {
    pub data: *mut xcb_screen_t,
    pub rem: cty::c_int,
    pub index: cty::c_int,
}
#[test]
fn bindgen_test_layout_xcb_screen_iterator_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_screen_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_screen_iterator_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_screen_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_screen_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_screen_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_screen_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_screen_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_screen_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_setup_request_t {
    pub byte_order: u8,
    pub pad0: u8,
    pub protocol_major_version: u16,
    pub protocol_minor_version: u16,
    pub authorization_protocol_name_len: u16,
    pub authorization_protocol_data_len: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_setup_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_setup_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_setup_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_setup_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_setup_request_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_setup_request_t>())).byte_order as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_request_t),
            "::",
            stringify!(byte_order)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_setup_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_setup_request_t>())).protocol_major_version as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_request_t),
            "::",
            stringify!(protocol_major_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_setup_request_t>())).protocol_minor_version as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_request_t),
            "::",
            stringify!(protocol_minor_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_setup_request_t>())).authorization_protocol_name_len
                as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_request_t),
            "::",
            stringify!(authorization_protocol_name_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_setup_request_t>())).authorization_protocol_data_len
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_request_t),
            "::",
            stringify!(authorization_protocol_data_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_setup_request_t>())).pad1 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_request_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_setup_request_iterator_t {
    pub data: *mut xcb_setup_request_t,
    pub rem: cty::c_int,
    pub index: cty::c_int,
}
#[test]
fn bindgen_test_layout_xcb_setup_request_iterator_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_setup_request_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_setup_request_iterator_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_setup_request_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_setup_request_iterator_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_setup_request_iterator_t>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_request_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_setup_request_iterator_t>())).rem as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_request_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_setup_request_iterator_t>())).index as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_request_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_setup_failed_t {
    pub status: u8,
    pub reason_len: u8,
    pub protocol_major_version: u16,
    pub protocol_minor_version: u16,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_setup_failed_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_setup_failed_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_setup_failed_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_setup_failed_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_setup_failed_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_setup_failed_t>())).status as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_failed_t),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_setup_failed_t>())).reason_len as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_failed_t),
            "::",
            stringify!(reason_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_setup_failed_t>())).protocol_major_version as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_failed_t),
            "::",
            stringify!(protocol_major_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_setup_failed_t>())).protocol_minor_version as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_failed_t),
            "::",
            stringify!(protocol_minor_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_setup_failed_t>())).length as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_failed_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_setup_failed_iterator_t {
    pub data: *mut xcb_setup_failed_t,
    pub rem: cty::c_int,
    pub index: cty::c_int,
}
#[test]
fn bindgen_test_layout_xcb_setup_failed_iterator_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_setup_failed_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_setup_failed_iterator_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_setup_failed_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_setup_failed_iterator_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_setup_failed_iterator_t>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_failed_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_setup_failed_iterator_t>())).rem as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_failed_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_setup_failed_iterator_t>())).index as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_failed_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_setup_authenticate_t {
    pub status: u8,
    pub pad0: [u8; 5usize],
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_setup_authenticate_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_setup_authenticate_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_setup_authenticate_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_setup_authenticate_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_setup_authenticate_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_setup_authenticate_t>())).status as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_authenticate_t),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_setup_authenticate_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_authenticate_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_setup_authenticate_t>())).length as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_authenticate_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_setup_authenticate_iterator_t {
    pub data: *mut xcb_setup_authenticate_t,
    pub rem: cty::c_int,
    pub index: cty::c_int,
}
#[test]
fn bindgen_test_layout_xcb_setup_authenticate_iterator_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_setup_authenticate_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_setup_authenticate_iterator_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_setup_authenticate_iterator_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_setup_authenticate_iterator_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_setup_authenticate_iterator_t>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_authenticate_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_setup_authenticate_iterator_t>())).rem as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_authenticate_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_setup_authenticate_iterator_t>())).index as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_authenticate_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub const xcb_image_order_t_XCB_IMAGE_ORDER_LSB_FIRST: xcb_image_order_t = 0;
pub const xcb_image_order_t_XCB_IMAGE_ORDER_MSB_FIRST: xcb_image_order_t = 1;
pub type xcb_image_order_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_setup_t {
    pub status: u8,
    pub pad0: u8,
    pub protocol_major_version: u16,
    pub protocol_minor_version: u16,
    pub length: u16,
    pub release_number: u32,
    pub resource_id_base: u32,
    pub resource_id_mask: u32,
    pub motion_buffer_size: u32,
    pub vendor_len: u16,
    pub maximum_request_length: u16,
    pub roots_len: u8,
    pub pixmap_formats_len: u8,
    pub image_byte_order: u8,
    pub bitmap_format_bit_order: u8,
    pub bitmap_format_scanline_unit: u8,
    pub bitmap_format_scanline_pad: u8,
    pub min_keycode: xcb_keycode_t,
    pub max_keycode: xcb_keycode_t,
    pub pad1: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_xcb_setup_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_setup_t>(),
        40usize,
        concat!("Size of: ", stringify!(xcb_setup_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_setup_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_setup_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_setup_t>())).status as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_setup_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_setup_t>())).protocol_major_version as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(protocol_major_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_setup_t>())).protocol_minor_version as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(protocol_minor_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_setup_t>())).length as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_setup_t>())).release_number as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(release_number)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_setup_t>())).resource_id_base as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(resource_id_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_setup_t>())).resource_id_mask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(resource_id_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_setup_t>())).motion_buffer_size as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(motion_buffer_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_setup_t>())).vendor_len as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(vendor_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_setup_t>())).maximum_request_length as *const _ as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(maximum_request_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_setup_t>())).roots_len as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(roots_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_setup_t>())).pixmap_formats_len as *const _ as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(pixmap_formats_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_setup_t>())).image_byte_order as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(image_byte_order)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_setup_t>())).bitmap_format_bit_order as *const _ as usize
        },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(bitmap_format_bit_order)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_setup_t>())).bitmap_format_scanline_unit as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(bitmap_format_scanline_unit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_setup_t>())).bitmap_format_scanline_pad as *const _ as usize
        },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(bitmap_format_scanline_pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_setup_t>())).min_keycode as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(min_keycode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_setup_t>())).max_keycode as *const _ as usize },
        35usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(max_keycode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_setup_t>())).pad1 as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_setup_iterator_t {
    pub data: *mut xcb_setup_t,
    pub rem: cty::c_int,
    pub index: cty::c_int,
}
#[test]
fn bindgen_test_layout_xcb_setup_iterator_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_setup_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_setup_iterator_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_setup_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_setup_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_setup_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_setup_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_setup_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_setup_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
pub const xcb_mod_mask_t_XCB_MOD_MASK_SHIFT: xcb_mod_mask_t = 1;
pub const xcb_mod_mask_t_XCB_MOD_MASK_LOCK: xcb_mod_mask_t = 2;
pub const xcb_mod_mask_t_XCB_MOD_MASK_CONTROL: xcb_mod_mask_t = 4;
pub const xcb_mod_mask_t_XCB_MOD_MASK_1: xcb_mod_mask_t = 8;
pub const xcb_mod_mask_t_XCB_MOD_MASK_2: xcb_mod_mask_t = 16;
pub const xcb_mod_mask_t_XCB_MOD_MASK_3: xcb_mod_mask_t = 32;
pub const xcb_mod_mask_t_XCB_MOD_MASK_4: xcb_mod_mask_t = 64;
pub const xcb_mod_mask_t_XCB_MOD_MASK_5: xcb_mod_mask_t = 128;
pub const xcb_mod_mask_t_XCB_MOD_MASK_ANY: xcb_mod_mask_t = 32768;
pub type xcb_mod_mask_t = u32;
pub const xcb_key_but_mask_t_XCB_KEY_BUT_MASK_SHIFT: xcb_key_but_mask_t = 1;
pub const xcb_key_but_mask_t_XCB_KEY_BUT_MASK_LOCK: xcb_key_but_mask_t = 2;
pub const xcb_key_but_mask_t_XCB_KEY_BUT_MASK_CONTROL: xcb_key_but_mask_t = 4;
pub const xcb_key_but_mask_t_XCB_KEY_BUT_MASK_MOD_1: xcb_key_but_mask_t = 8;
pub const xcb_key_but_mask_t_XCB_KEY_BUT_MASK_MOD_2: xcb_key_but_mask_t = 16;
pub const xcb_key_but_mask_t_XCB_KEY_BUT_MASK_MOD_3: xcb_key_but_mask_t = 32;
pub const xcb_key_but_mask_t_XCB_KEY_BUT_MASK_MOD_4: xcb_key_but_mask_t = 64;
pub const xcb_key_but_mask_t_XCB_KEY_BUT_MASK_MOD_5: xcb_key_but_mask_t = 128;
pub const xcb_key_but_mask_t_XCB_KEY_BUT_MASK_BUTTON_1: xcb_key_but_mask_t = 256;
pub const xcb_key_but_mask_t_XCB_KEY_BUT_MASK_BUTTON_2: xcb_key_but_mask_t = 512;
pub const xcb_key_but_mask_t_XCB_KEY_BUT_MASK_BUTTON_3: xcb_key_but_mask_t = 1024;
pub const xcb_key_but_mask_t_XCB_KEY_BUT_MASK_BUTTON_4: xcb_key_but_mask_t = 2048;
pub const xcb_key_but_mask_t_XCB_KEY_BUT_MASK_BUTTON_5: xcb_key_but_mask_t = 4096;
pub type xcb_key_but_mask_t = u32;
pub const xcb_window_enum_t_XCB_WINDOW_NONE: xcb_window_enum_t = 0;
pub type xcb_window_enum_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_key_press_event_t {
    pub response_type: u8,
    pub detail: xcb_keycode_t,
    pub sequence: u16,
    pub time: xcb_timestamp_t,
    pub root: xcb_window_t,
    pub event: xcb_window_t,
    pub child: xcb_window_t,
    pub root_x: i16,
    pub root_y: i16,
    pub event_x: i16,
    pub event_y: i16,
    pub state: u16,
    pub same_screen: u8,
    pub pad0: u8,
}
#[test]
fn bindgen_test_layout_xcb_key_press_event_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_key_press_event_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_key_press_event_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_key_press_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_key_press_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_key_press_event_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_key_press_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_key_press_event_t>())).detail as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_key_press_event_t),
            "::",
            stringify!(detail)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_key_press_event_t>())).sequence as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_key_press_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_key_press_event_t>())).time as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_key_press_event_t),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_key_press_event_t>())).root as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_key_press_event_t),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_key_press_event_t>())).event as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_key_press_event_t),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_key_press_event_t>())).child as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_key_press_event_t),
            "::",
            stringify!(child)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_key_press_event_t>())).root_x as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_key_press_event_t),
            "::",
            stringify!(root_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_key_press_event_t>())).root_y as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_key_press_event_t),
            "::",
            stringify!(root_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_key_press_event_t>())).event_x as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_key_press_event_t),
            "::",
            stringify!(event_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_key_press_event_t>())).event_y as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_key_press_event_t),
            "::",
            stringify!(event_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_key_press_event_t>())).state as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_key_press_event_t),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_key_press_event_t>())).same_screen as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_key_press_event_t),
            "::",
            stringify!(same_screen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_key_press_event_t>())).pad0 as *const _ as usize },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_key_press_event_t),
            "::",
            stringify!(pad0)
        )
    );
}
pub type xcb_key_release_event_t = xcb_key_press_event_t;
pub const xcb_button_mask_t_XCB_BUTTON_MASK_1: xcb_button_mask_t = 256;
pub const xcb_button_mask_t_XCB_BUTTON_MASK_2: xcb_button_mask_t = 512;
pub const xcb_button_mask_t_XCB_BUTTON_MASK_3: xcb_button_mask_t = 1024;
pub const xcb_button_mask_t_XCB_BUTTON_MASK_4: xcb_button_mask_t = 2048;
pub const xcb_button_mask_t_XCB_BUTTON_MASK_5: xcb_button_mask_t = 4096;
pub const xcb_button_mask_t_XCB_BUTTON_MASK_ANY: xcb_button_mask_t = 32768;
pub type xcb_button_mask_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_button_press_event_t {
    pub response_type: u8,
    pub detail: xcb_button_t,
    pub sequence: u16,
    pub time: xcb_timestamp_t,
    pub root: xcb_window_t,
    pub event: xcb_window_t,
    pub child: xcb_window_t,
    pub root_x: i16,
    pub root_y: i16,
    pub event_x: i16,
    pub event_y: i16,
    pub state: u16,
    pub same_screen: u8,
    pub pad0: u8,
}
#[test]
fn bindgen_test_layout_xcb_button_press_event_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_button_press_event_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_button_press_event_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_button_press_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_button_press_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_button_press_event_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_press_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_button_press_event_t>())).detail as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_press_event_t),
            "::",
            stringify!(detail)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_button_press_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_press_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_button_press_event_t>())).time as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_press_event_t),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_button_press_event_t>())).root as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_press_event_t),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_button_press_event_t>())).event as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_press_event_t),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_button_press_event_t>())).child as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_press_event_t),
            "::",
            stringify!(child)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_button_press_event_t>())).root_x as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_press_event_t),
            "::",
            stringify!(root_x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_button_press_event_t>())).root_y as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_press_event_t),
            "::",
            stringify!(root_y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_button_press_event_t>())).event_x as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_press_event_t),
            "::",
            stringify!(event_x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_button_press_event_t>())).event_y as *const _ as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_press_event_t),
            "::",
            stringify!(event_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_button_press_event_t>())).state as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_press_event_t),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_button_press_event_t>())).same_screen as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_press_event_t),
            "::",
            stringify!(same_screen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_button_press_event_t>())).pad0 as *const _ as usize },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_button_press_event_t),
            "::",
            stringify!(pad0)
        )
    );
}
pub type xcb_button_release_event_t = xcb_button_press_event_t;
pub const xcb_motion_t_XCB_MOTION_NORMAL: xcb_motion_t = 0;
pub const xcb_motion_t_XCB_MOTION_HINT: xcb_motion_t = 1;
pub type xcb_motion_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_motion_notify_event_t {
    pub response_type: u8,
    pub detail: u8,
    pub sequence: u16,
    pub time: xcb_timestamp_t,
    pub root: xcb_window_t,
    pub event: xcb_window_t,
    pub child: xcb_window_t,
    pub root_x: i16,
    pub root_y: i16,
    pub event_x: i16,
    pub event_y: i16,
    pub state: u16,
    pub same_screen: u8,
    pub pad0: u8,
}
#[test]
fn bindgen_test_layout_xcb_motion_notify_event_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_motion_notify_event_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_motion_notify_event_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_motion_notify_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_motion_notify_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_motion_notify_event_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_motion_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_motion_notify_event_t>())).detail as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_motion_notify_event_t),
            "::",
            stringify!(detail)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_motion_notify_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_motion_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_motion_notify_event_t>())).time as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_motion_notify_event_t),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_motion_notify_event_t>())).root as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_motion_notify_event_t),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_motion_notify_event_t>())).event as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_motion_notify_event_t),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_motion_notify_event_t>())).child as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_motion_notify_event_t),
            "::",
            stringify!(child)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_motion_notify_event_t>())).root_x as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_motion_notify_event_t),
            "::",
            stringify!(root_x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_motion_notify_event_t>())).root_y as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_motion_notify_event_t),
            "::",
            stringify!(root_y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_motion_notify_event_t>())).event_x as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_motion_notify_event_t),
            "::",
            stringify!(event_x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_motion_notify_event_t>())).event_y as *const _ as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_motion_notify_event_t),
            "::",
            stringify!(event_y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_motion_notify_event_t>())).state as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_motion_notify_event_t),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_motion_notify_event_t>())).same_screen as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_motion_notify_event_t),
            "::",
            stringify!(same_screen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_motion_notify_event_t>())).pad0 as *const _ as usize },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_motion_notify_event_t),
            "::",
            stringify!(pad0)
        )
    );
}
pub const xcb_notify_detail_t_XCB_NOTIFY_DETAIL_ANCESTOR: xcb_notify_detail_t = 0;
pub const xcb_notify_detail_t_XCB_NOTIFY_DETAIL_VIRTUAL: xcb_notify_detail_t = 1;
pub const xcb_notify_detail_t_XCB_NOTIFY_DETAIL_INFERIOR: xcb_notify_detail_t = 2;
pub const xcb_notify_detail_t_XCB_NOTIFY_DETAIL_NONLINEAR: xcb_notify_detail_t = 3;
pub const xcb_notify_detail_t_XCB_NOTIFY_DETAIL_NONLINEAR_VIRTUAL: xcb_notify_detail_t = 4;
pub const xcb_notify_detail_t_XCB_NOTIFY_DETAIL_POINTER: xcb_notify_detail_t = 5;
pub const xcb_notify_detail_t_XCB_NOTIFY_DETAIL_POINTER_ROOT: xcb_notify_detail_t = 6;
pub const xcb_notify_detail_t_XCB_NOTIFY_DETAIL_NONE: xcb_notify_detail_t = 7;
pub type xcb_notify_detail_t = u32;
pub const xcb_notify_mode_t_XCB_NOTIFY_MODE_NORMAL: xcb_notify_mode_t = 0;
pub const xcb_notify_mode_t_XCB_NOTIFY_MODE_GRAB: xcb_notify_mode_t = 1;
pub const xcb_notify_mode_t_XCB_NOTIFY_MODE_UNGRAB: xcb_notify_mode_t = 2;
pub const xcb_notify_mode_t_XCB_NOTIFY_MODE_WHILE_GRABBED: xcb_notify_mode_t = 3;
pub type xcb_notify_mode_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_enter_notify_event_t {
    pub response_type: u8,
    pub detail: u8,
    pub sequence: u16,
    pub time: xcb_timestamp_t,
    pub root: xcb_window_t,
    pub event: xcb_window_t,
    pub child: xcb_window_t,
    pub root_x: i16,
    pub root_y: i16,
    pub event_x: i16,
    pub event_y: i16,
    pub state: u16,
    pub mode: u8,
    pub same_screen_focus: u8,
}
#[test]
fn bindgen_test_layout_xcb_enter_notify_event_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_enter_notify_event_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_enter_notify_event_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_enter_notify_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_enter_notify_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_enter_notify_event_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_enter_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_enter_notify_event_t>())).detail as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_enter_notify_event_t),
            "::",
            stringify!(detail)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_enter_notify_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_enter_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_enter_notify_event_t>())).time as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_enter_notify_event_t),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_enter_notify_event_t>())).root as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_enter_notify_event_t),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_enter_notify_event_t>())).event as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_enter_notify_event_t),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_enter_notify_event_t>())).child as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_enter_notify_event_t),
            "::",
            stringify!(child)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_enter_notify_event_t>())).root_x as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_enter_notify_event_t),
            "::",
            stringify!(root_x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_enter_notify_event_t>())).root_y as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_enter_notify_event_t),
            "::",
            stringify!(root_y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_enter_notify_event_t>())).event_x as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_enter_notify_event_t),
            "::",
            stringify!(event_x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_enter_notify_event_t>())).event_y as *const _ as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_enter_notify_event_t),
            "::",
            stringify!(event_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_enter_notify_event_t>())).state as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_enter_notify_event_t),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_enter_notify_event_t>())).mode as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_enter_notify_event_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_enter_notify_event_t>())).same_screen_focus as *const _
                as usize
        },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_enter_notify_event_t),
            "::",
            stringify!(same_screen_focus)
        )
    );
}
pub type xcb_leave_notify_event_t = xcb_enter_notify_event_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_focus_in_event_t {
    pub response_type: u8,
    pub detail: u8,
    pub sequence: u16,
    pub event: xcb_window_t,
    pub mode: u8,
    pub pad0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_focus_in_event_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_focus_in_event_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_focus_in_event_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_focus_in_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_focus_in_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_focus_in_event_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_focus_in_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_focus_in_event_t>())).detail as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_focus_in_event_t),
            "::",
            stringify!(detail)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_focus_in_event_t>())).sequence as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_focus_in_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_focus_in_event_t>())).event as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_focus_in_event_t),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_focus_in_event_t>())).mode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_focus_in_event_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_focus_in_event_t>())).pad0 as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_focus_in_event_t),
            "::",
            stringify!(pad0)
        )
    );
}
pub type xcb_focus_out_event_t = xcb_focus_in_event_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_keymap_notify_event_t {
    pub response_type: u8,
    pub keys: [u8; 31usize],
}
#[test]
fn bindgen_test_layout_xcb_keymap_notify_event_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_keymap_notify_event_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_keymap_notify_event_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_keymap_notify_event_t>(),
        1usize,
        concat!("Alignment of ", stringify!(xcb_keymap_notify_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_keymap_notify_event_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_keymap_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_keymap_notify_event_t>())).keys as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_keymap_notify_event_t),
            "::",
            stringify!(keys)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_expose_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub window: xcb_window_t,
    pub x: u16,
    pub y: u16,
    pub width: u16,
    pub height: u16,
    pub count: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_expose_event_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_expose_event_t>(),
        20usize,
        concat!("Size of: ", stringify!(xcb_expose_event_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_expose_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_expose_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_expose_event_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_expose_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_expose_event_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_expose_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_expose_event_t>())).sequence as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_expose_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_expose_event_t>())).window as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_expose_event_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_expose_event_t>())).x as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_expose_event_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_expose_event_t>())).y as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_expose_event_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_expose_event_t>())).width as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_expose_event_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_expose_event_t>())).height as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_expose_event_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_expose_event_t>())).count as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_expose_event_t),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_expose_event_t>())).pad1 as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_expose_event_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_graphics_exposure_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub drawable: xcb_drawable_t,
    pub x: u16,
    pub y: u16,
    pub width: u16,
    pub height: u16,
    pub minor_opcode: u16,
    pub count: u16,
    pub major_opcode: u8,
    pub pad1: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_graphics_exposure_event_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_graphics_exposure_event_t>(),
        24usize,
        concat!("Size of: ", stringify!(xcb_graphics_exposure_event_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_graphics_exposure_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_graphics_exposure_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_graphics_exposure_event_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_graphics_exposure_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_graphics_exposure_event_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_graphics_exposure_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_graphics_exposure_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_graphics_exposure_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_graphics_exposure_event_t>())).drawable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_graphics_exposure_event_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_graphics_exposure_event_t>())).x as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_graphics_exposure_event_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_graphics_exposure_event_t>())).y as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_graphics_exposure_event_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_graphics_exposure_event_t>())).width as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_graphics_exposure_event_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_graphics_exposure_event_t>())).height as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_graphics_exposure_event_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_graphics_exposure_event_t>())).minor_opcode as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_graphics_exposure_event_t),
            "::",
            stringify!(minor_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_graphics_exposure_event_t>())).count as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_graphics_exposure_event_t),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_graphics_exposure_event_t>())).major_opcode as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_graphics_exposure_event_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_graphics_exposure_event_t>())).pad1 as *const _ as usize
        },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_graphics_exposure_event_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_no_exposure_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub drawable: xcb_drawable_t,
    pub minor_opcode: u16,
    pub major_opcode: u8,
    pub pad1: u8,
}
#[test]
fn bindgen_test_layout_xcb_no_exposure_event_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_no_exposure_event_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_no_exposure_event_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_no_exposure_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_no_exposure_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_no_exposure_event_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_no_exposure_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_no_exposure_event_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_no_exposure_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_no_exposure_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_no_exposure_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_no_exposure_event_t>())).drawable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_no_exposure_event_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_no_exposure_event_t>())).minor_opcode as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_no_exposure_event_t),
            "::",
            stringify!(minor_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_no_exposure_event_t>())).major_opcode as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_no_exposure_event_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_no_exposure_event_t>())).pad1 as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_no_exposure_event_t),
            "::",
            stringify!(pad1)
        )
    );
}
pub const xcb_visibility_t_XCB_VISIBILITY_UNOBSCURED: xcb_visibility_t = 0;
pub const xcb_visibility_t_XCB_VISIBILITY_PARTIALLY_OBSCURED: xcb_visibility_t = 1;
pub const xcb_visibility_t_XCB_VISIBILITY_FULLY_OBSCURED: xcb_visibility_t = 2;
pub type xcb_visibility_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_visibility_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub window: xcb_window_t,
    pub state: u8,
    pub pad1: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_visibility_notify_event_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_visibility_notify_event_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_visibility_notify_event_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_visibility_notify_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_visibility_notify_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_visibility_notify_event_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visibility_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_visibility_notify_event_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visibility_notify_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_visibility_notify_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visibility_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_visibility_notify_event_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visibility_notify_event_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_visibility_notify_event_t>())).state as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visibility_notify_event_t),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_visibility_notify_event_t>())).pad1 as *const _ as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_visibility_notify_event_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_create_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub parent: xcb_window_t,
    pub window: xcb_window_t,
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
    pub border_width: u16,
    pub override_redirect: u8,
    pub pad1: u8,
}
#[test]
fn bindgen_test_layout_xcb_create_notify_event_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_create_notify_event_t>(),
        24usize,
        concat!("Size of: ", stringify!(xcb_create_notify_event_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_create_notify_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_create_notify_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_notify_event_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_create_notify_event_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_notify_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_notify_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_notify_event_t>())).parent as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_notify_event_t),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_notify_event_t>())).window as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_notify_event_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_create_notify_event_t>())).x as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_notify_event_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_create_notify_event_t>())).y as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_notify_event_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_notify_event_t>())).width as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_notify_event_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_notify_event_t>())).height as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_notify_event_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_notify_event_t>())).border_width as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_notify_event_t),
            "::",
            stringify!(border_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_notify_event_t>())).override_redirect as *const _
                as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_notify_event_t),
            "::",
            stringify!(override_redirect)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_create_notify_event_t>())).pad1 as *const _ as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_notify_event_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_destroy_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub event: xcb_window_t,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_destroy_notify_event_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_destroy_notify_event_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_destroy_notify_event_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_destroy_notify_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_destroy_notify_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_destroy_notify_event_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_destroy_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_destroy_notify_event_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_destroy_notify_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_destroy_notify_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_destroy_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_destroy_notify_event_t>())).event as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_destroy_notify_event_t),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_destroy_notify_event_t>())).window as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_destroy_notify_event_t),
            "::",
            stringify!(window)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_unmap_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub event: xcb_window_t,
    pub window: xcb_window_t,
    pub from_configure: u8,
    pub pad1: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_unmap_notify_event_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_unmap_notify_event_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_unmap_notify_event_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_unmap_notify_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_unmap_notify_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_unmap_notify_event_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_unmap_notify_event_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_notify_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_unmap_notify_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_unmap_notify_event_t>())).event as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_notify_event_t),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_unmap_notify_event_t>())).window as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_notify_event_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_unmap_notify_event_t>())).from_configure as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_notify_event_t),
            "::",
            stringify!(from_configure)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_unmap_notify_event_t>())).pad1 as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_notify_event_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_map_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub event: xcb_window_t,
    pub window: xcb_window_t,
    pub override_redirect: u8,
    pub pad1: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_map_notify_event_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_map_notify_event_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_map_notify_event_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_map_notify_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_map_notify_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_map_notify_event_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_map_notify_event_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_notify_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_map_notify_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_map_notify_event_t>())).event as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_notify_event_t),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_map_notify_event_t>())).window as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_notify_event_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_map_notify_event_t>())).override_redirect as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_notify_event_t),
            "::",
            stringify!(override_redirect)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_map_notify_event_t>())).pad1 as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_notify_event_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_map_request_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub parent: xcb_window_t,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_map_request_event_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_map_request_event_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_map_request_event_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_map_request_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_map_request_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_map_request_event_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_request_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_map_request_event_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_request_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_map_request_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_request_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_map_request_event_t>())).parent as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_request_event_t),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_map_request_event_t>())).window as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_request_event_t),
            "::",
            stringify!(window)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_reparent_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub event: xcb_window_t,
    pub window: xcb_window_t,
    pub parent: xcb_window_t,
    pub x: i16,
    pub y: i16,
    pub override_redirect: u8,
    pub pad1: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_reparent_notify_event_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_reparent_notify_event_t>(),
        24usize,
        concat!("Size of: ", stringify!(xcb_reparent_notify_event_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_reparent_notify_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_reparent_notify_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_reparent_notify_event_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_reparent_notify_event_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_notify_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_reparent_notify_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_reparent_notify_event_t>())).event as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_notify_event_t),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_reparent_notify_event_t>())).window as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_notify_event_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_reparent_notify_event_t>())).parent as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_notify_event_t),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_reparent_notify_event_t>())).x as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_notify_event_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_reparent_notify_event_t>())).y as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_notify_event_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_reparent_notify_event_t>())).override_redirect as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_notify_event_t),
            "::",
            stringify!(override_redirect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_reparent_notify_event_t>())).pad1 as *const _ as usize
        },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_notify_event_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_configure_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub event: xcb_window_t,
    pub window: xcb_window_t,
    pub above_sibling: xcb_window_t,
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
    pub border_width: u16,
    pub override_redirect: u8,
    pub pad1: u8,
}
#[test]
fn bindgen_test_layout_xcb_configure_notify_event_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_configure_notify_event_t>(),
        28usize,
        concat!("Size of: ", stringify!(xcb_configure_notify_event_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_configure_notify_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_configure_notify_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_configure_notify_event_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_configure_notify_event_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_notify_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_configure_notify_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_configure_notify_event_t>())).event as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_notify_event_t),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_configure_notify_event_t>())).window as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_notify_event_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_configure_notify_event_t>())).above_sibling as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_notify_event_t),
            "::",
            stringify!(above_sibling)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_configure_notify_event_t>())).x as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_notify_event_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_configure_notify_event_t>())).y as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_notify_event_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_configure_notify_event_t>())).width as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_notify_event_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_configure_notify_event_t>())).height as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_notify_event_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_configure_notify_event_t>())).border_width as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_notify_event_t),
            "::",
            stringify!(border_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_configure_notify_event_t>())).override_redirect as *const _
                as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_notify_event_t),
            "::",
            stringify!(override_redirect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_configure_notify_event_t>())).pad1 as *const _ as usize
        },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_notify_event_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_configure_request_event_t {
    pub response_type: u8,
    pub stack_mode: u8,
    pub sequence: u16,
    pub parent: xcb_window_t,
    pub window: xcb_window_t,
    pub sibling: xcb_window_t,
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
    pub border_width: u16,
    pub value_mask: u16,
}
#[test]
fn bindgen_test_layout_xcb_configure_request_event_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_configure_request_event_t>(),
        28usize,
        concat!("Size of: ", stringify!(xcb_configure_request_event_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_configure_request_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_configure_request_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_configure_request_event_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_request_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_configure_request_event_t>())).stack_mode as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_request_event_t),
            "::",
            stringify!(stack_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_configure_request_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_request_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_configure_request_event_t>())).parent as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_request_event_t),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_configure_request_event_t>())).window as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_request_event_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_configure_request_event_t>())).sibling as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_request_event_t),
            "::",
            stringify!(sibling)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_configure_request_event_t>())).x as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_request_event_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_configure_request_event_t>())).y as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_request_event_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_configure_request_event_t>())).width as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_request_event_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_configure_request_event_t>())).height as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_request_event_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_configure_request_event_t>())).border_width as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_request_event_t),
            "::",
            stringify!(border_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_configure_request_event_t>())).value_mask as *const _
                as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_request_event_t),
            "::",
            stringify!(value_mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_gravity_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub event: xcb_window_t,
    pub window: xcb_window_t,
    pub x: i16,
    pub y: i16,
}
#[test]
fn bindgen_test_layout_xcb_gravity_notify_event_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_gravity_notify_event_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_gravity_notify_event_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_gravity_notify_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_gravity_notify_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_gravity_notify_event_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_gravity_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_gravity_notify_event_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_gravity_notify_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_gravity_notify_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_gravity_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_gravity_notify_event_t>())).event as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_gravity_notify_event_t),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_gravity_notify_event_t>())).window as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_gravity_notify_event_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_gravity_notify_event_t>())).x as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_gravity_notify_event_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_gravity_notify_event_t>())).y as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_gravity_notify_event_t),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_resize_request_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub window: xcb_window_t,
    pub width: u16,
    pub height: u16,
}
#[test]
fn bindgen_test_layout_xcb_resize_request_event_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_resize_request_event_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_resize_request_event_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_resize_request_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_resize_request_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_resize_request_event_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_resize_request_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_resize_request_event_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_resize_request_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_resize_request_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_resize_request_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_resize_request_event_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_resize_request_event_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_resize_request_event_t>())).width as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_resize_request_event_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_resize_request_event_t>())).height as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_resize_request_event_t),
            "::",
            stringify!(height)
        )
    );
}
pub const xcb_place_t_XCB_PLACE_ON_TOP: xcb_place_t = 0;
pub const xcb_place_t_XCB_PLACE_ON_BOTTOM: xcb_place_t = 1;
pub type xcb_place_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_circulate_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub event: xcb_window_t,
    pub window: xcb_window_t,
    pub pad1: [u8; 4usize],
    pub place: u8,
    pub pad2: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_circulate_notify_event_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_circulate_notify_event_t>(),
        20usize,
        concat!("Size of: ", stringify!(xcb_circulate_notify_event_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_circulate_notify_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_circulate_notify_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_circulate_notify_event_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_circulate_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_circulate_notify_event_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_circulate_notify_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_circulate_notify_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_circulate_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_circulate_notify_event_t>())).event as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_circulate_notify_event_t),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_circulate_notify_event_t>())).window as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_circulate_notify_event_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_circulate_notify_event_t>())).pad1 as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_circulate_notify_event_t),
            "::",
            stringify!(pad1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_circulate_notify_event_t>())).place as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_circulate_notify_event_t),
            "::",
            stringify!(place)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_circulate_notify_event_t>())).pad2 as *const _ as usize
        },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_circulate_notify_event_t),
            "::",
            stringify!(pad2)
        )
    );
}
pub type xcb_circulate_request_event_t = xcb_circulate_notify_event_t;
pub const xcb_property_t_XCB_PROPERTY_NEW_VALUE: xcb_property_t = 0;
pub const xcb_property_t_XCB_PROPERTY_DELETE: xcb_property_t = 1;
pub type xcb_property_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_property_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub window: xcb_window_t,
    pub atom: xcb_atom_t,
    pub time: xcb_timestamp_t,
    pub state: u8,
    pub pad1: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_property_notify_event_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_property_notify_event_t>(),
        20usize,
        concat!("Size of: ", stringify!(xcb_property_notify_event_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_property_notify_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_property_notify_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_property_notify_event_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_property_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_property_notify_event_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_property_notify_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_property_notify_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_property_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_property_notify_event_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_property_notify_event_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_property_notify_event_t>())).atom as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_property_notify_event_t),
            "::",
            stringify!(atom)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_property_notify_event_t>())).time as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_property_notify_event_t),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_property_notify_event_t>())).state as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_property_notify_event_t),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_property_notify_event_t>())).pad1 as *const _ as usize
        },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_property_notify_event_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_selection_clear_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub time: xcb_timestamp_t,
    pub owner: xcb_window_t,
    pub selection: xcb_atom_t,
}
#[test]
fn bindgen_test_layout_xcb_selection_clear_event_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_selection_clear_event_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_selection_clear_event_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_selection_clear_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_selection_clear_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_selection_clear_event_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_clear_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_selection_clear_event_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_clear_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_selection_clear_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_clear_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_selection_clear_event_t>())).time as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_clear_event_t),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_selection_clear_event_t>())).owner as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_clear_event_t),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_selection_clear_event_t>())).selection as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_clear_event_t),
            "::",
            stringify!(selection)
        )
    );
}
pub const xcb_time_t_XCB_TIME_CURRENT_TIME: xcb_time_t = 0;
pub type xcb_time_t = u32;
pub const xcb_atom_enum_t_XCB_ATOM_NONE: xcb_atom_enum_t = 0;
pub const xcb_atom_enum_t_XCB_ATOM_ANY: xcb_atom_enum_t = 0;
pub const xcb_atom_enum_t_XCB_ATOM_PRIMARY: xcb_atom_enum_t = 1;
pub const xcb_atom_enum_t_XCB_ATOM_SECONDARY: xcb_atom_enum_t = 2;
pub const xcb_atom_enum_t_XCB_ATOM_ARC: xcb_atom_enum_t = 3;
pub const xcb_atom_enum_t_XCB_ATOM_ATOM: xcb_atom_enum_t = 4;
pub const xcb_atom_enum_t_XCB_ATOM_BITMAP: xcb_atom_enum_t = 5;
pub const xcb_atom_enum_t_XCB_ATOM_CARDINAL: xcb_atom_enum_t = 6;
pub const xcb_atom_enum_t_XCB_ATOM_COLORMAP: xcb_atom_enum_t = 7;
pub const xcb_atom_enum_t_XCB_ATOM_CURSOR: xcb_atom_enum_t = 8;
pub const xcb_atom_enum_t_XCB_ATOM_CUT_BUFFER0: xcb_atom_enum_t = 9;
pub const xcb_atom_enum_t_XCB_ATOM_CUT_BUFFER1: xcb_atom_enum_t = 10;
pub const xcb_atom_enum_t_XCB_ATOM_CUT_BUFFER2: xcb_atom_enum_t = 11;
pub const xcb_atom_enum_t_XCB_ATOM_CUT_BUFFER3: xcb_atom_enum_t = 12;
pub const xcb_atom_enum_t_XCB_ATOM_CUT_BUFFER4: xcb_atom_enum_t = 13;
pub const xcb_atom_enum_t_XCB_ATOM_CUT_BUFFER5: xcb_atom_enum_t = 14;
pub const xcb_atom_enum_t_XCB_ATOM_CUT_BUFFER6: xcb_atom_enum_t = 15;
pub const xcb_atom_enum_t_XCB_ATOM_CUT_BUFFER7: xcb_atom_enum_t = 16;
pub const xcb_atom_enum_t_XCB_ATOM_DRAWABLE: xcb_atom_enum_t = 17;
pub const xcb_atom_enum_t_XCB_ATOM_FONT: xcb_atom_enum_t = 18;
pub const xcb_atom_enum_t_XCB_ATOM_INTEGER: xcb_atom_enum_t = 19;
pub const xcb_atom_enum_t_XCB_ATOM_PIXMAP: xcb_atom_enum_t = 20;
pub const xcb_atom_enum_t_XCB_ATOM_POINT: xcb_atom_enum_t = 21;
pub const xcb_atom_enum_t_XCB_ATOM_RECTANGLE: xcb_atom_enum_t = 22;
pub const xcb_atom_enum_t_XCB_ATOM_RESOURCE_MANAGER: xcb_atom_enum_t = 23;
pub const xcb_atom_enum_t_XCB_ATOM_RGB_COLOR_MAP: xcb_atom_enum_t = 24;
pub const xcb_atom_enum_t_XCB_ATOM_RGB_BEST_MAP: xcb_atom_enum_t = 25;
pub const xcb_atom_enum_t_XCB_ATOM_RGB_BLUE_MAP: xcb_atom_enum_t = 26;
pub const xcb_atom_enum_t_XCB_ATOM_RGB_DEFAULT_MAP: xcb_atom_enum_t = 27;
pub const xcb_atom_enum_t_XCB_ATOM_RGB_GRAY_MAP: xcb_atom_enum_t = 28;
pub const xcb_atom_enum_t_XCB_ATOM_RGB_GREEN_MAP: xcb_atom_enum_t = 29;
pub const xcb_atom_enum_t_XCB_ATOM_RGB_RED_MAP: xcb_atom_enum_t = 30;
pub const xcb_atom_enum_t_XCB_ATOM_STRING: xcb_atom_enum_t = 31;
pub const xcb_atom_enum_t_XCB_ATOM_VISUALID: xcb_atom_enum_t = 32;
pub const xcb_atom_enum_t_XCB_ATOM_WINDOW: xcb_atom_enum_t = 33;
pub const xcb_atom_enum_t_XCB_ATOM_WM_COMMAND: xcb_atom_enum_t = 34;
pub const xcb_atom_enum_t_XCB_ATOM_WM_HINTS: xcb_atom_enum_t = 35;
pub const xcb_atom_enum_t_XCB_ATOM_WM_CLIENT_MACHINE: xcb_atom_enum_t = 36;
pub const xcb_atom_enum_t_XCB_ATOM_WM_ICON_NAME: xcb_atom_enum_t = 37;
pub const xcb_atom_enum_t_XCB_ATOM_WM_ICON_SIZE: xcb_atom_enum_t = 38;
pub const xcb_atom_enum_t_XCB_ATOM_WM_NAME: xcb_atom_enum_t = 39;
pub const xcb_atom_enum_t_XCB_ATOM_WM_NORMAL_HINTS: xcb_atom_enum_t = 40;
pub const xcb_atom_enum_t_XCB_ATOM_WM_SIZE_HINTS: xcb_atom_enum_t = 41;
pub const xcb_atom_enum_t_XCB_ATOM_WM_ZOOM_HINTS: xcb_atom_enum_t = 42;
pub const xcb_atom_enum_t_XCB_ATOM_MIN_SPACE: xcb_atom_enum_t = 43;
pub const xcb_atom_enum_t_XCB_ATOM_NORM_SPACE: xcb_atom_enum_t = 44;
pub const xcb_atom_enum_t_XCB_ATOM_MAX_SPACE: xcb_atom_enum_t = 45;
pub const xcb_atom_enum_t_XCB_ATOM_END_SPACE: xcb_atom_enum_t = 46;
pub const xcb_atom_enum_t_XCB_ATOM_SUPERSCRIPT_X: xcb_atom_enum_t = 47;
pub const xcb_atom_enum_t_XCB_ATOM_SUPERSCRIPT_Y: xcb_atom_enum_t = 48;
pub const xcb_atom_enum_t_XCB_ATOM_SUBSCRIPT_X: xcb_atom_enum_t = 49;
pub const xcb_atom_enum_t_XCB_ATOM_SUBSCRIPT_Y: xcb_atom_enum_t = 50;
pub const xcb_atom_enum_t_XCB_ATOM_UNDERLINE_POSITION: xcb_atom_enum_t = 51;
pub const xcb_atom_enum_t_XCB_ATOM_UNDERLINE_THICKNESS: xcb_atom_enum_t = 52;
pub const xcb_atom_enum_t_XCB_ATOM_STRIKEOUT_ASCENT: xcb_atom_enum_t = 53;
pub const xcb_atom_enum_t_XCB_ATOM_STRIKEOUT_DESCENT: xcb_atom_enum_t = 54;
pub const xcb_atom_enum_t_XCB_ATOM_ITALIC_ANGLE: xcb_atom_enum_t = 55;
pub const xcb_atom_enum_t_XCB_ATOM_X_HEIGHT: xcb_atom_enum_t = 56;
pub const xcb_atom_enum_t_XCB_ATOM_QUAD_WIDTH: xcb_atom_enum_t = 57;
pub const xcb_atom_enum_t_XCB_ATOM_WEIGHT: xcb_atom_enum_t = 58;
pub const xcb_atom_enum_t_XCB_ATOM_POINT_SIZE: xcb_atom_enum_t = 59;
pub const xcb_atom_enum_t_XCB_ATOM_RESOLUTION: xcb_atom_enum_t = 60;
pub const xcb_atom_enum_t_XCB_ATOM_COPYRIGHT: xcb_atom_enum_t = 61;
pub const xcb_atom_enum_t_XCB_ATOM_NOTICE: xcb_atom_enum_t = 62;
pub const xcb_atom_enum_t_XCB_ATOM_FONT_NAME: xcb_atom_enum_t = 63;
pub const xcb_atom_enum_t_XCB_ATOM_FAMILY_NAME: xcb_atom_enum_t = 64;
pub const xcb_atom_enum_t_XCB_ATOM_FULL_NAME: xcb_atom_enum_t = 65;
pub const xcb_atom_enum_t_XCB_ATOM_CAP_HEIGHT: xcb_atom_enum_t = 66;
pub const xcb_atom_enum_t_XCB_ATOM_WM_CLASS: xcb_atom_enum_t = 67;
pub const xcb_atom_enum_t_XCB_ATOM_WM_TRANSIENT_FOR: xcb_atom_enum_t = 68;
pub type xcb_atom_enum_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_selection_request_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub time: xcb_timestamp_t,
    pub owner: xcb_window_t,
    pub requestor: xcb_window_t,
    pub selection: xcb_atom_t,
    pub target: xcb_atom_t,
    pub property: xcb_atom_t,
}
#[test]
fn bindgen_test_layout_xcb_selection_request_event_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_selection_request_event_t>(),
        28usize,
        concat!("Size of: ", stringify!(xcb_selection_request_event_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_selection_request_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_selection_request_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_selection_request_event_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_request_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_selection_request_event_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_request_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_selection_request_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_request_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_selection_request_event_t>())).time as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_request_event_t),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_selection_request_event_t>())).owner as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_request_event_t),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_selection_request_event_t>())).requestor as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_request_event_t),
            "::",
            stringify!(requestor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_selection_request_event_t>())).selection as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_request_event_t),
            "::",
            stringify!(selection)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_selection_request_event_t>())).target as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_request_event_t),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_selection_request_event_t>())).property as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_request_event_t),
            "::",
            stringify!(property)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_selection_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub time: xcb_timestamp_t,
    pub requestor: xcb_window_t,
    pub selection: xcb_atom_t,
    pub target: xcb_atom_t,
    pub property: xcb_atom_t,
}
#[test]
fn bindgen_test_layout_xcb_selection_notify_event_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_selection_notify_event_t>(),
        24usize,
        concat!("Size of: ", stringify!(xcb_selection_notify_event_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_selection_notify_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_selection_notify_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_selection_notify_event_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_selection_notify_event_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_notify_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_selection_notify_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_selection_notify_event_t>())).time as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_notify_event_t),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_selection_notify_event_t>())).requestor as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_notify_event_t),
            "::",
            stringify!(requestor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_selection_notify_event_t>())).selection as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_notify_event_t),
            "::",
            stringify!(selection)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_selection_notify_event_t>())).target as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_notify_event_t),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_selection_notify_event_t>())).property as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_selection_notify_event_t),
            "::",
            stringify!(property)
        )
    );
}
pub const xcb_colormap_state_t_XCB_COLORMAP_STATE_UNINSTALLED: xcb_colormap_state_t = 0;
pub const xcb_colormap_state_t_XCB_COLORMAP_STATE_INSTALLED: xcb_colormap_state_t = 1;
pub type xcb_colormap_state_t = u32;
pub const xcb_colormap_enum_t_XCB_COLORMAP_NONE: xcb_colormap_enum_t = 0;
pub type xcb_colormap_enum_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_colormap_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub window: xcb_window_t,
    pub colormap: xcb_colormap_t,
    pub _new: u8,
    pub state: u8,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_colormap_notify_event_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_colormap_notify_event_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_colormap_notify_event_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_colormap_notify_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_colormap_notify_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_colormap_notify_event_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_colormap_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_colormap_notify_event_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_colormap_notify_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_colormap_notify_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_colormap_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_colormap_notify_event_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_colormap_notify_event_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_colormap_notify_event_t>())).colormap as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_colormap_notify_event_t),
            "::",
            stringify!(colormap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_colormap_notify_event_t>()))._new as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_colormap_notify_event_t),
            "::",
            stringify!(_new)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_colormap_notify_event_t>())).state as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_colormap_notify_event_t),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_colormap_notify_event_t>())).pad1 as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_colormap_notify_event_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xcb_client_message_data_t {
    pub data8: [u8; 20usize],
    pub data16: [u16; 10usize],
    pub data32: [u32; 5usize],
    _bindgen_union_align: [u32; 5usize],
}
#[test]
fn bindgen_test_layout_xcb_client_message_data_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_client_message_data_t>(),
        20usize,
        concat!("Size of: ", stringify!(xcb_client_message_data_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_client_message_data_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_client_message_data_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_client_message_data_t>())).data8 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_client_message_data_t),
            "::",
            stringify!(data8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_client_message_data_t>())).data16 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_client_message_data_t),
            "::",
            stringify!(data16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_client_message_data_t>())).data32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_client_message_data_t),
            "::",
            stringify!(data32)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_client_message_data_iterator_t {
    pub data: *mut xcb_client_message_data_t,
    pub rem: cty::c_int,
    pub index: cty::c_int,
}
#[test]
fn bindgen_test_layout_xcb_client_message_data_iterator_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_client_message_data_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_client_message_data_iterator_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_client_message_data_iterator_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_client_message_data_iterator_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_client_message_data_iterator_t>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_client_message_data_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_client_message_data_iterator_t>())).rem as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_client_message_data_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_client_message_data_iterator_t>())).index as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_client_message_data_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xcb_client_message_event_t {
    pub response_type: u8,
    pub format: u8,
    pub sequence: u16,
    pub window: xcb_window_t,
    pub type_: xcb_atom_t,
    pub data: xcb_client_message_data_t,
}
#[test]
fn bindgen_test_layout_xcb_client_message_event_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_client_message_event_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_client_message_event_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_client_message_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_client_message_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_client_message_event_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_client_message_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_client_message_event_t>())).format as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_client_message_event_t),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_client_message_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_client_message_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_client_message_event_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_client_message_event_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_client_message_event_t>())).type_ as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_client_message_event_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_client_message_event_t>())).data as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_client_message_event_t),
            "::",
            stringify!(data)
        )
    );
}
pub const xcb_mapping_t_XCB_MAPPING_MODIFIER: xcb_mapping_t = 0;
pub const xcb_mapping_t_XCB_MAPPING_KEYBOARD: xcb_mapping_t = 1;
pub const xcb_mapping_t_XCB_MAPPING_POINTER: xcb_mapping_t = 2;
pub type xcb_mapping_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_mapping_notify_event_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub request: u8,
    pub first_keycode: xcb_keycode_t,
    pub count: u8,
    pub pad1: u8,
}
#[test]
fn bindgen_test_layout_xcb_mapping_notify_event_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_mapping_notify_event_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_mapping_notify_event_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_mapping_notify_event_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_mapping_notify_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_mapping_notify_event_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_mapping_notify_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_mapping_notify_event_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_mapping_notify_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_mapping_notify_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_mapping_notify_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_mapping_notify_event_t>())).request as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_mapping_notify_event_t),
            "::",
            stringify!(request)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_mapping_notify_event_t>())).first_keycode as *const _
                as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_mapping_notify_event_t),
            "::",
            stringify!(first_keycode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_mapping_notify_event_t>())).count as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_mapping_notify_event_t),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_mapping_notify_event_t>())).pad1 as *const _ as usize
        },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_mapping_notify_event_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_ge_generic_event_t {
    pub response_type: u8,
    pub extension: u8,
    pub sequence: u16,
    pub length: u32,
    pub event_type: u16,
    pub pad0: [u8; 22usize],
    pub full_sequence: u32,
}
#[test]
fn bindgen_test_layout_xcb_ge_generic_event_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_ge_generic_event_t>(),
        36usize,
        concat!("Size of: ", stringify!(xcb_ge_generic_event_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_ge_generic_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_ge_generic_event_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_ge_generic_event_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_generic_event_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_ge_generic_event_t>())).extension as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_generic_event_t),
            "::",
            stringify!(extension)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_ge_generic_event_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_generic_event_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_ge_generic_event_t>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_generic_event_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_ge_generic_event_t>())).event_type as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_generic_event_t),
            "::",
            stringify!(event_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_ge_generic_event_t>())).pad0 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_generic_event_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_ge_generic_event_t>())).full_sequence as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ge_generic_event_t),
            "::",
            stringify!(full_sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_request_error_t {
    pub response_type: u8,
    pub error_code: u8,
    pub sequence: u16,
    pub bad_value: u32,
    pub minor_opcode: u16,
    pub major_opcode: u8,
    pub pad0: u8,
}
#[test]
fn bindgen_test_layout_xcb_request_error_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_request_error_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_request_error_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_request_error_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_request_error_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_request_error_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_request_error_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_request_error_t>())).error_code as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_request_error_t),
            "::",
            stringify!(error_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_request_error_t>())).sequence as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_request_error_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_request_error_t>())).bad_value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_request_error_t),
            "::",
            stringify!(bad_value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_request_error_t>())).minor_opcode as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_request_error_t),
            "::",
            stringify!(minor_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_request_error_t>())).major_opcode as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_request_error_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_request_error_t>())).pad0 as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_request_error_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_value_error_t {
    pub response_type: u8,
    pub error_code: u8,
    pub sequence: u16,
    pub bad_value: u32,
    pub minor_opcode: u16,
    pub major_opcode: u8,
    pub pad0: u8,
}
#[test]
fn bindgen_test_layout_xcb_value_error_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_value_error_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_value_error_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_value_error_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_value_error_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_value_error_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_value_error_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_value_error_t>())).error_code as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_value_error_t),
            "::",
            stringify!(error_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_value_error_t>())).sequence as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_value_error_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_value_error_t>())).bad_value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_value_error_t),
            "::",
            stringify!(bad_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_value_error_t>())).minor_opcode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_value_error_t),
            "::",
            stringify!(minor_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_value_error_t>())).major_opcode as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_value_error_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_value_error_t>())).pad0 as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_value_error_t),
            "::",
            stringify!(pad0)
        )
    );
}
pub type xcb_window_error_t = xcb_value_error_t;
pub type xcb_pixmap_error_t = xcb_value_error_t;
pub type xcb_atom_error_t = xcb_value_error_t;
pub type xcb_cursor_error_t = xcb_value_error_t;
pub type xcb_font_error_t = xcb_value_error_t;
pub type xcb_match_error_t = xcb_request_error_t;
pub type xcb_drawable_error_t = xcb_value_error_t;
pub type xcb_access_error_t = xcb_request_error_t;
pub type xcb_alloc_error_t = xcb_request_error_t;
pub type xcb_colormap_error_t = xcb_value_error_t;
pub type xcb_g_context_error_t = xcb_value_error_t;
pub type xcb_id_choice_error_t = xcb_value_error_t;
pub type xcb_name_error_t = xcb_request_error_t;
pub type xcb_length_error_t = xcb_request_error_t;
pub type xcb_implementation_error_t = xcb_request_error_t;
pub const xcb_window_class_t_XCB_WINDOW_CLASS_COPY_FROM_PARENT: xcb_window_class_t = 0;
pub const xcb_window_class_t_XCB_WINDOW_CLASS_INPUT_OUTPUT: xcb_window_class_t = 1;
pub const xcb_window_class_t_XCB_WINDOW_CLASS_INPUT_ONLY: xcb_window_class_t = 2;
pub type xcb_window_class_t = u32;
pub const xcb_cw_t_XCB_CW_BACK_PIXMAP: xcb_cw_t = 1;
pub const xcb_cw_t_XCB_CW_BACK_PIXEL: xcb_cw_t = 2;
pub const xcb_cw_t_XCB_CW_BORDER_PIXMAP: xcb_cw_t = 4;
pub const xcb_cw_t_XCB_CW_BORDER_PIXEL: xcb_cw_t = 8;
pub const xcb_cw_t_XCB_CW_BIT_GRAVITY: xcb_cw_t = 16;
pub const xcb_cw_t_XCB_CW_WIN_GRAVITY: xcb_cw_t = 32;
pub const xcb_cw_t_XCB_CW_BACKING_STORE: xcb_cw_t = 64;
pub const xcb_cw_t_XCB_CW_BACKING_PLANES: xcb_cw_t = 128;
pub const xcb_cw_t_XCB_CW_BACKING_PIXEL: xcb_cw_t = 256;
pub const xcb_cw_t_XCB_CW_OVERRIDE_REDIRECT: xcb_cw_t = 512;
pub const xcb_cw_t_XCB_CW_SAVE_UNDER: xcb_cw_t = 1024;
pub const xcb_cw_t_XCB_CW_EVENT_MASK: xcb_cw_t = 2048;
pub const xcb_cw_t_XCB_CW_DONT_PROPAGATE: xcb_cw_t = 4096;
pub const xcb_cw_t_XCB_CW_COLORMAP: xcb_cw_t = 8192;
pub const xcb_cw_t_XCB_CW_CURSOR: xcb_cw_t = 16384;
pub type xcb_cw_t = u32;
pub const xcb_back_pixmap_t_XCB_BACK_PIXMAP_NONE: xcb_back_pixmap_t = 0;
pub const xcb_back_pixmap_t_XCB_BACK_PIXMAP_PARENT_RELATIVE: xcb_back_pixmap_t = 1;
pub type xcb_back_pixmap_t = u32;
pub const xcb_gravity_t_XCB_GRAVITY_BIT_FORGET: xcb_gravity_t = 0;
pub const xcb_gravity_t_XCB_GRAVITY_WIN_UNMAP: xcb_gravity_t = 0;
pub const xcb_gravity_t_XCB_GRAVITY_NORTH_WEST: xcb_gravity_t = 1;
pub const xcb_gravity_t_XCB_GRAVITY_NORTH: xcb_gravity_t = 2;
pub const xcb_gravity_t_XCB_GRAVITY_NORTH_EAST: xcb_gravity_t = 3;
pub const xcb_gravity_t_XCB_GRAVITY_WEST: xcb_gravity_t = 4;
pub const xcb_gravity_t_XCB_GRAVITY_CENTER: xcb_gravity_t = 5;
pub const xcb_gravity_t_XCB_GRAVITY_EAST: xcb_gravity_t = 6;
pub const xcb_gravity_t_XCB_GRAVITY_SOUTH_WEST: xcb_gravity_t = 7;
pub const xcb_gravity_t_XCB_GRAVITY_SOUTH: xcb_gravity_t = 8;
pub const xcb_gravity_t_XCB_GRAVITY_SOUTH_EAST: xcb_gravity_t = 9;
pub const xcb_gravity_t_XCB_GRAVITY_STATIC: xcb_gravity_t = 10;
pub type xcb_gravity_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_create_window_value_list_t {
    pub background_pixmap: xcb_pixmap_t,
    pub background_pixel: u32,
    pub border_pixmap: xcb_pixmap_t,
    pub border_pixel: u32,
    pub bit_gravity: u32,
    pub win_gravity: u32,
    pub backing_store: u32,
    pub backing_planes: u32,
    pub backing_pixel: u32,
    pub override_redirect: xcb_bool32_t,
    pub save_under: xcb_bool32_t,
    pub event_mask: u32,
    pub do_not_propogate_mask: u32,
    pub colormap: xcb_colormap_t,
    pub cursor: xcb_cursor_t,
}
#[test]
fn bindgen_test_layout_xcb_create_window_value_list_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_create_window_value_list_t>(),
        60usize,
        concat!("Size of: ", stringify!(xcb_create_window_value_list_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_create_window_value_list_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_create_window_value_list_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_window_value_list_t>())).background_pixmap
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(background_pixmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_window_value_list_t>())).background_pixel as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(background_pixel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_window_value_list_t>())).border_pixmap as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(border_pixmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_window_value_list_t>())).border_pixel as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(border_pixel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_window_value_list_t>())).bit_gravity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(bit_gravity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_window_value_list_t>())).win_gravity as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(win_gravity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_window_value_list_t>())).backing_store as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(backing_store)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_window_value_list_t>())).backing_planes as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(backing_planes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_window_value_list_t>())).backing_pixel as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(backing_pixel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_window_value_list_t>())).override_redirect
                as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(override_redirect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_window_value_list_t>())).save_under as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(save_under)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_window_value_list_t>())).event_mask as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(event_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_window_value_list_t>())).do_not_propogate_mask
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(do_not_propogate_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_window_value_list_t>())).colormap as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(colormap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_window_value_list_t>())).cursor as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_value_list_t),
            "::",
            stringify!(cursor)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_create_window_request_t {
    pub major_opcode: u8,
    pub depth: u8,
    pub length: u16,
    pub wid: xcb_window_t,
    pub parent: xcb_window_t,
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
    pub border_width: u16,
    pub _class: u16,
    pub visual: xcb_visualid_t,
    pub value_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_create_window_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_create_window_request_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_create_window_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_create_window_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_create_window_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_window_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_window_request_t>())).depth as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_request_t),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_window_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_window_request_t>())).wid as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_request_t),
            "::",
            stringify!(wid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_window_request_t>())).parent as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_request_t),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_create_window_request_t>())).x as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_request_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_create_window_request_t>())).y as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_request_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_window_request_t>())).width as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_request_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_window_request_t>())).height as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_request_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_window_request_t>())).border_width as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_request_t),
            "::",
            stringify!(border_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_window_request_t>()))._class as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_request_t),
            "::",
            stringify!(_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_window_request_t>())).visual as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_request_t),
            "::",
            stringify!(visual)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_window_request_t>())).value_mask as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_window_request_t),
            "::",
            stringify!(value_mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_change_window_attributes_value_list_t {
    pub background_pixmap: xcb_pixmap_t,
    pub background_pixel: u32,
    pub border_pixmap: xcb_pixmap_t,
    pub border_pixel: u32,
    pub bit_gravity: u32,
    pub win_gravity: u32,
    pub backing_store: u32,
    pub backing_planes: u32,
    pub backing_pixel: u32,
    pub override_redirect: xcb_bool32_t,
    pub save_under: xcb_bool32_t,
    pub event_mask: u32,
    pub do_not_propogate_mask: u32,
    pub colormap: xcb_colormap_t,
    pub cursor: xcb_cursor_t,
}
#[test]
fn bindgen_test_layout_xcb_change_window_attributes_value_list_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_change_window_attributes_value_list_t>(),
        60usize,
        concat!(
            "Size of: ",
            stringify!(xcb_change_window_attributes_value_list_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_change_window_attributes_value_list_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_change_window_attributes_value_list_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_window_attributes_value_list_t>())).background_pixmap
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(background_pixmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_window_attributes_value_list_t>())).background_pixel
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(background_pixel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_window_attributes_value_list_t>())).border_pixmap
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(border_pixmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_window_attributes_value_list_t>())).border_pixel
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(border_pixel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_window_attributes_value_list_t>())).bit_gravity
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(bit_gravity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_window_attributes_value_list_t>())).win_gravity
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(win_gravity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_window_attributes_value_list_t>())).backing_store
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(backing_store)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_window_attributes_value_list_t>())).backing_planes
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(backing_planes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_window_attributes_value_list_t>())).backing_pixel
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(backing_pixel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_window_attributes_value_list_t>())).override_redirect
                as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(override_redirect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_window_attributes_value_list_t>())).save_under
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(save_under)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_window_attributes_value_list_t>())).event_mask
                as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(event_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_window_attributes_value_list_t>()))
                .do_not_propogate_mask as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(do_not_propogate_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_window_attributes_value_list_t>())).colormap
                as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(colormap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_window_attributes_value_list_t>())).cursor
                as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_value_list_t),
            "::",
            stringify!(cursor)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_change_window_attributes_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
    pub value_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_change_window_attributes_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_change_window_attributes_request_t>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(xcb_change_window_attributes_request_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_change_window_attributes_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_change_window_attributes_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_window_attributes_request_t>())).major_opcode
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_window_attributes_request_t>())).pad0 as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_window_attributes_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_window_attributes_request_t>())).window as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_request_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_window_attributes_request_t>())).value_mask
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_window_attributes_request_t),
            "::",
            stringify!(value_mask)
        )
    );
}
pub const xcb_map_state_t_XCB_MAP_STATE_UNMAPPED: xcb_map_state_t = 0;
pub const xcb_map_state_t_XCB_MAP_STATE_UNVIEWABLE: xcb_map_state_t = 1;
pub const xcb_map_state_t_XCB_MAP_STATE_VIEWABLE: xcb_map_state_t = 2;
pub type xcb_map_state_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_window_attributes_cookie_t {
    pub sequence: cty::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_window_attributes_cookie_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_get_window_attributes_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_window_attributes_cookie_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_get_window_attributes_cookie_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_window_attributes_cookie_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_window_attributes_cookie_t>())).sequence as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_window_attributes_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_get_window_attributes_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_get_window_attributes_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_get_window_attributes_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_get_window_attributes_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_window_attributes_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_window_attributes_request_t>())).major_opcode
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_window_attributes_request_t>())).pad0 as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_window_attributes_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_window_attributes_request_t>())).window as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_request_t),
            "::",
            stringify!(window)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_window_attributes_reply_t {
    pub response_type: u8,
    pub backing_store: u8,
    pub sequence: u16,
    pub length: u32,
    pub visual: xcb_visualid_t,
    pub _class: u16,
    pub bit_gravity: u8,
    pub win_gravity: u8,
    pub backing_planes: u32,
    pub backing_pixel: u32,
    pub save_under: u8,
    pub map_is_installed: u8,
    pub map_state: u8,
    pub override_redirect: u8,
    pub colormap: xcb_colormap_t,
    pub all_event_masks: u32,
    pub your_event_mask: u32,
    pub do_not_propagate_mask: u16,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_get_window_attributes_reply_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_get_window_attributes_reply_t>(),
        44usize,
        concat!("Size of: ", stringify!(xcb_get_window_attributes_reply_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_get_window_attributes_reply_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_window_attributes_reply_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_window_attributes_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_window_attributes_reply_t>())).backing_store as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(backing_store)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_window_attributes_reply_t>())).sequence as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_window_attributes_reply_t>())).length as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_window_attributes_reply_t>())).visual as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(visual)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_window_attributes_reply_t>()))._class as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_window_attributes_reply_t>())).bit_gravity as *const _
                as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(bit_gravity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_window_attributes_reply_t>())).win_gravity as *const _
                as usize
        },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(win_gravity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_window_attributes_reply_t>())).backing_planes
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(backing_planes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_window_attributes_reply_t>())).backing_pixel as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(backing_pixel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_window_attributes_reply_t>())).save_under as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(save_under)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_window_attributes_reply_t>())).map_is_installed
                as *const _ as usize
        },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(map_is_installed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_window_attributes_reply_t>())).map_state as *const _
                as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(map_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_window_attributes_reply_t>())).override_redirect
                as *const _ as usize
        },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(override_redirect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_window_attributes_reply_t>())).colormap as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(colormap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_window_attributes_reply_t>())).all_event_masks
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(all_event_masks)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_window_attributes_reply_t>())).your_event_mask
                as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(your_event_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_window_attributes_reply_t>())).do_not_propagate_mask
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(do_not_propagate_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_window_attributes_reply_t>())).pad0 as *const _ as usize
        },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_window_attributes_reply_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_destroy_window_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_destroy_window_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_destroy_window_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_destroy_window_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_destroy_window_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_destroy_window_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_destroy_window_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_destroy_window_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_destroy_window_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_destroy_window_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_destroy_window_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_destroy_window_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_destroy_window_request_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_destroy_window_request_t),
            "::",
            stringify!(window)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_destroy_subwindows_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_destroy_subwindows_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_destroy_subwindows_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_destroy_subwindows_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_destroy_subwindows_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_destroy_subwindows_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_destroy_subwindows_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_destroy_subwindows_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_destroy_subwindows_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_destroy_subwindows_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_destroy_subwindows_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_destroy_subwindows_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_destroy_subwindows_request_t>())).window as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_destroy_subwindows_request_t),
            "::",
            stringify!(window)
        )
    );
}
pub const xcb_set_mode_t_XCB_SET_MODE_INSERT: xcb_set_mode_t = 0;
pub const xcb_set_mode_t_XCB_SET_MODE_DELETE: xcb_set_mode_t = 1;
pub type xcb_set_mode_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_change_save_set_request_t {
    pub major_opcode: u8,
    pub mode: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_change_save_set_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_change_save_set_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_change_save_set_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_change_save_set_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_change_save_set_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_save_set_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_save_set_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_save_set_request_t>())).mode as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_save_set_request_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_save_set_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_save_set_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_save_set_request_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_save_set_request_t),
            "::",
            stringify!(window)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_reparent_window_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
    pub parent: xcb_window_t,
    pub x: i16,
    pub y: i16,
}
#[test]
fn bindgen_test_layout_xcb_reparent_window_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_reparent_window_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_reparent_window_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_reparent_window_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_reparent_window_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_reparent_window_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_window_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_reparent_window_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_window_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_reparent_window_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_window_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_reparent_window_request_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_window_request_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_reparent_window_request_t>())).parent as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_window_request_t),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_reparent_window_request_t>())).x as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_window_request_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_reparent_window_request_t>())).y as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_reparent_window_request_t),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_map_window_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_map_window_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_map_window_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_map_window_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_map_window_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_map_window_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_map_window_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_window_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_map_window_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_window_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_map_window_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_window_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_map_window_request_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_window_request_t),
            "::",
            stringify!(window)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_map_subwindows_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_map_subwindows_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_map_subwindows_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_map_subwindows_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_map_subwindows_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_map_subwindows_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_map_subwindows_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_subwindows_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_map_subwindows_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_subwindows_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_map_subwindows_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_subwindows_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_map_subwindows_request_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_map_subwindows_request_t),
            "::",
            stringify!(window)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_unmap_window_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_unmap_window_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_unmap_window_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_unmap_window_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_unmap_window_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_unmap_window_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_unmap_window_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_window_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_unmap_window_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_window_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_unmap_window_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_window_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_unmap_window_request_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_window_request_t),
            "::",
            stringify!(window)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_unmap_subwindows_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_unmap_subwindows_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_unmap_subwindows_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_unmap_subwindows_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_unmap_subwindows_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_unmap_subwindows_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_unmap_subwindows_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_subwindows_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_unmap_subwindows_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_subwindows_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_unmap_subwindows_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_subwindows_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_unmap_subwindows_request_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_unmap_subwindows_request_t),
            "::",
            stringify!(window)
        )
    );
}
pub const xcb_config_window_t_XCB_CONFIG_WINDOW_X: xcb_config_window_t = 1;
pub const xcb_config_window_t_XCB_CONFIG_WINDOW_Y: xcb_config_window_t = 2;
pub const xcb_config_window_t_XCB_CONFIG_WINDOW_WIDTH: xcb_config_window_t = 4;
pub const xcb_config_window_t_XCB_CONFIG_WINDOW_HEIGHT: xcb_config_window_t = 8;
pub const xcb_config_window_t_XCB_CONFIG_WINDOW_BORDER_WIDTH: xcb_config_window_t = 16;
pub const xcb_config_window_t_XCB_CONFIG_WINDOW_SIBLING: xcb_config_window_t = 32;
pub const xcb_config_window_t_XCB_CONFIG_WINDOW_STACK_MODE: xcb_config_window_t = 64;
pub type xcb_config_window_t = u32;
pub const xcb_stack_mode_t_XCB_STACK_MODE_ABOVE: xcb_stack_mode_t = 0;
pub const xcb_stack_mode_t_XCB_STACK_MODE_BELOW: xcb_stack_mode_t = 1;
pub const xcb_stack_mode_t_XCB_STACK_MODE_TOP_IF: xcb_stack_mode_t = 2;
pub const xcb_stack_mode_t_XCB_STACK_MODE_BOTTOM_IF: xcb_stack_mode_t = 3;
pub const xcb_stack_mode_t_XCB_STACK_MODE_OPPOSITE: xcb_stack_mode_t = 4;
pub type xcb_stack_mode_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_configure_window_value_list_t {
    pub x: i32,
    pub y: i32,
    pub width: u32,
    pub height: u32,
    pub border_width: u32,
    pub sibling: xcb_window_t,
    pub stack_mode: u32,
}
#[test]
fn bindgen_test_layout_xcb_configure_window_value_list_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_configure_window_value_list_t>(),
        28usize,
        concat!("Size of: ", stringify!(xcb_configure_window_value_list_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_configure_window_value_list_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_configure_window_value_list_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_configure_window_value_list_t>())).x as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_window_value_list_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_configure_window_value_list_t>())).y as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_window_value_list_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_configure_window_value_list_t>())).width as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_window_value_list_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_configure_window_value_list_t>())).height as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_window_value_list_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_configure_window_value_list_t>())).border_width as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_window_value_list_t),
            "::",
            stringify!(border_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_configure_window_value_list_t>())).sibling as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_window_value_list_t),
            "::",
            stringify!(sibling)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_configure_window_value_list_t>())).stack_mode as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_window_value_list_t),
            "::",
            stringify!(stack_mode)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_configure_window_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
    pub value_mask: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_configure_window_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_configure_window_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_configure_window_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_configure_window_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_configure_window_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_configure_window_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_window_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_configure_window_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_window_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_configure_window_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_window_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_configure_window_request_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_window_request_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_configure_window_request_t>())).value_mask as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_window_request_t),
            "::",
            stringify!(value_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_configure_window_request_t>())).pad1 as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_configure_window_request_t),
            "::",
            stringify!(pad1)
        )
    );
}
pub const xcb_circulate_t_XCB_CIRCULATE_RAISE_LOWEST: xcb_circulate_t = 0;
pub const xcb_circulate_t_XCB_CIRCULATE_LOWER_HIGHEST: xcb_circulate_t = 1;
pub type xcb_circulate_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_circulate_window_request_t {
    pub major_opcode: u8,
    pub direction: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_circulate_window_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_circulate_window_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_circulate_window_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_circulate_window_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_circulate_window_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_circulate_window_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_circulate_window_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_circulate_window_request_t>())).direction as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_circulate_window_request_t),
            "::",
            stringify!(direction)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_circulate_window_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_circulate_window_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_circulate_window_request_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_circulate_window_request_t),
            "::",
            stringify!(window)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_geometry_cookie_t {
    pub sequence: cty::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_geometry_cookie_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_get_geometry_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_geometry_cookie_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_get_geometry_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_geometry_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_geometry_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_geometry_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
}
#[test]
fn bindgen_test_layout_xcb_get_geometry_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_get_geometry_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_get_geometry_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_get_geometry_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_geometry_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_geometry_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_geometry_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_geometry_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_geometry_request_t>())).drawable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_request_t),
            "::",
            stringify!(drawable)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_geometry_reply_t {
    pub response_type: u8,
    pub depth: u8,
    pub sequence: u16,
    pub length: u32,
    pub root: xcb_window_t,
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
    pub border_width: u16,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_get_geometry_reply_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_get_geometry_reply_t>(),
        24usize,
        concat!("Size of: ", stringify!(xcb_get_geometry_reply_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_get_geometry_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_geometry_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_geometry_reply_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_get_geometry_reply_t>())).depth as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_reply_t),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_geometry_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_geometry_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_get_geometry_reply_t>())).root as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_reply_t),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_get_geometry_reply_t>())).x as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_reply_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_get_geometry_reply_t>())).y as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_reply_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_get_geometry_reply_t>())).width as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_reply_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_geometry_reply_t>())).height as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_reply_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_geometry_reply_t>())).border_width as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_reply_t),
            "::",
            stringify!(border_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_get_geometry_reply_t>())).pad0 as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_geometry_reply_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_tree_cookie_t {
    pub sequence: cty::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_query_tree_cookie_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_query_tree_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_query_tree_cookie_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_query_tree_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_tree_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_tree_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_tree_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_tree_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_query_tree_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_query_tree_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_query_tree_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_query_tree_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_tree_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_tree_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_tree_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_query_tree_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_tree_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_tree_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_tree_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_tree_request_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_tree_request_t),
            "::",
            stringify!(window)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_tree_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub root: xcb_window_t,
    pub parent: xcb_window_t,
    pub children_len: u16,
    pub pad1: [u8; 14usize],
}
#[test]
fn bindgen_test_layout_xcb_query_tree_reply_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_query_tree_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_query_tree_reply_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_query_tree_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_tree_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_tree_reply_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_tree_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_query_tree_reply_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_tree_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_tree_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_tree_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_query_tree_reply_t>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_tree_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_query_tree_reply_t>())).root as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_tree_reply_t),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_query_tree_reply_t>())).parent as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_tree_reply_t),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_tree_reply_t>())).children_len as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_tree_reply_t),
            "::",
            stringify!(children_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_query_tree_reply_t>())).pad1 as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_tree_reply_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_intern_atom_cookie_t {
    pub sequence: cty::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_intern_atom_cookie_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_intern_atom_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_intern_atom_cookie_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_intern_atom_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_intern_atom_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_intern_atom_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_intern_atom_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_intern_atom_request_t {
    pub major_opcode: u8,
    pub only_if_exists: u8,
    pub length: u16,
    pub name_len: u16,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_intern_atom_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_intern_atom_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_intern_atom_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_intern_atom_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_intern_atom_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_intern_atom_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_intern_atom_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_intern_atom_request_t>())).only_if_exists as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_intern_atom_request_t),
            "::",
            stringify!(only_if_exists)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_intern_atom_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_intern_atom_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_intern_atom_request_t>())).name_len as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_intern_atom_request_t),
            "::",
            stringify!(name_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_intern_atom_request_t>())).pad0 as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_intern_atom_request_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_intern_atom_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub atom: xcb_atom_t,
}
#[test]
fn bindgen_test_layout_xcb_intern_atom_reply_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_intern_atom_reply_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_intern_atom_reply_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_intern_atom_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_intern_atom_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_intern_atom_reply_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_intern_atom_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_intern_atom_reply_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_intern_atom_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_intern_atom_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_intern_atom_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_intern_atom_reply_t>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_intern_atom_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_intern_atom_reply_t>())).atom as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_intern_atom_reply_t),
            "::",
            stringify!(atom)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_atom_name_cookie_t {
    pub sequence: cty::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_atom_name_cookie_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_get_atom_name_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_atom_name_cookie_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_get_atom_name_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_atom_name_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_atom_name_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_atom_name_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_atom_name_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub atom: xcb_atom_t,
}
#[test]
fn bindgen_test_layout_xcb_get_atom_name_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_get_atom_name_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_get_atom_name_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_get_atom_name_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_atom_name_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_atom_name_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_atom_name_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_atom_name_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_atom_name_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_atom_name_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_atom_name_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_atom_name_request_t>())).atom as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_atom_name_request_t),
            "::",
            stringify!(atom)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_atom_name_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub name_len: u16,
    pub pad1: [u8; 22usize],
}
#[test]
fn bindgen_test_layout_xcb_get_atom_name_reply_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_get_atom_name_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_get_atom_name_reply_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_get_atom_name_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_atom_name_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_atom_name_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_atom_name_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_get_atom_name_reply_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_atom_name_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_atom_name_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_atom_name_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_atom_name_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_atom_name_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_atom_name_reply_t>())).name_len as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_atom_name_reply_t),
            "::",
            stringify!(name_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_get_atom_name_reply_t>())).pad1 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_atom_name_reply_t),
            "::",
            stringify!(pad1)
        )
    );
}
pub const xcb_prop_mode_t_XCB_PROP_MODE_REPLACE: xcb_prop_mode_t = 0;
pub const xcb_prop_mode_t_XCB_PROP_MODE_PREPEND: xcb_prop_mode_t = 1;
pub const xcb_prop_mode_t_XCB_PROP_MODE_APPEND: xcb_prop_mode_t = 2;
pub type xcb_prop_mode_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_change_property_request_t {
    pub major_opcode: u8,
    pub mode: u8,
    pub length: u16,
    pub window: xcb_window_t,
    pub property: xcb_atom_t,
    pub type_: xcb_atom_t,
    pub format: u8,
    pub pad0: [u8; 3usize],
    pub data_len: u32,
}
#[test]
fn bindgen_test_layout_xcb_change_property_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_change_property_request_t>(),
        24usize,
        concat!("Size of: ", stringify!(xcb_change_property_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_change_property_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_change_property_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_property_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_property_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_property_request_t>())).mode as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_property_request_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_property_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_property_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_property_request_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_property_request_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_property_request_t>())).property as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_property_request_t),
            "::",
            stringify!(property)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_property_request_t>())).type_ as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_property_request_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_property_request_t>())).format as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_property_request_t),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_property_request_t>())).pad0 as *const _ as usize
        },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_property_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_property_request_t>())).data_len as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_property_request_t),
            "::",
            stringify!(data_len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_delete_property_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
    pub property: xcb_atom_t,
}
#[test]
fn bindgen_test_layout_xcb_delete_property_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_delete_property_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_delete_property_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_delete_property_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_delete_property_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_delete_property_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_delete_property_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_delete_property_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_delete_property_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_delete_property_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_delete_property_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_delete_property_request_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_delete_property_request_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_delete_property_request_t>())).property as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_delete_property_request_t),
            "::",
            stringify!(property)
        )
    );
}
pub const xcb_get_property_type_t_XCB_GET_PROPERTY_TYPE_ANY: xcb_get_property_type_t = 0;
pub type xcb_get_property_type_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_property_cookie_t {
    pub sequence: cty::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_property_cookie_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_get_property_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_property_cookie_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_get_property_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_property_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_property_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_property_request_t {
    pub major_opcode: u8,
    pub _delete: u8,
    pub length: u16,
    pub window: xcb_window_t,
    pub property: xcb_atom_t,
    pub type_: xcb_atom_t,
    pub long_offset: u32,
    pub long_length: u32,
}
#[test]
fn bindgen_test_layout_xcb_get_property_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_get_property_request_t>(),
        24usize,
        concat!("Size of: ", stringify!(xcb_get_property_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_get_property_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_property_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_property_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_property_request_t>()))._delete as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_request_t),
            "::",
            stringify!(_delete)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_property_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_property_request_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_request_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_property_request_t>())).property as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_request_t),
            "::",
            stringify!(property)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_property_request_t>())).type_ as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_request_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_property_request_t>())).long_offset as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_request_t),
            "::",
            stringify!(long_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_property_request_t>())).long_length as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_request_t),
            "::",
            stringify!(long_length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_property_reply_t {
    pub response_type: u8,
    pub format: u8,
    pub sequence: u16,
    pub length: u32,
    pub type_: xcb_atom_t,
    pub bytes_after: u32,
    pub value_len: u32,
    pub pad0: [u8; 12usize],
}
#[test]
fn bindgen_test_layout_xcb_get_property_reply_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_get_property_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_get_property_reply_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_get_property_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_property_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_property_reply_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_property_reply_t>())).format as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_reply_t),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_property_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_property_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_get_property_reply_t>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_reply_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_property_reply_t>())).bytes_after as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_reply_t),
            "::",
            stringify!(bytes_after)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_property_reply_t>())).value_len as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_reply_t),
            "::",
            stringify!(value_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_get_property_reply_t>())).pad0 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_property_reply_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_properties_cookie_t {
    pub sequence: cty::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_list_properties_cookie_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_list_properties_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_list_properties_cookie_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_list_properties_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_list_properties_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_properties_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_properties_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_properties_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_list_properties_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_list_properties_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_list_properties_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_list_properties_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_list_properties_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_properties_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_properties_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_properties_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_properties_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_properties_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_properties_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_properties_request_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_properties_request_t),
            "::",
            stringify!(window)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_properties_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub atoms_len: u16,
    pub pad1: [u8; 22usize],
}
#[test]
fn bindgen_test_layout_xcb_list_properties_reply_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_list_properties_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_list_properties_reply_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_list_properties_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_list_properties_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_properties_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_properties_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_properties_reply_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_properties_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_properties_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_properties_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_properties_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_properties_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_properties_reply_t>())).atoms_len as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_properties_reply_t),
            "::",
            stringify!(atoms_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_properties_reply_t>())).pad1 as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_properties_reply_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_set_selection_owner_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub owner: xcb_window_t,
    pub selection: xcb_atom_t,
    pub time: xcb_timestamp_t,
}
#[test]
fn bindgen_test_layout_xcb_set_selection_owner_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_set_selection_owner_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_set_selection_owner_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_set_selection_owner_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_set_selection_owner_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_set_selection_owner_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_selection_owner_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_set_selection_owner_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_selection_owner_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_set_selection_owner_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_selection_owner_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_set_selection_owner_request_t>())).owner as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_selection_owner_request_t),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_set_selection_owner_request_t>())).selection as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_selection_owner_request_t),
            "::",
            stringify!(selection)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_set_selection_owner_request_t>())).time as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_selection_owner_request_t),
            "::",
            stringify!(time)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_selection_owner_cookie_t {
    pub sequence: cty::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_selection_owner_cookie_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_get_selection_owner_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_selection_owner_cookie_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_get_selection_owner_cookie_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_selection_owner_cookie_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_selection_owner_cookie_t>())).sequence as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_selection_owner_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_selection_owner_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub selection: xcb_atom_t,
}
#[test]
fn bindgen_test_layout_xcb_get_selection_owner_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_get_selection_owner_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_get_selection_owner_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_get_selection_owner_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_selection_owner_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_selection_owner_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_selection_owner_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_selection_owner_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_selection_owner_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_selection_owner_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_selection_owner_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_selection_owner_request_t>())).selection as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_selection_owner_request_t),
            "::",
            stringify!(selection)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_selection_owner_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub owner: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_get_selection_owner_reply_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_get_selection_owner_reply_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_get_selection_owner_reply_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_get_selection_owner_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_selection_owner_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_selection_owner_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_selection_owner_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_selection_owner_reply_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_selection_owner_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_selection_owner_reply_t>())).sequence as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_selection_owner_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_selection_owner_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_selection_owner_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_selection_owner_reply_t>())).owner as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_selection_owner_reply_t),
            "::",
            stringify!(owner)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_convert_selection_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub requestor: xcb_window_t,
    pub selection: xcb_atom_t,
    pub target: xcb_atom_t,
    pub property: xcb_atom_t,
    pub time: xcb_timestamp_t,
}
#[test]
fn bindgen_test_layout_xcb_convert_selection_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_convert_selection_request_t>(),
        24usize,
        concat!("Size of: ", stringify!(xcb_convert_selection_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_convert_selection_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_convert_selection_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_convert_selection_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_convert_selection_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_convert_selection_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_convert_selection_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_convert_selection_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_convert_selection_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_convert_selection_request_t>())).requestor as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_convert_selection_request_t),
            "::",
            stringify!(requestor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_convert_selection_request_t>())).selection as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_convert_selection_request_t),
            "::",
            stringify!(selection)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_convert_selection_request_t>())).target as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_convert_selection_request_t),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_convert_selection_request_t>())).property as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_convert_selection_request_t),
            "::",
            stringify!(property)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_convert_selection_request_t>())).time as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_convert_selection_request_t),
            "::",
            stringify!(time)
        )
    );
}
pub const xcb_send_event_dest_t_XCB_SEND_EVENT_DEST_POINTER_WINDOW: xcb_send_event_dest_t = 0;
pub const xcb_send_event_dest_t_XCB_SEND_EVENT_DEST_ITEM_FOCUS: xcb_send_event_dest_t = 1;
pub type xcb_send_event_dest_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_send_event_request_t {
    pub major_opcode: u8,
    pub propagate: u8,
    pub length: u16,
    pub destination: xcb_window_t,
    pub event_mask: u32,
    pub event: [cty::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_xcb_send_event_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_send_event_request_t>(),
        44usize,
        concat!("Size of: ", stringify!(xcb_send_event_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_send_event_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_send_event_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_send_event_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_send_event_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_send_event_request_t>())).propagate as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_send_event_request_t),
            "::",
            stringify!(propagate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_send_event_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_send_event_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_send_event_request_t>())).destination as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_send_event_request_t),
            "::",
            stringify!(destination)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_send_event_request_t>())).event_mask as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_send_event_request_t),
            "::",
            stringify!(event_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_send_event_request_t>())).event as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_send_event_request_t),
            "::",
            stringify!(event)
        )
    );
}
pub const xcb_grab_mode_t_XCB_GRAB_MODE_SYNC: xcb_grab_mode_t = 0;
pub const xcb_grab_mode_t_XCB_GRAB_MODE_ASYNC: xcb_grab_mode_t = 1;
pub type xcb_grab_mode_t = u32;
pub const xcb_grab_status_t_XCB_GRAB_STATUS_SUCCESS: xcb_grab_status_t = 0;
pub const xcb_grab_status_t_XCB_GRAB_STATUS_ALREADY_GRABBED: xcb_grab_status_t = 1;
pub const xcb_grab_status_t_XCB_GRAB_STATUS_INVALID_TIME: xcb_grab_status_t = 2;
pub const xcb_grab_status_t_XCB_GRAB_STATUS_NOT_VIEWABLE: xcb_grab_status_t = 3;
pub const xcb_grab_status_t_XCB_GRAB_STATUS_FROZEN: xcb_grab_status_t = 4;
pub type xcb_grab_status_t = u32;
pub const xcb_cursor_enum_t_XCB_CURSOR_NONE: xcb_cursor_enum_t = 0;
pub type xcb_cursor_enum_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_grab_pointer_cookie_t {
    pub sequence: cty::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_grab_pointer_cookie_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_grab_pointer_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_grab_pointer_cookie_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_grab_pointer_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_grab_pointer_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_grab_pointer_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_grab_pointer_request_t {
    pub major_opcode: u8,
    pub owner_events: u8,
    pub length: u16,
    pub grab_window: xcb_window_t,
    pub event_mask: u16,
    pub pointer_mode: u8,
    pub keyboard_mode: u8,
    pub confine_to: xcb_window_t,
    pub cursor: xcb_cursor_t,
    pub time: xcb_timestamp_t,
}
#[test]
fn bindgen_test_layout_xcb_grab_pointer_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_grab_pointer_request_t>(),
        24usize,
        concat!("Size of: ", stringify!(xcb_grab_pointer_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_grab_pointer_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_grab_pointer_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_grab_pointer_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_grab_pointer_request_t>())).owner_events as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_request_t),
            "::",
            stringify!(owner_events)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_grab_pointer_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_grab_pointer_request_t>())).grab_window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_request_t),
            "::",
            stringify!(grab_window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_grab_pointer_request_t>())).event_mask as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_request_t),
            "::",
            stringify!(event_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_grab_pointer_request_t>())).pointer_mode as *const _
                as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_request_t),
            "::",
            stringify!(pointer_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_grab_pointer_request_t>())).keyboard_mode as *const _
                as usize
        },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_request_t),
            "::",
            stringify!(keyboard_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_grab_pointer_request_t>())).confine_to as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_request_t),
            "::",
            stringify!(confine_to)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_grab_pointer_request_t>())).cursor as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_request_t),
            "::",
            stringify!(cursor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_grab_pointer_request_t>())).time as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_request_t),
            "::",
            stringify!(time)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_grab_pointer_reply_t {
    pub response_type: u8,
    pub status: u8,
    pub sequence: u16,
    pub length: u32,
}
#[test]
fn bindgen_test_layout_xcb_grab_pointer_reply_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_grab_pointer_reply_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_grab_pointer_reply_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_grab_pointer_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_grab_pointer_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_grab_pointer_reply_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_grab_pointer_reply_t>())).status as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_reply_t),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_grab_pointer_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_grab_pointer_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_pointer_reply_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_ungrab_pointer_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub time: xcb_timestamp_t,
}
#[test]
fn bindgen_test_layout_xcb_ungrab_pointer_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_ungrab_pointer_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_ungrab_pointer_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_ungrab_pointer_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_ungrab_pointer_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_ungrab_pointer_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_pointer_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_ungrab_pointer_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_pointer_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_ungrab_pointer_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_pointer_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_ungrab_pointer_request_t>())).time as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_pointer_request_t),
            "::",
            stringify!(time)
        )
    );
}
pub const xcb_button_index_t_XCB_BUTTON_INDEX_ANY: xcb_button_index_t = 0;
pub const xcb_button_index_t_XCB_BUTTON_INDEX_1: xcb_button_index_t = 1;
pub const xcb_button_index_t_XCB_BUTTON_INDEX_2: xcb_button_index_t = 2;
pub const xcb_button_index_t_XCB_BUTTON_INDEX_3: xcb_button_index_t = 3;
pub const xcb_button_index_t_XCB_BUTTON_INDEX_4: xcb_button_index_t = 4;
pub const xcb_button_index_t_XCB_BUTTON_INDEX_5: xcb_button_index_t = 5;
pub type xcb_button_index_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_grab_button_request_t {
    pub major_opcode: u8,
    pub owner_events: u8,
    pub length: u16,
    pub grab_window: xcb_window_t,
    pub event_mask: u16,
    pub pointer_mode: u8,
    pub keyboard_mode: u8,
    pub confine_to: xcb_window_t,
    pub cursor: xcb_cursor_t,
    pub button: u8,
    pub pad0: u8,
    pub modifiers: u16,
}
#[test]
fn bindgen_test_layout_xcb_grab_button_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_grab_button_request_t>(),
        24usize,
        concat!("Size of: ", stringify!(xcb_grab_button_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_grab_button_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_grab_button_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_grab_button_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_button_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_grab_button_request_t>())).owner_events as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_button_request_t),
            "::",
            stringify!(owner_events)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_grab_button_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_button_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_grab_button_request_t>())).grab_window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_button_request_t),
            "::",
            stringify!(grab_window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_grab_button_request_t>())).event_mask as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_button_request_t),
            "::",
            stringify!(event_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_grab_button_request_t>())).pointer_mode as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_button_request_t),
            "::",
            stringify!(pointer_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_grab_button_request_t>())).keyboard_mode as *const _
                as usize
        },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_button_request_t),
            "::",
            stringify!(keyboard_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_grab_button_request_t>())).confine_to as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_button_request_t),
            "::",
            stringify!(confine_to)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_grab_button_request_t>())).cursor as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_button_request_t),
            "::",
            stringify!(cursor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_grab_button_request_t>())).button as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_button_request_t),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_grab_button_request_t>())).pad0 as *const _ as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_button_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_grab_button_request_t>())).modifiers as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_button_request_t),
            "::",
            stringify!(modifiers)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_ungrab_button_request_t {
    pub major_opcode: u8,
    pub button: u8,
    pub length: u16,
    pub grab_window: xcb_window_t,
    pub modifiers: u16,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_ungrab_button_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_ungrab_button_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_ungrab_button_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_ungrab_button_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_ungrab_button_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_ungrab_button_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_button_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_ungrab_button_request_t>())).button as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_button_request_t),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_ungrab_button_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_button_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_ungrab_button_request_t>())).grab_window as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_button_request_t),
            "::",
            stringify!(grab_window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_ungrab_button_request_t>())).modifiers as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_button_request_t),
            "::",
            stringify!(modifiers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_ungrab_button_request_t>())).pad0 as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_button_request_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_change_active_pointer_grab_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cursor: xcb_cursor_t,
    pub time: xcb_timestamp_t,
    pub event_mask: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_change_active_pointer_grab_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_change_active_pointer_grab_request_t>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(xcb_change_active_pointer_grab_request_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_change_active_pointer_grab_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_change_active_pointer_grab_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_active_pointer_grab_request_t>())).major_opcode
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_active_pointer_grab_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_active_pointer_grab_request_t>())).pad0 as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_active_pointer_grab_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_active_pointer_grab_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_active_pointer_grab_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_active_pointer_grab_request_t>())).cursor as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_active_pointer_grab_request_t),
            "::",
            stringify!(cursor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_active_pointer_grab_request_t>())).time as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_active_pointer_grab_request_t),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_active_pointer_grab_request_t>())).event_mask
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_active_pointer_grab_request_t),
            "::",
            stringify!(event_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_active_pointer_grab_request_t>())).pad1 as *const _
                as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_active_pointer_grab_request_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_grab_keyboard_cookie_t {
    pub sequence: cty::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_grab_keyboard_cookie_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_grab_keyboard_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_grab_keyboard_cookie_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_grab_keyboard_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_grab_keyboard_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_grab_keyboard_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_keyboard_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_grab_keyboard_request_t {
    pub major_opcode: u8,
    pub owner_events: u8,
    pub length: u16,
    pub grab_window: xcb_window_t,
    pub time: xcb_timestamp_t,
    pub pointer_mode: u8,
    pub keyboard_mode: u8,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_grab_keyboard_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_grab_keyboard_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_grab_keyboard_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_grab_keyboard_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_grab_keyboard_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_grab_keyboard_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_keyboard_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_grab_keyboard_request_t>())).owner_events as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_keyboard_request_t),
            "::",
            stringify!(owner_events)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_grab_keyboard_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_keyboard_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_grab_keyboard_request_t>())).grab_window as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_keyboard_request_t),
            "::",
            stringify!(grab_window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_grab_keyboard_request_t>())).time as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_keyboard_request_t),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_grab_keyboard_request_t>())).pointer_mode as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_keyboard_request_t),
            "::",
            stringify!(pointer_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_grab_keyboard_request_t>())).keyboard_mode as *const _
                as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_keyboard_request_t),
            "::",
            stringify!(keyboard_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_grab_keyboard_request_t>())).pad0 as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_keyboard_request_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_grab_keyboard_reply_t {
    pub response_type: u8,
    pub status: u8,
    pub sequence: u16,
    pub length: u32,
}
#[test]
fn bindgen_test_layout_xcb_grab_keyboard_reply_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_grab_keyboard_reply_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_grab_keyboard_reply_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_grab_keyboard_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_grab_keyboard_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_grab_keyboard_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_keyboard_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_grab_keyboard_reply_t>())).status as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_keyboard_reply_t),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_grab_keyboard_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_keyboard_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_grab_keyboard_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_keyboard_reply_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_ungrab_keyboard_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub time: xcb_timestamp_t,
}
#[test]
fn bindgen_test_layout_xcb_ungrab_keyboard_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_ungrab_keyboard_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_ungrab_keyboard_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_ungrab_keyboard_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_ungrab_keyboard_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_ungrab_keyboard_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_keyboard_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_ungrab_keyboard_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_keyboard_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_ungrab_keyboard_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_keyboard_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_ungrab_keyboard_request_t>())).time as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_keyboard_request_t),
            "::",
            stringify!(time)
        )
    );
}
pub const xcb_grab_t_XCB_GRAB_ANY: xcb_grab_t = 0;
pub type xcb_grab_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_grab_key_request_t {
    pub major_opcode: u8,
    pub owner_events: u8,
    pub length: u16,
    pub grab_window: xcb_window_t,
    pub modifiers: u16,
    pub key: xcb_keycode_t,
    pub pointer_mode: u8,
    pub keyboard_mode: u8,
    pub pad0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_xcb_grab_key_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_grab_key_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_grab_key_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_grab_key_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_grab_key_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_grab_key_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_key_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_grab_key_request_t>())).owner_events as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_key_request_t),
            "::",
            stringify!(owner_events)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_grab_key_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_key_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_grab_key_request_t>())).grab_window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_key_request_t),
            "::",
            stringify!(grab_window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_grab_key_request_t>())).modifiers as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_key_request_t),
            "::",
            stringify!(modifiers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_grab_key_request_t>())).key as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_key_request_t),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_grab_key_request_t>())).pointer_mode as *const _ as usize
        },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_key_request_t),
            "::",
            stringify!(pointer_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_grab_key_request_t>())).keyboard_mode as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_key_request_t),
            "::",
            stringify!(keyboard_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_grab_key_request_t>())).pad0 as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_key_request_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_ungrab_key_request_t {
    pub major_opcode: u8,
    pub key: xcb_keycode_t,
    pub length: u16,
    pub grab_window: xcb_window_t,
    pub modifiers: u16,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_ungrab_key_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_ungrab_key_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_ungrab_key_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_ungrab_key_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_ungrab_key_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_ungrab_key_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_key_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_ungrab_key_request_t>())).key as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_key_request_t),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_ungrab_key_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_key_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_ungrab_key_request_t>())).grab_window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_key_request_t),
            "::",
            stringify!(grab_window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_ungrab_key_request_t>())).modifiers as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_key_request_t),
            "::",
            stringify!(modifiers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_ungrab_key_request_t>())).pad0 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_key_request_t),
            "::",
            stringify!(pad0)
        )
    );
}
pub const xcb_allow_t_XCB_ALLOW_ASYNC_POINTER: xcb_allow_t = 0;
pub const xcb_allow_t_XCB_ALLOW_SYNC_POINTER: xcb_allow_t = 1;
pub const xcb_allow_t_XCB_ALLOW_REPLAY_POINTER: xcb_allow_t = 2;
pub const xcb_allow_t_XCB_ALLOW_ASYNC_KEYBOARD: xcb_allow_t = 3;
pub const xcb_allow_t_XCB_ALLOW_SYNC_KEYBOARD: xcb_allow_t = 4;
pub const xcb_allow_t_XCB_ALLOW_REPLAY_KEYBOARD: xcb_allow_t = 5;
pub const xcb_allow_t_XCB_ALLOW_ASYNC_BOTH: xcb_allow_t = 6;
pub const xcb_allow_t_XCB_ALLOW_SYNC_BOTH: xcb_allow_t = 7;
pub type xcb_allow_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_allow_events_request_t {
    pub major_opcode: u8,
    pub mode: u8,
    pub length: u16,
    pub time: xcb_timestamp_t,
}
#[test]
fn bindgen_test_layout_xcb_allow_events_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_allow_events_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_allow_events_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_allow_events_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_allow_events_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_allow_events_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_allow_events_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_allow_events_request_t>())).mode as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_allow_events_request_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_allow_events_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_allow_events_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_allow_events_request_t>())).time as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_allow_events_request_t),
            "::",
            stringify!(time)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_grab_server_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_grab_server_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_grab_server_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_grab_server_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_grab_server_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_grab_server_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_grab_server_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_server_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_grab_server_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_server_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_grab_server_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_grab_server_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_ungrab_server_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_ungrab_server_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_ungrab_server_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_ungrab_server_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_ungrab_server_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_ungrab_server_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_ungrab_server_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_server_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_ungrab_server_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_server_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_ungrab_server_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_ungrab_server_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_pointer_cookie_t {
    pub sequence: cty::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_query_pointer_cookie_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_query_pointer_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_query_pointer_cookie_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_query_pointer_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_pointer_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_pointer_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_pointer_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_query_pointer_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_query_pointer_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_query_pointer_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_query_pointer_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_pointer_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_pointer_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_pointer_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_pointer_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_pointer_request_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_request_t),
            "::",
            stringify!(window)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_pointer_reply_t {
    pub response_type: u8,
    pub same_screen: u8,
    pub sequence: u16,
    pub length: u32,
    pub root: xcb_window_t,
    pub child: xcb_window_t,
    pub root_x: i16,
    pub root_y: i16,
    pub win_x: i16,
    pub win_y: i16,
    pub mask: u16,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_query_pointer_reply_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_query_pointer_reply_t>(),
        28usize,
        concat!("Size of: ", stringify!(xcb_query_pointer_reply_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_query_pointer_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_pointer_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_pointer_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_pointer_reply_t>())).same_screen as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_reply_t),
            "::",
            stringify!(same_screen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_pointer_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_pointer_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_query_pointer_reply_t>())).root as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_reply_t),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_pointer_reply_t>())).child as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_reply_t),
            "::",
            stringify!(child)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_pointer_reply_t>())).root_x as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_reply_t),
            "::",
            stringify!(root_x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_pointer_reply_t>())).root_y as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_reply_t),
            "::",
            stringify!(root_y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_pointer_reply_t>())).win_x as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_reply_t),
            "::",
            stringify!(win_x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_pointer_reply_t>())).win_y as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_reply_t),
            "::",
            stringify!(win_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_query_pointer_reply_t>())).mask as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_reply_t),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_query_pointer_reply_t>())).pad0 as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_pointer_reply_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_timecoord_t {
    pub time: xcb_timestamp_t,
    pub x: i16,
    pub y: i16,
}
#[test]
fn bindgen_test_layout_xcb_timecoord_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_timecoord_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_timecoord_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_timecoord_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_timecoord_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_timecoord_t>())).time as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_timecoord_t),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_timecoord_t>())).x as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_timecoord_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_timecoord_t>())).y as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_timecoord_t),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_timecoord_iterator_t {
    pub data: *mut xcb_timecoord_t,
    pub rem: cty::c_int,
    pub index: cty::c_int,
}
#[test]
fn bindgen_test_layout_xcb_timecoord_iterator_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_timecoord_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_timecoord_iterator_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_timecoord_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_timecoord_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_timecoord_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_timecoord_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_timecoord_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_timecoord_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_timecoord_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_timecoord_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_motion_events_cookie_t {
    pub sequence: cty::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_motion_events_cookie_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_get_motion_events_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_motion_events_cookie_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_get_motion_events_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_motion_events_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_motion_events_cookie_t>())).sequence as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_motion_events_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_motion_events_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
    pub start: xcb_timestamp_t,
    pub stop: xcb_timestamp_t,
}
#[test]
fn bindgen_test_layout_xcb_get_motion_events_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_get_motion_events_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_get_motion_events_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_get_motion_events_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_motion_events_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_motion_events_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_motion_events_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_motion_events_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_motion_events_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_motion_events_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_motion_events_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_motion_events_request_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_motion_events_request_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_motion_events_request_t>())).start as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_motion_events_request_t),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_motion_events_request_t>())).stop as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_motion_events_request_t),
            "::",
            stringify!(stop)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_motion_events_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub events_len: u32,
    pub pad1: [u8; 20usize],
}
#[test]
fn bindgen_test_layout_xcb_get_motion_events_reply_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_get_motion_events_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_get_motion_events_reply_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_get_motion_events_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_motion_events_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_motion_events_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_motion_events_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_motion_events_reply_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_motion_events_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_motion_events_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_motion_events_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_motion_events_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_motion_events_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_motion_events_reply_t>())).events_len as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_motion_events_reply_t),
            "::",
            stringify!(events_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_motion_events_reply_t>())).pad1 as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_motion_events_reply_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_translate_coordinates_cookie_t {
    pub sequence: cty::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_translate_coordinates_cookie_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_translate_coordinates_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_translate_coordinates_cookie_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_translate_coordinates_cookie_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_translate_coordinates_cookie_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_translate_coordinates_cookie_t>())).sequence as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_translate_coordinates_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub src_window: xcb_window_t,
    pub dst_window: xcb_window_t,
    pub src_x: i16,
    pub src_y: i16,
}
#[test]
fn bindgen_test_layout_xcb_translate_coordinates_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_translate_coordinates_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_translate_coordinates_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_translate_coordinates_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_translate_coordinates_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_translate_coordinates_request_t>())).major_opcode
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_translate_coordinates_request_t>())).pad0 as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_translate_coordinates_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_translate_coordinates_request_t>())).src_window as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_request_t),
            "::",
            stringify!(src_window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_translate_coordinates_request_t>())).dst_window as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_request_t),
            "::",
            stringify!(dst_window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_translate_coordinates_request_t>())).src_x as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_request_t),
            "::",
            stringify!(src_x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_translate_coordinates_request_t>())).src_y as *const _
                as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_request_t),
            "::",
            stringify!(src_y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_translate_coordinates_reply_t {
    pub response_type: u8,
    pub same_screen: u8,
    pub sequence: u16,
    pub length: u32,
    pub child: xcb_window_t,
    pub dst_x: i16,
    pub dst_y: i16,
}
#[test]
fn bindgen_test_layout_xcb_translate_coordinates_reply_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_translate_coordinates_reply_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_translate_coordinates_reply_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_translate_coordinates_reply_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_translate_coordinates_reply_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_translate_coordinates_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_translate_coordinates_reply_t>())).same_screen as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_reply_t),
            "::",
            stringify!(same_screen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_translate_coordinates_reply_t>())).sequence as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_translate_coordinates_reply_t>())).length as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_translate_coordinates_reply_t>())).child as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_reply_t),
            "::",
            stringify!(child)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_translate_coordinates_reply_t>())).dst_x as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_reply_t),
            "::",
            stringify!(dst_x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_translate_coordinates_reply_t>())).dst_y as *const _
                as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_translate_coordinates_reply_t),
            "::",
            stringify!(dst_y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_warp_pointer_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub src_window: xcb_window_t,
    pub dst_window: xcb_window_t,
    pub src_x: i16,
    pub src_y: i16,
    pub src_width: u16,
    pub src_height: u16,
    pub dst_x: i16,
    pub dst_y: i16,
}
#[test]
fn bindgen_test_layout_xcb_warp_pointer_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_warp_pointer_request_t>(),
        24usize,
        concat!("Size of: ", stringify!(xcb_warp_pointer_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_warp_pointer_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_warp_pointer_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_warp_pointer_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_warp_pointer_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_warp_pointer_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_warp_pointer_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_warp_pointer_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_warp_pointer_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_warp_pointer_request_t>())).src_window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_warp_pointer_request_t),
            "::",
            stringify!(src_window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_warp_pointer_request_t>())).dst_window as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_warp_pointer_request_t),
            "::",
            stringify!(dst_window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_warp_pointer_request_t>())).src_x as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_warp_pointer_request_t),
            "::",
            stringify!(src_x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_warp_pointer_request_t>())).src_y as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_warp_pointer_request_t),
            "::",
            stringify!(src_y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_warp_pointer_request_t>())).src_width as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_warp_pointer_request_t),
            "::",
            stringify!(src_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_warp_pointer_request_t>())).src_height as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_warp_pointer_request_t),
            "::",
            stringify!(src_height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_warp_pointer_request_t>())).dst_x as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_warp_pointer_request_t),
            "::",
            stringify!(dst_x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_warp_pointer_request_t>())).dst_y as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_warp_pointer_request_t),
            "::",
            stringify!(dst_y)
        )
    );
}
pub const xcb_input_focus_t_XCB_INPUT_FOCUS_NONE: xcb_input_focus_t = 0;
pub const xcb_input_focus_t_XCB_INPUT_FOCUS_POINTER_ROOT: xcb_input_focus_t = 1;
pub const xcb_input_focus_t_XCB_INPUT_FOCUS_PARENT: xcb_input_focus_t = 2;
pub const xcb_input_focus_t_XCB_INPUT_FOCUS_FOLLOW_KEYBOARD: xcb_input_focus_t = 3;
pub type xcb_input_focus_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_set_input_focus_request_t {
    pub major_opcode: u8,
    pub revert_to: u8,
    pub length: u16,
    pub focus: xcb_window_t,
    pub time: xcb_timestamp_t,
}
#[test]
fn bindgen_test_layout_xcb_set_input_focus_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_set_input_focus_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_set_input_focus_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_set_input_focus_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_set_input_focus_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_set_input_focus_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_input_focus_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_set_input_focus_request_t>())).revert_to as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_input_focus_request_t),
            "::",
            stringify!(revert_to)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_set_input_focus_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_input_focus_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_set_input_focus_request_t>())).focus as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_input_focus_request_t),
            "::",
            stringify!(focus)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_set_input_focus_request_t>())).time as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_input_focus_request_t),
            "::",
            stringify!(time)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_input_focus_cookie_t {
    pub sequence: cty::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_input_focus_cookie_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_get_input_focus_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_input_focus_cookie_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_get_input_focus_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_input_focus_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_input_focus_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_input_focus_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_input_focus_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_get_input_focus_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_get_input_focus_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_input_focus_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_get_input_focus_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_get_input_focus_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_input_focus_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_input_focus_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_input_focus_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_input_focus_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_input_focus_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_input_focus_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_input_focus_reply_t {
    pub response_type: u8,
    pub revert_to: u8,
    pub sequence: u16,
    pub length: u32,
    pub focus: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_get_input_focus_reply_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_get_input_focus_reply_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_get_input_focus_reply_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_get_input_focus_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_input_focus_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_input_focus_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_input_focus_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_input_focus_reply_t>())).revert_to as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_input_focus_reply_t),
            "::",
            stringify!(revert_to)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_input_focus_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_input_focus_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_input_focus_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_input_focus_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_input_focus_reply_t>())).focus as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_input_focus_reply_t),
            "::",
            stringify!(focus)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_keymap_cookie_t {
    pub sequence: cty::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_query_keymap_cookie_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_query_keymap_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_query_keymap_cookie_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_query_keymap_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_keymap_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_keymap_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_keymap_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_keymap_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_query_keymap_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_query_keymap_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_query_keymap_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_query_keymap_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_query_keymap_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_keymap_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_keymap_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_keymap_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_keymap_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_keymap_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_keymap_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_keymap_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub keys: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_xcb_query_keymap_reply_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_query_keymap_reply_t>(),
        40usize,
        concat!("Size of: ", stringify!(xcb_query_keymap_reply_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_query_keymap_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_keymap_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_keymap_reply_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_keymap_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_query_keymap_reply_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_keymap_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_keymap_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_keymap_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_keymap_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_keymap_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_query_keymap_reply_t>())).keys as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_keymap_reply_t),
            "::",
            stringify!(keys)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_open_font_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub fid: xcb_font_t,
    pub name_len: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_open_font_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_open_font_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_open_font_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_open_font_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_open_font_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_open_font_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_open_font_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_open_font_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_open_font_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_open_font_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_open_font_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_open_font_request_t>())).fid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_open_font_request_t),
            "::",
            stringify!(fid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_open_font_request_t>())).name_len as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_open_font_request_t),
            "::",
            stringify!(name_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_open_font_request_t>())).pad1 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_open_font_request_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_close_font_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub font: xcb_font_t,
}
#[test]
fn bindgen_test_layout_xcb_close_font_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_close_font_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_close_font_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_close_font_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_close_font_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_close_font_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_close_font_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_close_font_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_close_font_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_close_font_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_close_font_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_close_font_request_t>())).font as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_close_font_request_t),
            "::",
            stringify!(font)
        )
    );
}
pub const xcb_font_draw_t_XCB_FONT_DRAW_LEFT_TO_RIGHT: xcb_font_draw_t = 0;
pub const xcb_font_draw_t_XCB_FONT_DRAW_RIGHT_TO_LEFT: xcb_font_draw_t = 1;
pub type xcb_font_draw_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_fontprop_t {
    pub name: xcb_atom_t,
    pub value: u32,
}
#[test]
fn bindgen_test_layout_xcb_fontprop_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_fontprop_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_fontprop_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_fontprop_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_fontprop_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_fontprop_t>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fontprop_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_fontprop_t>())).value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fontprop_t),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_fontprop_iterator_t {
    pub data: *mut xcb_fontprop_t,
    pub rem: cty::c_int,
    pub index: cty::c_int,
}
#[test]
fn bindgen_test_layout_xcb_fontprop_iterator_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_fontprop_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_fontprop_iterator_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_fontprop_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_fontprop_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_fontprop_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fontprop_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_fontprop_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fontprop_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_fontprop_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fontprop_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_charinfo_t {
    pub left_side_bearing: i16,
    pub right_side_bearing: i16,
    pub character_width: i16,
    pub ascent: i16,
    pub descent: i16,
    pub attributes: u16,
}
#[test]
fn bindgen_test_layout_xcb_charinfo_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_charinfo_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_charinfo_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_charinfo_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_charinfo_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_charinfo_t>())).left_side_bearing as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_charinfo_t),
            "::",
            stringify!(left_side_bearing)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_charinfo_t>())).right_side_bearing as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_charinfo_t),
            "::",
            stringify!(right_side_bearing)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_charinfo_t>())).character_width as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_charinfo_t),
            "::",
            stringify!(character_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_charinfo_t>())).ascent as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_charinfo_t),
            "::",
            stringify!(ascent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_charinfo_t>())).descent as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_charinfo_t),
            "::",
            stringify!(descent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_charinfo_t>())).attributes as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_charinfo_t),
            "::",
            stringify!(attributes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_charinfo_iterator_t {
    pub data: *mut xcb_charinfo_t,
    pub rem: cty::c_int,
    pub index: cty::c_int,
}
#[test]
fn bindgen_test_layout_xcb_charinfo_iterator_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_charinfo_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_charinfo_iterator_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_charinfo_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_charinfo_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_charinfo_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_charinfo_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_charinfo_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_charinfo_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_charinfo_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_charinfo_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_font_cookie_t {
    pub sequence: cty::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_query_font_cookie_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_query_font_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_query_font_cookie_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_query_font_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_font_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_font_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_font_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub font: xcb_fontable_t,
}
#[test]
fn bindgen_test_layout_xcb_query_font_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_query_font_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_query_font_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_query_font_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_font_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_font_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_query_font_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_font_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_query_font_request_t>())).font as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_request_t),
            "::",
            stringify!(font)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_font_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub min_bounds: xcb_charinfo_t,
    pub pad1: [u8; 4usize],
    pub max_bounds: xcb_charinfo_t,
    pub pad2: [u8; 4usize],
    pub min_char_or_byte2: u16,
    pub max_char_or_byte2: u16,
    pub default_char: u16,
    pub properties_len: u16,
    pub draw_direction: u8,
    pub min_byte1: u8,
    pub max_byte1: u8,
    pub all_chars_exist: u8,
    pub font_ascent: i16,
    pub font_descent: i16,
    pub char_infos_len: u32,
}
#[test]
fn bindgen_test_layout_xcb_query_font_reply_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_query_font_reply_t>(),
        60usize,
        concat!("Size of: ", stringify!(xcb_query_font_reply_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_query_font_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_font_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_font_reply_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_query_font_reply_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_font_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_query_font_reply_t>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_font_reply_t>())).min_bounds as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(min_bounds)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_query_font_reply_t>())).pad1 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(pad1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_font_reply_t>())).max_bounds as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(max_bounds)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_query_font_reply_t>())).pad2 as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(pad2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_font_reply_t>())).min_char_or_byte2 as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(min_char_or_byte2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_font_reply_t>())).max_char_or_byte2 as *const _
                as usize
        },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(max_char_or_byte2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_font_reply_t>())).default_char as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(default_char)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_font_reply_t>())).properties_len as *const _ as usize
        },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(properties_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_font_reply_t>())).draw_direction as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(draw_direction)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_font_reply_t>())).min_byte1 as *const _ as usize
        },
        49usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(min_byte1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_font_reply_t>())).max_byte1 as *const _ as usize
        },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(max_byte1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_font_reply_t>())).all_chars_exist as *const _ as usize
        },
        51usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(all_chars_exist)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_font_reply_t>())).font_ascent as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(font_ascent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_font_reply_t>())).font_descent as *const _ as usize
        },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(font_descent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_font_reply_t>())).char_infos_len as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_font_reply_t),
            "::",
            stringify!(char_infos_len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_text_extents_cookie_t {
    pub sequence: cty::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_query_text_extents_cookie_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_query_text_extents_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_query_text_extents_cookie_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_query_text_extents_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_text_extents_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_text_extents_cookie_t>())).sequence as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_text_extents_request_t {
    pub major_opcode: u8,
    pub odd_length: u8,
    pub length: u16,
    pub font: xcb_fontable_t,
}
#[test]
fn bindgen_test_layout_xcb_query_text_extents_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_query_text_extents_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_query_text_extents_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_query_text_extents_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_query_text_extents_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_text_extents_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_text_extents_request_t>())).odd_length as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_request_t),
            "::",
            stringify!(odd_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_text_extents_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_text_extents_request_t>())).font as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_request_t),
            "::",
            stringify!(font)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_text_extents_reply_t {
    pub response_type: u8,
    pub draw_direction: u8,
    pub sequence: u16,
    pub length: u32,
    pub font_ascent: i16,
    pub font_descent: i16,
    pub overall_ascent: i16,
    pub overall_descent: i16,
    pub overall_width: i32,
    pub overall_left: i32,
    pub overall_right: i32,
}
#[test]
fn bindgen_test_layout_xcb_query_text_extents_reply_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_query_text_extents_reply_t>(),
        28usize,
        concat!("Size of: ", stringify!(xcb_query_text_extents_reply_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_query_text_extents_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_text_extents_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_text_extents_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_text_extents_reply_t>())).draw_direction as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_reply_t),
            "::",
            stringify!(draw_direction)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_text_extents_reply_t>())).sequence as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_text_extents_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_text_extents_reply_t>())).font_ascent as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_reply_t),
            "::",
            stringify!(font_ascent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_text_extents_reply_t>())).font_descent as *const _
                as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_reply_t),
            "::",
            stringify!(font_descent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_text_extents_reply_t>())).overall_ascent as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_reply_t),
            "::",
            stringify!(overall_ascent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_text_extents_reply_t>())).overall_descent as *const _
                as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_reply_t),
            "::",
            stringify!(overall_descent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_text_extents_reply_t>())).overall_width as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_reply_t),
            "::",
            stringify!(overall_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_text_extents_reply_t>())).overall_left as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_reply_t),
            "::",
            stringify!(overall_left)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_text_extents_reply_t>())).overall_right as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_text_extents_reply_t),
            "::",
            stringify!(overall_right)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_str_t {
    pub name_len: u8,
}
#[test]
fn bindgen_test_layout_xcb_str_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_str_t>(),
        1usize,
        concat!("Size of: ", stringify!(xcb_str_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_str_t>(),
        1usize,
        concat!("Alignment of ", stringify!(xcb_str_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_str_t>())).name_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_str_t),
            "::",
            stringify!(name_len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_str_iterator_t {
    pub data: *mut xcb_str_t,
    pub rem: cty::c_int,
    pub index: cty::c_int,
}
#[test]
fn bindgen_test_layout_xcb_str_iterator_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_str_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_str_iterator_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_str_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_str_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_str_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_str_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_str_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_str_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_str_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_str_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_fonts_cookie_t {
    pub sequence: cty::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_list_fonts_cookie_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_list_fonts_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_list_fonts_cookie_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_list_fonts_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_list_fonts_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_fonts_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_fonts_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub max_names: u16,
    pub pattern_len: u16,
}
#[test]
fn bindgen_test_layout_xcb_list_fonts_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_list_fonts_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_list_fonts_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_list_fonts_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_list_fonts_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_fonts_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_list_fonts_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_fonts_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_fonts_request_t>())).max_names as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_request_t),
            "::",
            stringify!(max_names)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_fonts_request_t>())).pattern_len as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_request_t),
            "::",
            stringify!(pattern_len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_fonts_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub names_len: u16,
    pub pad1: [u8; 22usize],
}
#[test]
fn bindgen_test_layout_xcb_list_fonts_reply_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_list_fonts_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_list_fonts_reply_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_list_fonts_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_list_fonts_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_fonts_reply_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_list_fonts_reply_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_fonts_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_list_fonts_reply_t>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_fonts_reply_t>())).names_len as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_reply_t),
            "::",
            stringify!(names_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_list_fonts_reply_t>())).pad1 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_reply_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_fonts_with_info_cookie_t {
    pub sequence: cty::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_list_fonts_with_info_cookie_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_list_fonts_with_info_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_list_fonts_with_info_cookie_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_list_fonts_with_info_cookie_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_list_fonts_with_info_cookie_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_fonts_with_info_cookie_t>())).sequence as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_fonts_with_info_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub max_names: u16,
    pub pattern_len: u16,
}
#[test]
fn bindgen_test_layout_xcb_list_fonts_with_info_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_list_fonts_with_info_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_list_fonts_with_info_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_list_fonts_with_info_request_t>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_list_fonts_with_info_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_fonts_with_info_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_fonts_with_info_request_t>())).pad0 as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_fonts_with_info_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_fonts_with_info_request_t>())).max_names as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_request_t),
            "::",
            stringify!(max_names)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_fonts_with_info_request_t>())).pattern_len as *const _
                as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_request_t),
            "::",
            stringify!(pattern_len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_fonts_with_info_reply_t {
    pub response_type: u8,
    pub name_len: u8,
    pub sequence: u16,
    pub length: u32,
    pub min_bounds: xcb_charinfo_t,
    pub pad0: [u8; 4usize],
    pub max_bounds: xcb_charinfo_t,
    pub pad1: [u8; 4usize],
    pub min_char_or_byte2: u16,
    pub max_char_or_byte2: u16,
    pub default_char: u16,
    pub properties_len: u16,
    pub draw_direction: u8,
    pub min_byte1: u8,
    pub max_byte1: u8,
    pub all_chars_exist: u8,
    pub font_ascent: i16,
    pub font_descent: i16,
    pub replies_hint: u32,
}
#[test]
fn bindgen_test_layout_xcb_list_fonts_with_info_reply_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_list_fonts_with_info_reply_t>(),
        60usize,
        concat!("Size of: ", stringify!(xcb_list_fonts_with_info_reply_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_list_fonts_with_info_reply_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_list_fonts_with_info_reply_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_fonts_with_info_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_fonts_with_info_reply_t>())).name_len as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(name_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_fonts_with_info_reply_t>())).sequence as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_fonts_with_info_reply_t>())).length as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_fonts_with_info_reply_t>())).min_bounds as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(min_bounds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_fonts_with_info_reply_t>())).pad0 as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_fonts_with_info_reply_t>())).max_bounds as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(max_bounds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_fonts_with_info_reply_t>())).pad1 as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(pad1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_fonts_with_info_reply_t>())).min_char_or_byte2
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(min_char_or_byte2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_fonts_with_info_reply_t>())).max_char_or_byte2
                as *const _ as usize
        },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(max_char_or_byte2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_fonts_with_info_reply_t>())).default_char as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(default_char)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_fonts_with_info_reply_t>())).properties_len as *const _
                as usize
        },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(properties_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_fonts_with_info_reply_t>())).draw_direction as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(draw_direction)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_fonts_with_info_reply_t>())).min_byte1 as *const _
                as usize
        },
        49usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(min_byte1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_fonts_with_info_reply_t>())).max_byte1 as *const _
                as usize
        },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(max_byte1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_fonts_with_info_reply_t>())).all_chars_exist
                as *const _ as usize
        },
        51usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(all_chars_exist)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_fonts_with_info_reply_t>())).font_ascent as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(font_ascent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_fonts_with_info_reply_t>())).font_descent as *const _
                as usize
        },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(font_descent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_fonts_with_info_reply_t>())).replies_hint as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_fonts_with_info_reply_t),
            "::",
            stringify!(replies_hint)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_set_font_path_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub font_qty: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_set_font_path_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_set_font_path_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_set_font_path_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_set_font_path_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_set_font_path_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_set_font_path_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_font_path_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_set_font_path_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_font_path_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_set_font_path_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_font_path_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_set_font_path_request_t>())).font_qty as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_font_path_request_t),
            "::",
            stringify!(font_qty)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_set_font_path_request_t>())).pad1 as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_font_path_request_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_font_path_cookie_t {
    pub sequence: cty::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_font_path_cookie_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_get_font_path_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_font_path_cookie_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_get_font_path_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_font_path_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_font_path_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_font_path_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_font_path_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_get_font_path_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_get_font_path_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_font_path_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_get_font_path_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_get_font_path_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_font_path_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_font_path_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_font_path_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_font_path_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_font_path_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_font_path_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_font_path_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub path_len: u16,
    pub pad1: [u8; 22usize],
}
#[test]
fn bindgen_test_layout_xcb_get_font_path_reply_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_get_font_path_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_get_font_path_reply_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_get_font_path_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_font_path_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_font_path_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_font_path_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_get_font_path_reply_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_font_path_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_font_path_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_font_path_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_font_path_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_font_path_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_font_path_reply_t>())).path_len as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_font_path_reply_t),
            "::",
            stringify!(path_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_get_font_path_reply_t>())).pad1 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_font_path_reply_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_create_pixmap_request_t {
    pub major_opcode: u8,
    pub depth: u8,
    pub length: u16,
    pub pid: xcb_pixmap_t,
    pub drawable: xcb_drawable_t,
    pub width: u16,
    pub height: u16,
}
#[test]
fn bindgen_test_layout_xcb_create_pixmap_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_create_pixmap_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_create_pixmap_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_create_pixmap_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_create_pixmap_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_pixmap_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_pixmap_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_pixmap_request_t>())).depth as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_pixmap_request_t),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_pixmap_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_pixmap_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_pixmap_request_t>())).pid as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_pixmap_request_t),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_pixmap_request_t>())).drawable as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_pixmap_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_pixmap_request_t>())).width as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_pixmap_request_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_pixmap_request_t>())).height as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_pixmap_request_t),
            "::",
            stringify!(height)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_free_pixmap_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub pixmap: xcb_pixmap_t,
}
#[test]
fn bindgen_test_layout_xcb_free_pixmap_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_free_pixmap_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_free_pixmap_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_free_pixmap_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_free_pixmap_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_free_pixmap_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_pixmap_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_free_pixmap_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_pixmap_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_free_pixmap_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_pixmap_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_free_pixmap_request_t>())).pixmap as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_pixmap_request_t),
            "::",
            stringify!(pixmap)
        )
    );
}
pub const xcb_gc_t_XCB_GC_FUNCTION: xcb_gc_t = 1;
pub const xcb_gc_t_XCB_GC_PLANE_MASK: xcb_gc_t = 2;
pub const xcb_gc_t_XCB_GC_FOREGROUND: xcb_gc_t = 4;
pub const xcb_gc_t_XCB_GC_BACKGROUND: xcb_gc_t = 8;
pub const xcb_gc_t_XCB_GC_LINE_WIDTH: xcb_gc_t = 16;
pub const xcb_gc_t_XCB_GC_LINE_STYLE: xcb_gc_t = 32;
pub const xcb_gc_t_XCB_GC_CAP_STYLE: xcb_gc_t = 64;
pub const xcb_gc_t_XCB_GC_JOIN_STYLE: xcb_gc_t = 128;
pub const xcb_gc_t_XCB_GC_FILL_STYLE: xcb_gc_t = 256;
pub const xcb_gc_t_XCB_GC_FILL_RULE: xcb_gc_t = 512;
pub const xcb_gc_t_XCB_GC_TILE: xcb_gc_t = 1024;
pub const xcb_gc_t_XCB_GC_STIPPLE: xcb_gc_t = 2048;
pub const xcb_gc_t_XCB_GC_TILE_STIPPLE_ORIGIN_X: xcb_gc_t = 4096;
pub const xcb_gc_t_XCB_GC_TILE_STIPPLE_ORIGIN_Y: xcb_gc_t = 8192;
pub const xcb_gc_t_XCB_GC_FONT: xcb_gc_t = 16384;
pub const xcb_gc_t_XCB_GC_SUBWINDOW_MODE: xcb_gc_t = 32768;
pub const xcb_gc_t_XCB_GC_GRAPHICS_EXPOSURES: xcb_gc_t = 65536;
pub const xcb_gc_t_XCB_GC_CLIP_ORIGIN_X: xcb_gc_t = 131072;
pub const xcb_gc_t_XCB_GC_CLIP_ORIGIN_Y: xcb_gc_t = 262144;
pub const xcb_gc_t_XCB_GC_CLIP_MASK: xcb_gc_t = 524288;
pub const xcb_gc_t_XCB_GC_DASH_OFFSET: xcb_gc_t = 1048576;
pub const xcb_gc_t_XCB_GC_DASH_LIST: xcb_gc_t = 2097152;
pub const xcb_gc_t_XCB_GC_ARC_MODE: xcb_gc_t = 4194304;
pub type xcb_gc_t = u32;
pub const xcb_gx_t_XCB_GX_CLEAR: xcb_gx_t = 0;
pub const xcb_gx_t_XCB_GX_AND: xcb_gx_t = 1;
pub const xcb_gx_t_XCB_GX_AND_REVERSE: xcb_gx_t = 2;
pub const xcb_gx_t_XCB_GX_COPY: xcb_gx_t = 3;
pub const xcb_gx_t_XCB_GX_AND_INVERTED: xcb_gx_t = 4;
pub const xcb_gx_t_XCB_GX_NOOP: xcb_gx_t = 5;
pub const xcb_gx_t_XCB_GX_XOR: xcb_gx_t = 6;
pub const xcb_gx_t_XCB_GX_OR: xcb_gx_t = 7;
pub const xcb_gx_t_XCB_GX_NOR: xcb_gx_t = 8;
pub const xcb_gx_t_XCB_GX_EQUIV: xcb_gx_t = 9;
pub const xcb_gx_t_XCB_GX_INVERT: xcb_gx_t = 10;
pub const xcb_gx_t_XCB_GX_OR_REVERSE: xcb_gx_t = 11;
pub const xcb_gx_t_XCB_GX_COPY_INVERTED: xcb_gx_t = 12;
pub const xcb_gx_t_XCB_GX_OR_INVERTED: xcb_gx_t = 13;
pub const xcb_gx_t_XCB_GX_NAND: xcb_gx_t = 14;
pub const xcb_gx_t_XCB_GX_SET: xcb_gx_t = 15;
pub type xcb_gx_t = u32;
pub const xcb_line_style_t_XCB_LINE_STYLE_SOLID: xcb_line_style_t = 0;
pub const xcb_line_style_t_XCB_LINE_STYLE_ON_OFF_DASH: xcb_line_style_t = 1;
pub const xcb_line_style_t_XCB_LINE_STYLE_DOUBLE_DASH: xcb_line_style_t = 2;
pub type xcb_line_style_t = u32;
pub const xcb_cap_style_t_XCB_CAP_STYLE_NOT_LAST: xcb_cap_style_t = 0;
pub const xcb_cap_style_t_XCB_CAP_STYLE_BUTT: xcb_cap_style_t = 1;
pub const xcb_cap_style_t_XCB_CAP_STYLE_ROUND: xcb_cap_style_t = 2;
pub const xcb_cap_style_t_XCB_CAP_STYLE_PROJECTING: xcb_cap_style_t = 3;
pub type xcb_cap_style_t = u32;
pub const xcb_join_style_t_XCB_JOIN_STYLE_MITER: xcb_join_style_t = 0;
pub const xcb_join_style_t_XCB_JOIN_STYLE_ROUND: xcb_join_style_t = 1;
pub const xcb_join_style_t_XCB_JOIN_STYLE_BEVEL: xcb_join_style_t = 2;
pub type xcb_join_style_t = u32;
pub const xcb_fill_style_t_XCB_FILL_STYLE_SOLID: xcb_fill_style_t = 0;
pub const xcb_fill_style_t_XCB_FILL_STYLE_TILED: xcb_fill_style_t = 1;
pub const xcb_fill_style_t_XCB_FILL_STYLE_STIPPLED: xcb_fill_style_t = 2;
pub const xcb_fill_style_t_XCB_FILL_STYLE_OPAQUE_STIPPLED: xcb_fill_style_t = 3;
pub type xcb_fill_style_t = u32;
pub const xcb_fill_rule_t_XCB_FILL_RULE_EVEN_ODD: xcb_fill_rule_t = 0;
pub const xcb_fill_rule_t_XCB_FILL_RULE_WINDING: xcb_fill_rule_t = 1;
pub type xcb_fill_rule_t = u32;
pub const xcb_subwindow_mode_t_XCB_SUBWINDOW_MODE_CLIP_BY_CHILDREN: xcb_subwindow_mode_t = 0;
pub const xcb_subwindow_mode_t_XCB_SUBWINDOW_MODE_INCLUDE_INFERIORS: xcb_subwindow_mode_t = 1;
pub type xcb_subwindow_mode_t = u32;
pub const xcb_arc_mode_t_XCB_ARC_MODE_CHORD: xcb_arc_mode_t = 0;
pub const xcb_arc_mode_t_XCB_ARC_MODE_PIE_SLICE: xcb_arc_mode_t = 1;
pub type xcb_arc_mode_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_create_gc_value_list_t {
    pub function: u32,
    pub plane_mask: u32,
    pub foreground: u32,
    pub background: u32,
    pub line_width: u32,
    pub line_style: u32,
    pub cap_style: u32,
    pub join_style: u32,
    pub fill_style: u32,
    pub fill_rule: u32,
    pub tile: xcb_pixmap_t,
    pub stipple: xcb_pixmap_t,
    pub tile_stipple_x_origin: i32,
    pub tile_stipple_y_origin: i32,
    pub font: xcb_font_t,
    pub subwindow_mode: u32,
    pub graphics_exposures: xcb_bool32_t,
    pub clip_x_origin: i32,
    pub clip_y_origin: i32,
    pub clip_mask: xcb_pixmap_t,
    pub dash_offset: u32,
    pub dashes: u32,
    pub arc_mode: u32,
}
#[test]
fn bindgen_test_layout_xcb_create_gc_value_list_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_create_gc_value_list_t>(),
        92usize,
        concat!("Size of: ", stringify!(xcb_create_gc_value_list_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_create_gc_value_list_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_create_gc_value_list_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_gc_value_list_t>())).function as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_gc_value_list_t>())).plane_mask as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(plane_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_gc_value_list_t>())).foreground as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(foreground)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_gc_value_list_t>())).background as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(background)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_gc_value_list_t>())).line_width as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(line_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_gc_value_list_t>())).line_style as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(line_style)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_gc_value_list_t>())).cap_style as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(cap_style)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_gc_value_list_t>())).join_style as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(join_style)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_gc_value_list_t>())).fill_style as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(fill_style)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_gc_value_list_t>())).fill_rule as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(fill_rule)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_gc_value_list_t>())).tile as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(tile)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_gc_value_list_t>())).stipple as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(stipple)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_gc_value_list_t>())).tile_stipple_x_origin
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(tile_stipple_x_origin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_gc_value_list_t>())).tile_stipple_y_origin
                as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(tile_stipple_y_origin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_gc_value_list_t>())).font as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(font)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_gc_value_list_t>())).subwindow_mode as *const _
                as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(subwindow_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_gc_value_list_t>())).graphics_exposures as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(graphics_exposures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_gc_value_list_t>())).clip_x_origin as *const _
                as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(clip_x_origin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_gc_value_list_t>())).clip_y_origin as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(clip_y_origin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_gc_value_list_t>())).clip_mask as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(clip_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_gc_value_list_t>())).dash_offset as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(dash_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_gc_value_list_t>())).dashes as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(dashes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_gc_value_list_t>())).arc_mode as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_value_list_t),
            "::",
            stringify!(arc_mode)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_create_gc_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cid: xcb_gcontext_t,
    pub drawable: xcb_drawable_t,
    pub value_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_create_gc_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_create_gc_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_create_gc_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_create_gc_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_create_gc_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_gc_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_create_gc_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_create_gc_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_create_gc_request_t>())).cid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_request_t),
            "::",
            stringify!(cid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_gc_request_t>())).drawable as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_gc_request_t>())).value_mask as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_gc_request_t),
            "::",
            stringify!(value_mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_change_gc_value_list_t {
    pub function: u32,
    pub plane_mask: u32,
    pub foreground: u32,
    pub background: u32,
    pub line_width: u32,
    pub line_style: u32,
    pub cap_style: u32,
    pub join_style: u32,
    pub fill_style: u32,
    pub fill_rule: u32,
    pub tile: xcb_pixmap_t,
    pub stipple: xcb_pixmap_t,
    pub tile_stipple_x_origin: i32,
    pub tile_stipple_y_origin: i32,
    pub font: xcb_font_t,
    pub subwindow_mode: u32,
    pub graphics_exposures: xcb_bool32_t,
    pub clip_x_origin: i32,
    pub clip_y_origin: i32,
    pub clip_mask: xcb_pixmap_t,
    pub dash_offset: u32,
    pub dashes: u32,
    pub arc_mode: u32,
}
#[test]
fn bindgen_test_layout_xcb_change_gc_value_list_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_change_gc_value_list_t>(),
        92usize,
        concat!("Size of: ", stringify!(xcb_change_gc_value_list_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_change_gc_value_list_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_change_gc_value_list_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_gc_value_list_t>())).function as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_gc_value_list_t>())).plane_mask as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(plane_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_gc_value_list_t>())).foreground as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(foreground)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_gc_value_list_t>())).background as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(background)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_gc_value_list_t>())).line_width as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(line_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_gc_value_list_t>())).line_style as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(line_style)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_gc_value_list_t>())).cap_style as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(cap_style)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_gc_value_list_t>())).join_style as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(join_style)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_gc_value_list_t>())).fill_style as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(fill_style)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_gc_value_list_t>())).fill_rule as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(fill_rule)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_gc_value_list_t>())).tile as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(tile)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_gc_value_list_t>())).stipple as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(stipple)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_gc_value_list_t>())).tile_stipple_x_origin
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(tile_stipple_x_origin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_gc_value_list_t>())).tile_stipple_y_origin
                as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(tile_stipple_y_origin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_gc_value_list_t>())).font as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(font)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_gc_value_list_t>())).subwindow_mode as *const _
                as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(subwindow_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_gc_value_list_t>())).graphics_exposures as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(graphics_exposures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_gc_value_list_t>())).clip_x_origin as *const _
                as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(clip_x_origin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_gc_value_list_t>())).clip_y_origin as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(clip_y_origin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_gc_value_list_t>())).clip_mask as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(clip_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_gc_value_list_t>())).dash_offset as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(dash_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_gc_value_list_t>())).dashes as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(dashes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_gc_value_list_t>())).arc_mode as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_value_list_t),
            "::",
            stringify!(arc_mode)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_change_gc_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub gc: xcb_gcontext_t,
    pub value_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_change_gc_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_change_gc_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_change_gc_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_change_gc_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_change_gc_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_gc_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_change_gc_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_change_gc_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_change_gc_request_t>())).gc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_request_t),
            "::",
            stringify!(gc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_gc_request_t>())).value_mask as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_gc_request_t),
            "::",
            stringify!(value_mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_copy_gc_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub src_gc: xcb_gcontext_t,
    pub dst_gc: xcb_gcontext_t,
    pub value_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_copy_gc_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_copy_gc_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_copy_gc_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_copy_gc_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_copy_gc_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_copy_gc_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_gc_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_copy_gc_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_gc_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_copy_gc_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_gc_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_copy_gc_request_t>())).src_gc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_gc_request_t),
            "::",
            stringify!(src_gc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_copy_gc_request_t>())).dst_gc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_gc_request_t),
            "::",
            stringify!(dst_gc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_copy_gc_request_t>())).value_mask as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_gc_request_t),
            "::",
            stringify!(value_mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_set_dashes_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub gc: xcb_gcontext_t,
    pub dash_offset: u16,
    pub dashes_len: u16,
}
#[test]
fn bindgen_test_layout_xcb_set_dashes_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_set_dashes_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_set_dashes_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_set_dashes_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_set_dashes_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_set_dashes_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_dashes_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_set_dashes_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_dashes_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_set_dashes_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_dashes_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_set_dashes_request_t>())).gc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_dashes_request_t),
            "::",
            stringify!(gc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_set_dashes_request_t>())).dash_offset as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_dashes_request_t),
            "::",
            stringify!(dash_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_set_dashes_request_t>())).dashes_len as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_dashes_request_t),
            "::",
            stringify!(dashes_len)
        )
    );
}
pub const xcb_clip_ordering_t_XCB_CLIP_ORDERING_UNSORTED: xcb_clip_ordering_t = 0;
pub const xcb_clip_ordering_t_XCB_CLIP_ORDERING_Y_SORTED: xcb_clip_ordering_t = 1;
pub const xcb_clip_ordering_t_XCB_CLIP_ORDERING_YX_SORTED: xcb_clip_ordering_t = 2;
pub const xcb_clip_ordering_t_XCB_CLIP_ORDERING_YX_BANDED: xcb_clip_ordering_t = 3;
pub type xcb_clip_ordering_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_set_clip_rectangles_request_t {
    pub major_opcode: u8,
    pub ordering: u8,
    pub length: u16,
    pub gc: xcb_gcontext_t,
    pub clip_x_origin: i16,
    pub clip_y_origin: i16,
}
#[test]
fn bindgen_test_layout_xcb_set_clip_rectangles_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_set_clip_rectangles_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_set_clip_rectangles_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_set_clip_rectangles_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_set_clip_rectangles_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_set_clip_rectangles_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_clip_rectangles_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_set_clip_rectangles_request_t>())).ordering as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_clip_rectangles_request_t),
            "::",
            stringify!(ordering)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_set_clip_rectangles_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_clip_rectangles_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_set_clip_rectangles_request_t>())).gc as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_clip_rectangles_request_t),
            "::",
            stringify!(gc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_set_clip_rectangles_request_t>())).clip_x_origin as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_clip_rectangles_request_t),
            "::",
            stringify!(clip_x_origin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_set_clip_rectangles_request_t>())).clip_y_origin as *const _
                as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_clip_rectangles_request_t),
            "::",
            stringify!(clip_y_origin)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_free_gc_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub gc: xcb_gcontext_t,
}
#[test]
fn bindgen_test_layout_xcb_free_gc_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_free_gc_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_free_gc_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_free_gc_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_free_gc_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_free_gc_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_gc_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_free_gc_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_gc_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_free_gc_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_gc_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_free_gc_request_t>())).gc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_gc_request_t),
            "::",
            stringify!(gc)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_clear_area_request_t {
    pub major_opcode: u8,
    pub exposures: u8,
    pub length: u16,
    pub window: xcb_window_t,
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
}
#[test]
fn bindgen_test_layout_xcb_clear_area_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_clear_area_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_clear_area_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_clear_area_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_clear_area_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_clear_area_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_clear_area_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_clear_area_request_t>())).exposures as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_clear_area_request_t),
            "::",
            stringify!(exposures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_clear_area_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_clear_area_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_clear_area_request_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_clear_area_request_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_clear_area_request_t>())).x as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_clear_area_request_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_clear_area_request_t>())).y as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_clear_area_request_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_clear_area_request_t>())).width as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_clear_area_request_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_clear_area_request_t>())).height as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_clear_area_request_t),
            "::",
            stringify!(height)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_copy_area_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub src_drawable: xcb_drawable_t,
    pub dst_drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
    pub src_x: i16,
    pub src_y: i16,
    pub dst_x: i16,
    pub dst_y: i16,
    pub width: u16,
    pub height: u16,
}
#[test]
fn bindgen_test_layout_xcb_copy_area_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_copy_area_request_t>(),
        28usize,
        concat!("Size of: ", stringify!(xcb_copy_area_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_copy_area_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_copy_area_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_copy_area_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_area_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_copy_area_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_area_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_copy_area_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_area_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_copy_area_request_t>())).src_drawable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_area_request_t),
            "::",
            stringify!(src_drawable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_copy_area_request_t>())).dst_drawable as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_area_request_t),
            "::",
            stringify!(dst_drawable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_copy_area_request_t>())).gc as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_area_request_t),
            "::",
            stringify!(gc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_copy_area_request_t>())).src_x as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_area_request_t),
            "::",
            stringify!(src_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_copy_area_request_t>())).src_y as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_area_request_t),
            "::",
            stringify!(src_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_copy_area_request_t>())).dst_x as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_area_request_t),
            "::",
            stringify!(dst_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_copy_area_request_t>())).dst_y as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_area_request_t),
            "::",
            stringify!(dst_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_copy_area_request_t>())).width as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_area_request_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_copy_area_request_t>())).height as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_area_request_t),
            "::",
            stringify!(height)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_copy_plane_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub src_drawable: xcb_drawable_t,
    pub dst_drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
    pub src_x: i16,
    pub src_y: i16,
    pub dst_x: i16,
    pub dst_y: i16,
    pub width: u16,
    pub height: u16,
    pub bit_plane: u32,
}
#[test]
fn bindgen_test_layout_xcb_copy_plane_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_copy_plane_request_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_copy_plane_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_copy_plane_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_copy_plane_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_copy_plane_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_plane_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_copy_plane_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_plane_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_copy_plane_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_plane_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_copy_plane_request_t>())).src_drawable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_plane_request_t),
            "::",
            stringify!(src_drawable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_copy_plane_request_t>())).dst_drawable as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_plane_request_t),
            "::",
            stringify!(dst_drawable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_copy_plane_request_t>())).gc as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_plane_request_t),
            "::",
            stringify!(gc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_copy_plane_request_t>())).src_x as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_plane_request_t),
            "::",
            stringify!(src_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_copy_plane_request_t>())).src_y as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_plane_request_t),
            "::",
            stringify!(src_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_copy_plane_request_t>())).dst_x as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_plane_request_t),
            "::",
            stringify!(dst_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_copy_plane_request_t>())).dst_y as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_plane_request_t),
            "::",
            stringify!(dst_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_copy_plane_request_t>())).width as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_plane_request_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_copy_plane_request_t>())).height as *const _ as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_plane_request_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_copy_plane_request_t>())).bit_plane as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_plane_request_t),
            "::",
            stringify!(bit_plane)
        )
    );
}
pub const xcb_coord_mode_t_XCB_COORD_MODE_ORIGIN: xcb_coord_mode_t = 0;
pub const xcb_coord_mode_t_XCB_COORD_MODE_PREVIOUS: xcb_coord_mode_t = 1;
pub type xcb_coord_mode_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_poly_point_request_t {
    pub major_opcode: u8,
    pub coordinate_mode: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
}
#[test]
fn bindgen_test_layout_xcb_poly_point_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_poly_point_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_poly_point_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_poly_point_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_poly_point_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_poly_point_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_point_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_poly_point_request_t>())).coordinate_mode as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_point_request_t),
            "::",
            stringify!(coordinate_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_poly_point_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_point_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_poly_point_request_t>())).drawable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_point_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_poly_point_request_t>())).gc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_point_request_t),
            "::",
            stringify!(gc)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_poly_line_request_t {
    pub major_opcode: u8,
    pub coordinate_mode: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
}
#[test]
fn bindgen_test_layout_xcb_poly_line_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_poly_line_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_poly_line_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_poly_line_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_poly_line_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_poly_line_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_line_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_poly_line_request_t>())).coordinate_mode as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_line_request_t),
            "::",
            stringify!(coordinate_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_poly_line_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_line_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_poly_line_request_t>())).drawable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_line_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_poly_line_request_t>())).gc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_line_request_t),
            "::",
            stringify!(gc)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_segment_t {
    pub x1: i16,
    pub y1: i16,
    pub x2: i16,
    pub y2: i16,
}
#[test]
fn bindgen_test_layout_xcb_segment_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_segment_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_segment_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_segment_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_segment_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_segment_t>())).x1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_segment_t),
            "::",
            stringify!(x1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_segment_t>())).y1 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_segment_t),
            "::",
            stringify!(y1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_segment_t>())).x2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_segment_t),
            "::",
            stringify!(x2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_segment_t>())).y2 as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_segment_t),
            "::",
            stringify!(y2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_segment_iterator_t {
    pub data: *mut xcb_segment_t,
    pub rem: cty::c_int,
    pub index: cty::c_int,
}
#[test]
fn bindgen_test_layout_xcb_segment_iterator_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_segment_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_segment_iterator_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_segment_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_segment_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_segment_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_segment_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_segment_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_segment_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_segment_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_segment_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_poly_segment_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
}
#[test]
fn bindgen_test_layout_xcb_poly_segment_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_poly_segment_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_poly_segment_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_poly_segment_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_poly_segment_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_poly_segment_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_segment_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_poly_segment_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_segment_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_poly_segment_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_segment_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_poly_segment_request_t>())).drawable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_segment_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_poly_segment_request_t>())).gc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_segment_request_t),
            "::",
            stringify!(gc)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_poly_rectangle_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
}
#[test]
fn bindgen_test_layout_xcb_poly_rectangle_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_poly_rectangle_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_poly_rectangle_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_poly_rectangle_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_poly_rectangle_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_poly_rectangle_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_rectangle_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_poly_rectangle_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_rectangle_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_poly_rectangle_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_rectangle_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_poly_rectangle_request_t>())).drawable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_rectangle_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_poly_rectangle_request_t>())).gc as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_rectangle_request_t),
            "::",
            stringify!(gc)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_poly_arc_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
}
#[test]
fn bindgen_test_layout_xcb_poly_arc_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_poly_arc_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_poly_arc_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_poly_arc_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_poly_arc_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_poly_arc_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_arc_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_poly_arc_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_arc_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_poly_arc_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_arc_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_poly_arc_request_t>())).drawable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_arc_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_poly_arc_request_t>())).gc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_arc_request_t),
            "::",
            stringify!(gc)
        )
    );
}
pub const xcb_poly_shape_t_XCB_POLY_SHAPE_COMPLEX: xcb_poly_shape_t = 0;
pub const xcb_poly_shape_t_XCB_POLY_SHAPE_NONCONVEX: xcb_poly_shape_t = 1;
pub const xcb_poly_shape_t_XCB_POLY_SHAPE_CONVEX: xcb_poly_shape_t = 2;
pub type xcb_poly_shape_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_fill_poly_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
    pub shape: u8,
    pub coordinate_mode: u8,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_fill_poly_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_fill_poly_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_fill_poly_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_fill_poly_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_fill_poly_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_fill_poly_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fill_poly_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_fill_poly_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fill_poly_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_fill_poly_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fill_poly_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_fill_poly_request_t>())).drawable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fill_poly_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_fill_poly_request_t>())).gc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fill_poly_request_t),
            "::",
            stringify!(gc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_fill_poly_request_t>())).shape as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fill_poly_request_t),
            "::",
            stringify!(shape)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_fill_poly_request_t>())).coordinate_mode as *const _
                as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fill_poly_request_t),
            "::",
            stringify!(coordinate_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_fill_poly_request_t>())).pad1 as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_fill_poly_request_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_poly_fill_rectangle_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
}
#[test]
fn bindgen_test_layout_xcb_poly_fill_rectangle_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_poly_fill_rectangle_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_poly_fill_rectangle_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_poly_fill_rectangle_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_poly_fill_rectangle_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_poly_fill_rectangle_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_fill_rectangle_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_poly_fill_rectangle_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_fill_rectangle_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_poly_fill_rectangle_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_fill_rectangle_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_poly_fill_rectangle_request_t>())).drawable as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_fill_rectangle_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_poly_fill_rectangle_request_t>())).gc as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_fill_rectangle_request_t),
            "::",
            stringify!(gc)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_poly_fill_arc_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
}
#[test]
fn bindgen_test_layout_xcb_poly_fill_arc_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_poly_fill_arc_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_poly_fill_arc_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_poly_fill_arc_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_poly_fill_arc_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_poly_fill_arc_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_fill_arc_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_poly_fill_arc_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_fill_arc_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_poly_fill_arc_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_fill_arc_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_poly_fill_arc_request_t>())).drawable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_fill_arc_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_poly_fill_arc_request_t>())).gc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_fill_arc_request_t),
            "::",
            stringify!(gc)
        )
    );
}
pub const xcb_image_format_t_XCB_IMAGE_FORMAT_XY_BITMAP: xcb_image_format_t = 0;
pub const xcb_image_format_t_XCB_IMAGE_FORMAT_XY_PIXMAP: xcb_image_format_t = 1;
pub const xcb_image_format_t_XCB_IMAGE_FORMAT_Z_PIXMAP: xcb_image_format_t = 2;
pub type xcb_image_format_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_put_image_request_t {
    pub major_opcode: u8,
    pub format: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
    pub width: u16,
    pub height: u16,
    pub dst_x: i16,
    pub dst_y: i16,
    pub left_pad: u8,
    pub depth: u8,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_put_image_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_put_image_request_t>(),
        24usize,
        concat!("Size of: ", stringify!(xcb_put_image_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_put_image_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_put_image_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_put_image_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_put_image_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_put_image_request_t>())).format as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_put_image_request_t),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_put_image_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_put_image_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_put_image_request_t>())).drawable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_put_image_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_put_image_request_t>())).gc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_put_image_request_t),
            "::",
            stringify!(gc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_put_image_request_t>())).width as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_put_image_request_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_put_image_request_t>())).height as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_put_image_request_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_put_image_request_t>())).dst_x as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_put_image_request_t),
            "::",
            stringify!(dst_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_put_image_request_t>())).dst_y as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_put_image_request_t),
            "::",
            stringify!(dst_y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_put_image_request_t>())).left_pad as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_put_image_request_t),
            "::",
            stringify!(left_pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_put_image_request_t>())).depth as *const _ as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_put_image_request_t),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_put_image_request_t>())).pad0 as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_put_image_request_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_image_cookie_t {
    pub sequence: cty::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_image_cookie_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_get_image_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_image_cookie_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_get_image_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_image_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_image_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_image_request_t {
    pub major_opcode: u8,
    pub format: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub x: i16,
    pub y: i16,
    pub width: u16,
    pub height: u16,
    pub plane_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_get_image_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_get_image_request_t>(),
        20usize,
        concat!("Size of: ", stringify!(xcb_get_image_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_get_image_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_image_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_image_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_get_image_request_t>())).format as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_request_t),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_get_image_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_image_request_t>())).drawable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_get_image_request_t>())).x as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_request_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_get_image_request_t>())).y as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_request_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_get_image_request_t>())).width as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_request_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_get_image_request_t>())).height as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_request_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_image_request_t>())).plane_mask as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_request_t),
            "::",
            stringify!(plane_mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_image_reply_t {
    pub response_type: u8,
    pub depth: u8,
    pub sequence: u16,
    pub length: u32,
    pub visual: xcb_visualid_t,
    pub pad0: [u8; 20usize],
}
#[test]
fn bindgen_test_layout_xcb_get_image_reply_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_get_image_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_get_image_reply_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_get_image_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_image_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_image_reply_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_get_image_reply_t>())).depth as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_reply_t),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_get_image_reply_t>())).sequence as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_get_image_reply_t>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_get_image_reply_t>())).visual as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_reply_t),
            "::",
            stringify!(visual)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_get_image_reply_t>())).pad0 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_image_reply_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_poly_text_8_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
    pub x: i16,
    pub y: i16,
}
#[test]
fn bindgen_test_layout_xcb_poly_text_8_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_poly_text_8_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_poly_text_8_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_poly_text_8_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_poly_text_8_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_poly_text_8_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_text_8_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_poly_text_8_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_text_8_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_poly_text_8_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_text_8_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_poly_text_8_request_t>())).drawable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_text_8_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_poly_text_8_request_t>())).gc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_text_8_request_t),
            "::",
            stringify!(gc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_poly_text_8_request_t>())).x as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_text_8_request_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_poly_text_8_request_t>())).y as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_text_8_request_t),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_poly_text_16_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
    pub x: i16,
    pub y: i16,
}
#[test]
fn bindgen_test_layout_xcb_poly_text_16_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_poly_text_16_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_poly_text_16_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_poly_text_16_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_poly_text_16_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_poly_text_16_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_text_16_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_poly_text_16_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_text_16_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_poly_text_16_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_text_16_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_poly_text_16_request_t>())).drawable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_text_16_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_poly_text_16_request_t>())).gc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_text_16_request_t),
            "::",
            stringify!(gc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_poly_text_16_request_t>())).x as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_text_16_request_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_poly_text_16_request_t>())).y as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_poly_text_16_request_t),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_image_text_8_request_t {
    pub major_opcode: u8,
    pub string_len: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
    pub x: i16,
    pub y: i16,
}
#[test]
fn bindgen_test_layout_xcb_image_text_8_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_image_text_8_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_image_text_8_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_image_text_8_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_image_text_8_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_image_text_8_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_image_text_8_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_image_text_8_request_t>())).string_len as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_image_text_8_request_t),
            "::",
            stringify!(string_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_image_text_8_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_image_text_8_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_image_text_8_request_t>())).drawable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_image_text_8_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_image_text_8_request_t>())).gc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_image_text_8_request_t),
            "::",
            stringify!(gc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_image_text_8_request_t>())).x as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_image_text_8_request_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_image_text_8_request_t>())).y as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_image_text_8_request_t),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_image_text_16_request_t {
    pub major_opcode: u8,
    pub string_len: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub gc: xcb_gcontext_t,
    pub x: i16,
    pub y: i16,
}
#[test]
fn bindgen_test_layout_xcb_image_text_16_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_image_text_16_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_image_text_16_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_image_text_16_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_image_text_16_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_image_text_16_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_image_text_16_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_image_text_16_request_t>())).string_len as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_image_text_16_request_t),
            "::",
            stringify!(string_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_image_text_16_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_image_text_16_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_image_text_16_request_t>())).drawable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_image_text_16_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_image_text_16_request_t>())).gc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_image_text_16_request_t),
            "::",
            stringify!(gc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_image_text_16_request_t>())).x as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_image_text_16_request_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_image_text_16_request_t>())).y as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_image_text_16_request_t),
            "::",
            stringify!(y)
        )
    );
}
pub const xcb_colormap_alloc_t_XCB_COLORMAP_ALLOC_NONE: xcb_colormap_alloc_t = 0;
pub const xcb_colormap_alloc_t_XCB_COLORMAP_ALLOC_ALL: xcb_colormap_alloc_t = 1;
pub type xcb_colormap_alloc_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_create_colormap_request_t {
    pub major_opcode: u8,
    pub alloc: u8,
    pub length: u16,
    pub mid: xcb_colormap_t,
    pub window: xcb_window_t,
    pub visual: xcb_visualid_t,
}
#[test]
fn bindgen_test_layout_xcb_create_colormap_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_create_colormap_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_create_colormap_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_create_colormap_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_create_colormap_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_colormap_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_colormap_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_colormap_request_t>())).alloc as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_colormap_request_t),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_colormap_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_colormap_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_colormap_request_t>())).mid as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_colormap_request_t),
            "::",
            stringify!(mid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_colormap_request_t>())).window as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_colormap_request_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_colormap_request_t>())).visual as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_colormap_request_t),
            "::",
            stringify!(visual)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_free_colormap_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
}
#[test]
fn bindgen_test_layout_xcb_free_colormap_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_free_colormap_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_free_colormap_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_free_colormap_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_free_colormap_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_free_colormap_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_colormap_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_free_colormap_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_colormap_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_free_colormap_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_colormap_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_free_colormap_request_t>())).cmap as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_colormap_request_t),
            "::",
            stringify!(cmap)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_copy_colormap_and_free_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub mid: xcb_colormap_t,
    pub src_cmap: xcb_colormap_t,
}
#[test]
fn bindgen_test_layout_xcb_copy_colormap_and_free_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_copy_colormap_and_free_request_t>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(xcb_copy_colormap_and_free_request_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_copy_colormap_and_free_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_copy_colormap_and_free_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_copy_colormap_and_free_request_t>())).major_opcode
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_colormap_and_free_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_copy_colormap_and_free_request_t>())).pad0 as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_colormap_and_free_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_copy_colormap_and_free_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_colormap_and_free_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_copy_colormap_and_free_request_t>())).mid as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_colormap_and_free_request_t),
            "::",
            stringify!(mid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_copy_colormap_and_free_request_t>())).src_cmap as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_copy_colormap_and_free_request_t),
            "::",
            stringify!(src_cmap)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_install_colormap_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
}
#[test]
fn bindgen_test_layout_xcb_install_colormap_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_install_colormap_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_install_colormap_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_install_colormap_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_install_colormap_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_install_colormap_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_install_colormap_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_install_colormap_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_install_colormap_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_install_colormap_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_install_colormap_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_install_colormap_request_t>())).cmap as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_install_colormap_request_t),
            "::",
            stringify!(cmap)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_uninstall_colormap_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
}
#[test]
fn bindgen_test_layout_xcb_uninstall_colormap_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_uninstall_colormap_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_uninstall_colormap_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_uninstall_colormap_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_uninstall_colormap_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_uninstall_colormap_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_uninstall_colormap_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_uninstall_colormap_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_uninstall_colormap_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_uninstall_colormap_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_uninstall_colormap_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_uninstall_colormap_request_t>())).cmap as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_uninstall_colormap_request_t),
            "::",
            stringify!(cmap)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_installed_colormaps_cookie_t {
    pub sequence: cty::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_list_installed_colormaps_cookie_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_list_installed_colormaps_cookie_t>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(xcb_list_installed_colormaps_cookie_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_list_installed_colormaps_cookie_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_list_installed_colormaps_cookie_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_installed_colormaps_cookie_t>())).sequence as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_installed_colormaps_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_installed_colormaps_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
}
#[test]
fn bindgen_test_layout_xcb_list_installed_colormaps_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_list_installed_colormaps_request_t>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(xcb_list_installed_colormaps_request_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_list_installed_colormaps_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_list_installed_colormaps_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_installed_colormaps_request_t>())).major_opcode
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_installed_colormaps_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_installed_colormaps_request_t>())).pad0 as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_installed_colormaps_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_installed_colormaps_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_installed_colormaps_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_installed_colormaps_request_t>())).window as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_installed_colormaps_request_t),
            "::",
            stringify!(window)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_installed_colormaps_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub cmaps_len: u16,
    pub pad1: [u8; 22usize],
}
#[test]
fn bindgen_test_layout_xcb_list_installed_colormaps_reply_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_list_installed_colormaps_reply_t>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(xcb_list_installed_colormaps_reply_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_list_installed_colormaps_reply_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_list_installed_colormaps_reply_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_installed_colormaps_reply_t>())).response_type
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_installed_colormaps_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_installed_colormaps_reply_t>())).pad0 as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_installed_colormaps_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_installed_colormaps_reply_t>())).sequence as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_installed_colormaps_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_installed_colormaps_reply_t>())).length as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_installed_colormaps_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_installed_colormaps_reply_t>())).cmaps_len as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_installed_colormaps_reply_t),
            "::",
            stringify!(cmaps_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_installed_colormaps_reply_t>())).pad1 as *const _
                as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_installed_colormaps_reply_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_alloc_color_cookie_t {
    pub sequence: cty::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_cookie_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_alloc_color_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_alloc_color_cookie_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_alloc_color_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_alloc_color_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_alloc_color_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_alloc_color_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
    pub red: u16,
    pub green: u16,
    pub blue: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_alloc_color_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_alloc_color_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_alloc_color_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_alloc_color_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_alloc_color_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_alloc_color_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_alloc_color_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_alloc_color_request_t>())).cmap as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_request_t),
            "::",
            stringify!(cmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_alloc_color_request_t>())).red as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_request_t),
            "::",
            stringify!(red)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_alloc_color_request_t>())).green as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_request_t),
            "::",
            stringify!(green)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_alloc_color_request_t>())).blue as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_request_t),
            "::",
            stringify!(blue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_alloc_color_request_t>())).pad1 as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_request_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_alloc_color_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub red: u16,
    pub green: u16,
    pub blue: u16,
    pub pad1: [u8; 2usize],
    pub pixel: u32,
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_reply_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_alloc_color_reply_t>(),
        20usize,
        concat!("Size of: ", stringify!(xcb_alloc_color_reply_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_alloc_color_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_alloc_color_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_alloc_color_reply_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_alloc_color_reply_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_alloc_color_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_alloc_color_reply_t>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_alloc_color_reply_t>())).red as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_reply_t),
            "::",
            stringify!(red)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_alloc_color_reply_t>())).green as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_reply_t),
            "::",
            stringify!(green)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_alloc_color_reply_t>())).blue as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_reply_t),
            "::",
            stringify!(blue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_alloc_color_reply_t>())).pad1 as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_reply_t),
            "::",
            stringify!(pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_alloc_color_reply_t>())).pixel as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_reply_t),
            "::",
            stringify!(pixel)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_alloc_named_color_cookie_t {
    pub sequence: cty::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_alloc_named_color_cookie_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_alloc_named_color_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_alloc_named_color_cookie_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_alloc_named_color_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_alloc_named_color_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_alloc_named_color_cookie_t>())).sequence as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_alloc_named_color_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
    pub name_len: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_alloc_named_color_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_alloc_named_color_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_alloc_named_color_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_alloc_named_color_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_alloc_named_color_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_alloc_named_color_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_alloc_named_color_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_alloc_named_color_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_alloc_named_color_request_t>())).cmap as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_request_t),
            "::",
            stringify!(cmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_alloc_named_color_request_t>())).name_len as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_request_t),
            "::",
            stringify!(name_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_alloc_named_color_request_t>())).pad1 as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_request_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_alloc_named_color_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub pixel: u32,
    pub exact_red: u16,
    pub exact_green: u16,
    pub exact_blue: u16,
    pub visual_red: u16,
    pub visual_green: u16,
    pub visual_blue: u16,
}
#[test]
fn bindgen_test_layout_xcb_alloc_named_color_reply_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_alloc_named_color_reply_t>(),
        24usize,
        concat!("Size of: ", stringify!(xcb_alloc_named_color_reply_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_alloc_named_color_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_alloc_named_color_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_alloc_named_color_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_alloc_named_color_reply_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_alloc_named_color_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_alloc_named_color_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_alloc_named_color_reply_t>())).pixel as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_reply_t),
            "::",
            stringify!(pixel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_alloc_named_color_reply_t>())).exact_red as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_reply_t),
            "::",
            stringify!(exact_red)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_alloc_named_color_reply_t>())).exact_green as *const _
                as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_reply_t),
            "::",
            stringify!(exact_green)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_alloc_named_color_reply_t>())).exact_blue as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_reply_t),
            "::",
            stringify!(exact_blue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_alloc_named_color_reply_t>())).visual_red as *const _
                as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_reply_t),
            "::",
            stringify!(visual_red)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_alloc_named_color_reply_t>())).visual_green as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_reply_t),
            "::",
            stringify!(visual_green)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_alloc_named_color_reply_t>())).visual_blue as *const _
                as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_named_color_reply_t),
            "::",
            stringify!(visual_blue)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_alloc_color_cells_cookie_t {
    pub sequence: cty::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_cells_cookie_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_alloc_color_cells_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_alloc_color_cells_cookie_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_alloc_color_cells_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_alloc_color_cells_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_alloc_color_cells_cookie_t>())).sequence as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cells_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_alloc_color_cells_request_t {
    pub major_opcode: u8,
    pub contiguous: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
    pub colors: u16,
    pub planes: u16,
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_cells_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_alloc_color_cells_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_alloc_color_cells_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_alloc_color_cells_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_alloc_color_cells_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_alloc_color_cells_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cells_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_alloc_color_cells_request_t>())).contiguous as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cells_request_t),
            "::",
            stringify!(contiguous)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_alloc_color_cells_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cells_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_alloc_color_cells_request_t>())).cmap as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cells_request_t),
            "::",
            stringify!(cmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_alloc_color_cells_request_t>())).colors as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cells_request_t),
            "::",
            stringify!(colors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_alloc_color_cells_request_t>())).planes as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cells_request_t),
            "::",
            stringify!(planes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_alloc_color_cells_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub pixels_len: u16,
    pub masks_len: u16,
    pub pad1: [u8; 20usize],
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_cells_reply_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_alloc_color_cells_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_alloc_color_cells_reply_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_alloc_color_cells_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_alloc_color_cells_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_alloc_color_cells_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cells_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_alloc_color_cells_reply_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cells_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_alloc_color_cells_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cells_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_alloc_color_cells_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cells_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_alloc_color_cells_reply_t>())).pixels_len as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cells_reply_t),
            "::",
            stringify!(pixels_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_alloc_color_cells_reply_t>())).masks_len as *const _
                as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cells_reply_t),
            "::",
            stringify!(masks_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_alloc_color_cells_reply_t>())).pad1 as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_cells_reply_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_alloc_color_planes_cookie_t {
    pub sequence: cty::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_planes_cookie_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_alloc_color_planes_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_alloc_color_planes_cookie_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_alloc_color_planes_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_alloc_color_planes_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_alloc_color_planes_cookie_t>())).sequence as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_alloc_color_planes_request_t {
    pub major_opcode: u8,
    pub contiguous: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
    pub colors: u16,
    pub reds: u16,
    pub greens: u16,
    pub blues: u16,
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_planes_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_alloc_color_planes_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_alloc_color_planes_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_alloc_color_planes_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_alloc_color_planes_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_alloc_color_planes_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_alloc_color_planes_request_t>())).contiguous as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_request_t),
            "::",
            stringify!(contiguous)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_alloc_color_planes_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_alloc_color_planes_request_t>())).cmap as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_request_t),
            "::",
            stringify!(cmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_alloc_color_planes_request_t>())).colors as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_request_t),
            "::",
            stringify!(colors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_alloc_color_planes_request_t>())).reds as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_request_t),
            "::",
            stringify!(reds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_alloc_color_planes_request_t>())).greens as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_request_t),
            "::",
            stringify!(greens)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_alloc_color_planes_request_t>())).blues as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_request_t),
            "::",
            stringify!(blues)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_alloc_color_planes_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub pixels_len: u16,
    pub pad1: [u8; 2usize],
    pub red_mask: u32,
    pub green_mask: u32,
    pub blue_mask: u32,
    pub pad2: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_xcb_alloc_color_planes_reply_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_alloc_color_planes_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_alloc_color_planes_reply_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_alloc_color_planes_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_alloc_color_planes_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_alloc_color_planes_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_alloc_color_planes_reply_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_alloc_color_planes_reply_t>())).sequence as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_alloc_color_planes_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_alloc_color_planes_reply_t>())).pixels_len as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_reply_t),
            "::",
            stringify!(pixels_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_alloc_color_planes_reply_t>())).pad1 as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_reply_t),
            "::",
            stringify!(pad1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_alloc_color_planes_reply_t>())).red_mask as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_reply_t),
            "::",
            stringify!(red_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_alloc_color_planes_reply_t>())).green_mask as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_reply_t),
            "::",
            stringify!(green_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_alloc_color_planes_reply_t>())).blue_mask as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_reply_t),
            "::",
            stringify!(blue_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_alloc_color_planes_reply_t>())).pad2 as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_alloc_color_planes_reply_t),
            "::",
            stringify!(pad2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_free_colors_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
    pub plane_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_free_colors_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_free_colors_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_free_colors_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_free_colors_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_free_colors_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_free_colors_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_colors_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_free_colors_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_colors_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_free_colors_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_colors_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_free_colors_request_t>())).cmap as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_colors_request_t),
            "::",
            stringify!(cmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_free_colors_request_t>())).plane_mask as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_colors_request_t),
            "::",
            stringify!(plane_mask)
        )
    );
}
pub const xcb_color_flag_t_XCB_COLOR_FLAG_RED: xcb_color_flag_t = 1;
pub const xcb_color_flag_t_XCB_COLOR_FLAG_GREEN: xcb_color_flag_t = 2;
pub const xcb_color_flag_t_XCB_COLOR_FLAG_BLUE: xcb_color_flag_t = 4;
pub type xcb_color_flag_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_coloritem_t {
    pub pixel: u32,
    pub red: u16,
    pub green: u16,
    pub blue: u16,
    pub flags: u8,
    pub pad0: u8,
}
#[test]
fn bindgen_test_layout_xcb_coloritem_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_coloritem_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_coloritem_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_coloritem_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_coloritem_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_coloritem_t>())).pixel as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_coloritem_t),
            "::",
            stringify!(pixel)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_coloritem_t>())).red as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_coloritem_t),
            "::",
            stringify!(red)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_coloritem_t>())).green as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_coloritem_t),
            "::",
            stringify!(green)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_coloritem_t>())).blue as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_coloritem_t),
            "::",
            stringify!(blue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_coloritem_t>())).flags as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_coloritem_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_coloritem_t>())).pad0 as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_coloritem_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_coloritem_iterator_t {
    pub data: *mut xcb_coloritem_t,
    pub rem: cty::c_int,
    pub index: cty::c_int,
}
#[test]
fn bindgen_test_layout_xcb_coloritem_iterator_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_coloritem_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_coloritem_iterator_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_coloritem_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_coloritem_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_coloritem_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_coloritem_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_coloritem_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_coloritem_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_coloritem_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_coloritem_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_store_colors_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
}
#[test]
fn bindgen_test_layout_xcb_store_colors_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_store_colors_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_store_colors_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_store_colors_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_store_colors_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_store_colors_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_store_colors_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_store_colors_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_store_colors_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_store_colors_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_store_colors_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_store_colors_request_t>())).cmap as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_store_colors_request_t),
            "::",
            stringify!(cmap)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_store_named_color_request_t {
    pub major_opcode: u8,
    pub flags: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
    pub pixel: u32,
    pub name_len: u16,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_store_named_color_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_store_named_color_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_store_named_color_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_store_named_color_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_store_named_color_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_store_named_color_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_store_named_color_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_store_named_color_request_t>())).flags as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_store_named_color_request_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_store_named_color_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_store_named_color_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_store_named_color_request_t>())).cmap as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_store_named_color_request_t),
            "::",
            stringify!(cmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_store_named_color_request_t>())).pixel as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_store_named_color_request_t),
            "::",
            stringify!(pixel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_store_named_color_request_t>())).name_len as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_store_named_color_request_t),
            "::",
            stringify!(name_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_store_named_color_request_t>())).pad0 as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_store_named_color_request_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_rgb_t {
    pub red: u16,
    pub green: u16,
    pub blue: u16,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_rgb_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_rgb_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_rgb_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_rgb_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_rgb_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_rgb_t>())).red as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rgb_t),
            "::",
            stringify!(red)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_rgb_t>())).green as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rgb_t),
            "::",
            stringify!(green)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_rgb_t>())).blue as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rgb_t),
            "::",
            stringify!(blue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_rgb_t>())).pad0 as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rgb_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_rgb_iterator_t {
    pub data: *mut xcb_rgb_t,
    pub rem: cty::c_int,
    pub index: cty::c_int,
}
#[test]
fn bindgen_test_layout_xcb_rgb_iterator_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_rgb_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_rgb_iterator_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_rgb_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_rgb_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_rgb_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rgb_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_rgb_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rgb_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_rgb_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rgb_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_colors_cookie_t {
    pub sequence: cty::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_query_colors_cookie_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_query_colors_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_query_colors_cookie_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_query_colors_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_colors_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_colors_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_colors_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_colors_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
}
#[test]
fn bindgen_test_layout_xcb_query_colors_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_query_colors_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_query_colors_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_query_colors_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_colors_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_colors_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_colors_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_colors_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_colors_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_colors_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_colors_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_colors_request_t>())).cmap as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_colors_request_t),
            "::",
            stringify!(cmap)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_colors_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub colors_len: u16,
    pub pad1: [u8; 22usize],
}
#[test]
fn bindgen_test_layout_xcb_query_colors_reply_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_query_colors_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_query_colors_reply_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_query_colors_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_colors_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_colors_reply_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_colors_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_query_colors_reply_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_colors_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_colors_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_colors_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_colors_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_colors_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_colors_reply_t>())).colors_len as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_colors_reply_t),
            "::",
            stringify!(colors_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_query_colors_reply_t>())).pad1 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_colors_reply_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_lookup_color_cookie_t {
    pub sequence: cty::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_lookup_color_cookie_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_lookup_color_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_lookup_color_cookie_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_lookup_color_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_lookup_color_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_lookup_color_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_lookup_color_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cmap: xcb_colormap_t,
    pub name_len: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_lookup_color_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_lookup_color_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_lookup_color_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_lookup_color_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_lookup_color_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_lookup_color_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_lookup_color_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_lookup_color_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_lookup_color_request_t>())).cmap as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_request_t),
            "::",
            stringify!(cmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_lookup_color_request_t>())).name_len as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_request_t),
            "::",
            stringify!(name_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_lookup_color_request_t>())).pad1 as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_request_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_lookup_color_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub exact_red: u16,
    pub exact_green: u16,
    pub exact_blue: u16,
    pub visual_red: u16,
    pub visual_green: u16,
    pub visual_blue: u16,
}
#[test]
fn bindgen_test_layout_xcb_lookup_color_reply_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_lookup_color_reply_t>(),
        20usize,
        concat!("Size of: ", stringify!(xcb_lookup_color_reply_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_lookup_color_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_lookup_color_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_lookup_color_reply_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_lookup_color_reply_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_lookup_color_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_lookup_color_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_lookup_color_reply_t>())).exact_red as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_reply_t),
            "::",
            stringify!(exact_red)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_lookup_color_reply_t>())).exact_green as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_reply_t),
            "::",
            stringify!(exact_green)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_lookup_color_reply_t>())).exact_blue as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_reply_t),
            "::",
            stringify!(exact_blue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_lookup_color_reply_t>())).visual_red as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_reply_t),
            "::",
            stringify!(visual_red)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_lookup_color_reply_t>())).visual_green as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_reply_t),
            "::",
            stringify!(visual_green)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_lookup_color_reply_t>())).visual_blue as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_lookup_color_reply_t),
            "::",
            stringify!(visual_blue)
        )
    );
}
pub const xcb_pixmap_enum_t_XCB_PIXMAP_NONE: xcb_pixmap_enum_t = 0;
pub type xcb_pixmap_enum_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_create_cursor_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cid: xcb_cursor_t,
    pub source: xcb_pixmap_t,
    pub mask: xcb_pixmap_t,
    pub fore_red: u16,
    pub fore_green: u16,
    pub fore_blue: u16,
    pub back_red: u16,
    pub back_green: u16,
    pub back_blue: u16,
    pub x: u16,
    pub y: u16,
}
#[test]
fn bindgen_test_layout_xcb_create_cursor_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_create_cursor_request_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_create_cursor_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_create_cursor_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_create_cursor_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_cursor_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_cursor_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_cursor_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_cursor_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_cursor_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_cursor_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_cursor_request_t>())).cid as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_cursor_request_t),
            "::",
            stringify!(cid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_cursor_request_t>())).source as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_cursor_request_t),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_cursor_request_t>())).mask as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_cursor_request_t),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_cursor_request_t>())).fore_red as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_cursor_request_t),
            "::",
            stringify!(fore_red)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_cursor_request_t>())).fore_green as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_cursor_request_t),
            "::",
            stringify!(fore_green)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_cursor_request_t>())).fore_blue as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_cursor_request_t),
            "::",
            stringify!(fore_blue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_cursor_request_t>())).back_red as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_cursor_request_t),
            "::",
            stringify!(back_red)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_cursor_request_t>())).back_green as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_cursor_request_t),
            "::",
            stringify!(back_green)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_cursor_request_t>())).back_blue as *const _ as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_cursor_request_t),
            "::",
            stringify!(back_blue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_create_cursor_request_t>())).x as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_cursor_request_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_create_cursor_request_t>())).y as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_cursor_request_t),
            "::",
            stringify!(y)
        )
    );
}
pub const xcb_font_enum_t_XCB_FONT_NONE: xcb_font_enum_t = 0;
pub type xcb_font_enum_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_create_glyph_cursor_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cid: xcb_cursor_t,
    pub source_font: xcb_font_t,
    pub mask_font: xcb_font_t,
    pub source_char: u16,
    pub mask_char: u16,
    pub fore_red: u16,
    pub fore_green: u16,
    pub fore_blue: u16,
    pub back_red: u16,
    pub back_green: u16,
    pub back_blue: u16,
}
#[test]
fn bindgen_test_layout_xcb_create_glyph_cursor_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_create_glyph_cursor_request_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_create_glyph_cursor_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_create_glyph_cursor_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_create_glyph_cursor_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_glyph_cursor_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_glyph_cursor_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_glyph_cursor_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_glyph_cursor_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_glyph_cursor_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_glyph_cursor_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_glyph_cursor_request_t>())).cid as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_glyph_cursor_request_t),
            "::",
            stringify!(cid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_glyph_cursor_request_t>())).source_font as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_glyph_cursor_request_t),
            "::",
            stringify!(source_font)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_glyph_cursor_request_t>())).mask_font as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_glyph_cursor_request_t),
            "::",
            stringify!(mask_font)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_glyph_cursor_request_t>())).source_char as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_glyph_cursor_request_t),
            "::",
            stringify!(source_char)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_glyph_cursor_request_t>())).mask_char as *const _
                as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_glyph_cursor_request_t),
            "::",
            stringify!(mask_char)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_glyph_cursor_request_t>())).fore_red as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_glyph_cursor_request_t),
            "::",
            stringify!(fore_red)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_glyph_cursor_request_t>())).fore_green as *const _
                as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_glyph_cursor_request_t),
            "::",
            stringify!(fore_green)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_glyph_cursor_request_t>())).fore_blue as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_glyph_cursor_request_t),
            "::",
            stringify!(fore_blue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_glyph_cursor_request_t>())).back_red as *const _
                as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_glyph_cursor_request_t),
            "::",
            stringify!(back_red)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_glyph_cursor_request_t>())).back_green as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_glyph_cursor_request_t),
            "::",
            stringify!(back_green)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_create_glyph_cursor_request_t>())).back_blue as *const _
                as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_create_glyph_cursor_request_t),
            "::",
            stringify!(back_blue)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_free_cursor_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cursor: xcb_cursor_t,
}
#[test]
fn bindgen_test_layout_xcb_free_cursor_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_free_cursor_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_free_cursor_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_free_cursor_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_free_cursor_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_free_cursor_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_cursor_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_free_cursor_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_cursor_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_free_cursor_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_cursor_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_free_cursor_request_t>())).cursor as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_free_cursor_request_t),
            "::",
            stringify!(cursor)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_recolor_cursor_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub cursor: xcb_cursor_t,
    pub fore_red: u16,
    pub fore_green: u16,
    pub fore_blue: u16,
    pub back_red: u16,
    pub back_green: u16,
    pub back_blue: u16,
}
#[test]
fn bindgen_test_layout_xcb_recolor_cursor_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_recolor_cursor_request_t>(),
        20usize,
        concat!("Size of: ", stringify!(xcb_recolor_cursor_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_recolor_cursor_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_recolor_cursor_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_recolor_cursor_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_recolor_cursor_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_recolor_cursor_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_recolor_cursor_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_recolor_cursor_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_recolor_cursor_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_recolor_cursor_request_t>())).cursor as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_recolor_cursor_request_t),
            "::",
            stringify!(cursor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_recolor_cursor_request_t>())).fore_red as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_recolor_cursor_request_t),
            "::",
            stringify!(fore_red)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_recolor_cursor_request_t>())).fore_green as *const _
                as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_recolor_cursor_request_t),
            "::",
            stringify!(fore_green)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_recolor_cursor_request_t>())).fore_blue as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_recolor_cursor_request_t),
            "::",
            stringify!(fore_blue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_recolor_cursor_request_t>())).back_red as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_recolor_cursor_request_t),
            "::",
            stringify!(back_red)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_recolor_cursor_request_t>())).back_green as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_recolor_cursor_request_t),
            "::",
            stringify!(back_green)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_recolor_cursor_request_t>())).back_blue as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_recolor_cursor_request_t),
            "::",
            stringify!(back_blue)
        )
    );
}
pub const xcb_query_shape_of_t_XCB_QUERY_SHAPE_OF_LARGEST_CURSOR: xcb_query_shape_of_t = 0;
pub const xcb_query_shape_of_t_XCB_QUERY_SHAPE_OF_FASTEST_TILE: xcb_query_shape_of_t = 1;
pub const xcb_query_shape_of_t_XCB_QUERY_SHAPE_OF_FASTEST_STIPPLE: xcb_query_shape_of_t = 2;
pub type xcb_query_shape_of_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_best_size_cookie_t {
    pub sequence: cty::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_query_best_size_cookie_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_query_best_size_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_query_best_size_cookie_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_query_best_size_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_best_size_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_best_size_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_best_size_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_best_size_request_t {
    pub major_opcode: u8,
    pub _class: u8,
    pub length: u16,
    pub drawable: xcb_drawable_t,
    pub width: u16,
    pub height: u16,
}
#[test]
fn bindgen_test_layout_xcb_query_best_size_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_query_best_size_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_query_best_size_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_query_best_size_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_best_size_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_best_size_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_best_size_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_best_size_request_t>()))._class as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_best_size_request_t),
            "::",
            stringify!(_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_best_size_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_best_size_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_best_size_request_t>())).drawable as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_best_size_request_t),
            "::",
            stringify!(drawable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_best_size_request_t>())).width as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_best_size_request_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_best_size_request_t>())).height as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_best_size_request_t),
            "::",
            stringify!(height)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_best_size_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub width: u16,
    pub height: u16,
}
#[test]
fn bindgen_test_layout_xcb_query_best_size_reply_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_query_best_size_reply_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_query_best_size_reply_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_query_best_size_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_best_size_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_best_size_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_best_size_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_best_size_reply_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_best_size_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_best_size_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_best_size_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_best_size_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_best_size_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_best_size_reply_t>())).width as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_best_size_reply_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_best_size_reply_t>())).height as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_best_size_reply_t),
            "::",
            stringify!(height)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_extension_cookie_t {
    pub sequence: cty::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_query_extension_cookie_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_query_extension_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_query_extension_cookie_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_query_extension_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_extension_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_extension_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_extension_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_extension_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub name_len: u16,
    pub pad1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_query_extension_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_query_extension_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_query_extension_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_query_extension_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_query_extension_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_extension_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_extension_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_extension_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_extension_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_extension_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_extension_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_extension_request_t>())).name_len as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_extension_request_t),
            "::",
            stringify!(name_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_extension_request_t>())).pad1 as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_extension_request_t),
            "::",
            stringify!(pad1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_query_extension_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub present: u8,
    pub major_opcode: u8,
    pub first_event: u8,
    pub first_error: u8,
}
#[test]
fn bindgen_test_layout_xcb_query_extension_reply_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_query_extension_reply_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_query_extension_reply_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_query_extension_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_query_extension_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_extension_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_extension_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_extension_reply_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_extension_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_extension_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_extension_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_extension_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_extension_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_extension_reply_t>())).present as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_extension_reply_t),
            "::",
            stringify!(present)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_extension_reply_t>())).major_opcode as *const _
                as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_extension_reply_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_extension_reply_t>())).first_event as *const _
                as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_extension_reply_t),
            "::",
            stringify!(first_event)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_query_extension_reply_t>())).first_error as *const _
                as usize
        },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_query_extension_reply_t),
            "::",
            stringify!(first_error)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_extensions_cookie_t {
    pub sequence: cty::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_list_extensions_cookie_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_list_extensions_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_list_extensions_cookie_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_list_extensions_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_list_extensions_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_extensions_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_extensions_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_extensions_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_list_extensions_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_list_extensions_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_list_extensions_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_list_extensions_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_list_extensions_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_extensions_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_extensions_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_extensions_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_extensions_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_extensions_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_extensions_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_extensions_reply_t {
    pub response_type: u8,
    pub names_len: u8,
    pub sequence: u16,
    pub length: u32,
    pub pad0: [u8; 24usize],
}
#[test]
fn bindgen_test_layout_xcb_list_extensions_reply_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_list_extensions_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_list_extensions_reply_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_list_extensions_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_list_extensions_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_extensions_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_extensions_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_extensions_reply_t>())).names_len as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_extensions_reply_t),
            "::",
            stringify!(names_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_extensions_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_extensions_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_extensions_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_extensions_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_extensions_reply_t>())).pad0 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_extensions_reply_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_change_keyboard_mapping_request_t {
    pub major_opcode: u8,
    pub keycode_count: u8,
    pub length: u16,
    pub first_keycode: xcb_keycode_t,
    pub keysyms_per_keycode: u8,
    pub pad0: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_xcb_change_keyboard_mapping_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_change_keyboard_mapping_request_t>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(xcb_change_keyboard_mapping_request_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_change_keyboard_mapping_request_t>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_change_keyboard_mapping_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_keyboard_mapping_request_t>())).major_opcode
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_mapping_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_keyboard_mapping_request_t>())).keycode_count
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_mapping_request_t),
            "::",
            stringify!(keycode_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_keyboard_mapping_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_mapping_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_keyboard_mapping_request_t>())).first_keycode
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_mapping_request_t),
            "::",
            stringify!(first_keycode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_keyboard_mapping_request_t>())).keysyms_per_keycode
                as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_mapping_request_t),
            "::",
            stringify!(keysyms_per_keycode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_keyboard_mapping_request_t>())).pad0 as *const _
                as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_mapping_request_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_keyboard_mapping_cookie_t {
    pub sequence: cty::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_keyboard_mapping_cookie_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_get_keyboard_mapping_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_keyboard_mapping_cookie_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_get_keyboard_mapping_cookie_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_keyboard_mapping_cookie_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_keyboard_mapping_cookie_t>())).sequence as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_mapping_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_keyboard_mapping_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub first_keycode: xcb_keycode_t,
    pub count: u8,
}
#[test]
fn bindgen_test_layout_xcb_get_keyboard_mapping_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_get_keyboard_mapping_request_t>(),
        6usize,
        concat!("Size of: ", stringify!(xcb_get_keyboard_mapping_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_get_keyboard_mapping_request_t>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_keyboard_mapping_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_keyboard_mapping_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_mapping_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_keyboard_mapping_request_t>())).pad0 as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_mapping_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_keyboard_mapping_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_mapping_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_keyboard_mapping_request_t>())).first_keycode
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_mapping_request_t),
            "::",
            stringify!(first_keycode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_keyboard_mapping_request_t>())).count as *const _
                as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_mapping_request_t),
            "::",
            stringify!(count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_keyboard_mapping_reply_t {
    pub response_type: u8,
    pub keysyms_per_keycode: u8,
    pub sequence: u16,
    pub length: u32,
    pub pad0: [u8; 24usize],
}
#[test]
fn bindgen_test_layout_xcb_get_keyboard_mapping_reply_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_get_keyboard_mapping_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_get_keyboard_mapping_reply_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_get_keyboard_mapping_reply_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_keyboard_mapping_reply_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_keyboard_mapping_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_mapping_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_keyboard_mapping_reply_t>())).keysyms_per_keycode
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_mapping_reply_t),
            "::",
            stringify!(keysyms_per_keycode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_keyboard_mapping_reply_t>())).sequence as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_mapping_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_keyboard_mapping_reply_t>())).length as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_mapping_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_keyboard_mapping_reply_t>())).pad0 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_mapping_reply_t),
            "::",
            stringify!(pad0)
        )
    );
}
pub const xcb_kb_t_XCB_KB_KEY_CLICK_PERCENT: xcb_kb_t = 1;
pub const xcb_kb_t_XCB_KB_BELL_PERCENT: xcb_kb_t = 2;
pub const xcb_kb_t_XCB_KB_BELL_PITCH: xcb_kb_t = 4;
pub const xcb_kb_t_XCB_KB_BELL_DURATION: xcb_kb_t = 8;
pub const xcb_kb_t_XCB_KB_LED: xcb_kb_t = 16;
pub const xcb_kb_t_XCB_KB_LED_MODE: xcb_kb_t = 32;
pub const xcb_kb_t_XCB_KB_KEY: xcb_kb_t = 64;
pub const xcb_kb_t_XCB_KB_AUTO_REPEAT_MODE: xcb_kb_t = 128;
pub type xcb_kb_t = u32;
pub const xcb_led_mode_t_XCB_LED_MODE_OFF: xcb_led_mode_t = 0;
pub const xcb_led_mode_t_XCB_LED_MODE_ON: xcb_led_mode_t = 1;
pub type xcb_led_mode_t = u32;
pub const xcb_auto_repeat_mode_t_XCB_AUTO_REPEAT_MODE_OFF: xcb_auto_repeat_mode_t = 0;
pub const xcb_auto_repeat_mode_t_XCB_AUTO_REPEAT_MODE_ON: xcb_auto_repeat_mode_t = 1;
pub const xcb_auto_repeat_mode_t_XCB_AUTO_REPEAT_MODE_DEFAULT: xcb_auto_repeat_mode_t = 2;
pub type xcb_auto_repeat_mode_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_change_keyboard_control_value_list_t {
    pub key_click_percent: i32,
    pub bell_percent: i32,
    pub bell_pitch: i32,
    pub bell_duration: i32,
    pub led: u32,
    pub led_mode: u32,
    pub key: xcb_keycode32_t,
    pub auto_repeat_mode: u32,
}
#[test]
fn bindgen_test_layout_xcb_change_keyboard_control_value_list_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_change_keyboard_control_value_list_t>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(xcb_change_keyboard_control_value_list_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_change_keyboard_control_value_list_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_change_keyboard_control_value_list_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_keyboard_control_value_list_t>())).key_click_percent
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_control_value_list_t),
            "::",
            stringify!(key_click_percent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_keyboard_control_value_list_t>())).bell_percent
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_control_value_list_t),
            "::",
            stringify!(bell_percent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_keyboard_control_value_list_t>())).bell_pitch
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_control_value_list_t),
            "::",
            stringify!(bell_pitch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_keyboard_control_value_list_t>())).bell_duration
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_control_value_list_t),
            "::",
            stringify!(bell_duration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_keyboard_control_value_list_t>())).led as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_control_value_list_t),
            "::",
            stringify!(led)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_keyboard_control_value_list_t>())).led_mode
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_control_value_list_t),
            "::",
            stringify!(led_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_keyboard_control_value_list_t>())).key as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_control_value_list_t),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_keyboard_control_value_list_t>())).auto_repeat_mode
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_control_value_list_t),
            "::",
            stringify!(auto_repeat_mode)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_change_keyboard_control_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub value_mask: u32,
}
#[test]
fn bindgen_test_layout_xcb_change_keyboard_control_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_change_keyboard_control_request_t>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(xcb_change_keyboard_control_request_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_change_keyboard_control_request_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_change_keyboard_control_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_keyboard_control_request_t>())).major_opcode
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_control_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_keyboard_control_request_t>())).pad0 as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_control_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_keyboard_control_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_control_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_keyboard_control_request_t>())).value_mask
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_keyboard_control_request_t),
            "::",
            stringify!(value_mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_keyboard_control_cookie_t {
    pub sequence: cty::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_keyboard_control_cookie_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_get_keyboard_control_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_keyboard_control_cookie_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_get_keyboard_control_cookie_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_keyboard_control_cookie_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_keyboard_control_cookie_t>())).sequence as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_keyboard_control_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_get_keyboard_control_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_get_keyboard_control_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_keyboard_control_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_get_keyboard_control_request_t>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_keyboard_control_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_keyboard_control_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_keyboard_control_request_t>())).pad0 as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_keyboard_control_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_keyboard_control_reply_t {
    pub response_type: u8,
    pub global_auto_repeat: u8,
    pub sequence: u16,
    pub length: u32,
    pub led_mask: u32,
    pub key_click_percent: u8,
    pub bell_percent: u8,
    pub bell_pitch: u16,
    pub bell_duration: u16,
    pub pad0: [u8; 2usize],
    pub auto_repeats: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_xcb_get_keyboard_control_reply_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_get_keyboard_control_reply_t>(),
        52usize,
        concat!("Size of: ", stringify!(xcb_get_keyboard_control_reply_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_get_keyboard_control_reply_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_keyboard_control_reply_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_keyboard_control_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_keyboard_control_reply_t>())).global_auto_repeat
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_reply_t),
            "::",
            stringify!(global_auto_repeat)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_keyboard_control_reply_t>())).sequence as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_keyboard_control_reply_t>())).length as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_keyboard_control_reply_t>())).led_mask as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_reply_t),
            "::",
            stringify!(led_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_keyboard_control_reply_t>())).key_click_percent
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_reply_t),
            "::",
            stringify!(key_click_percent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_keyboard_control_reply_t>())).bell_percent as *const _
                as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_reply_t),
            "::",
            stringify!(bell_percent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_keyboard_control_reply_t>())).bell_pitch as *const _
                as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_reply_t),
            "::",
            stringify!(bell_pitch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_keyboard_control_reply_t>())).bell_duration as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_reply_t),
            "::",
            stringify!(bell_duration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_keyboard_control_reply_t>())).pad0 as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_keyboard_control_reply_t>())).auto_repeats as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_keyboard_control_reply_t),
            "::",
            stringify!(auto_repeats)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_bell_request_t {
    pub major_opcode: u8,
    pub percent: i8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_bell_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_bell_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_bell_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_bell_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_bell_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_bell_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_bell_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_bell_request_t>())).percent as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_bell_request_t),
            "::",
            stringify!(percent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_bell_request_t>())).length as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_bell_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_change_pointer_control_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub acceleration_numerator: i16,
    pub acceleration_denominator: i16,
    pub threshold: i16,
    pub do_acceleration: u8,
    pub do_threshold: u8,
}
#[test]
fn bindgen_test_layout_xcb_change_pointer_control_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_change_pointer_control_request_t>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(xcb_change_pointer_control_request_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_change_pointer_control_request_t>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_change_pointer_control_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_pointer_control_request_t>())).major_opcode
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_pointer_control_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_pointer_control_request_t>())).pad0 as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_pointer_control_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_pointer_control_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_pointer_control_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_pointer_control_request_t>())).acceleration_numerator
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_pointer_control_request_t),
            "::",
            stringify!(acceleration_numerator)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_pointer_control_request_t>()))
                .acceleration_denominator as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_pointer_control_request_t),
            "::",
            stringify!(acceleration_denominator)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_pointer_control_request_t>())).threshold as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_pointer_control_request_t),
            "::",
            stringify!(threshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_pointer_control_request_t>())).do_acceleration
                as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_pointer_control_request_t),
            "::",
            stringify!(do_acceleration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_pointer_control_request_t>())).do_threshold
                as *const _ as usize
        },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_pointer_control_request_t),
            "::",
            stringify!(do_threshold)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_pointer_control_cookie_t {
    pub sequence: cty::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_pointer_control_cookie_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_get_pointer_control_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_pointer_control_cookie_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_get_pointer_control_cookie_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_pointer_control_cookie_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_pointer_control_cookie_t>())).sequence as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_control_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_pointer_control_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_get_pointer_control_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_get_pointer_control_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_pointer_control_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_get_pointer_control_request_t>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_pointer_control_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_pointer_control_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_control_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_pointer_control_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_control_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_pointer_control_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_control_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_pointer_control_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub acceleration_numerator: u16,
    pub acceleration_denominator: u16,
    pub threshold: u16,
    pub pad1: [u8; 18usize],
}
#[test]
fn bindgen_test_layout_xcb_get_pointer_control_reply_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_get_pointer_control_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_get_pointer_control_reply_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_get_pointer_control_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_pointer_control_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_pointer_control_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_control_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_pointer_control_reply_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_control_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_pointer_control_reply_t>())).sequence as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_control_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_pointer_control_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_control_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_pointer_control_reply_t>())).acceleration_numerator
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_control_reply_t),
            "::",
            stringify!(acceleration_numerator)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_pointer_control_reply_t>())).acceleration_denominator
                as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_control_reply_t),
            "::",
            stringify!(acceleration_denominator)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_pointer_control_reply_t>())).threshold as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_control_reply_t),
            "::",
            stringify!(threshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_pointer_control_reply_t>())).pad1 as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_control_reply_t),
            "::",
            stringify!(pad1)
        )
    );
}
pub const xcb_blanking_t_XCB_BLANKING_NOT_PREFERRED: xcb_blanking_t = 0;
pub const xcb_blanking_t_XCB_BLANKING_PREFERRED: xcb_blanking_t = 1;
pub const xcb_blanking_t_XCB_BLANKING_DEFAULT: xcb_blanking_t = 2;
pub type xcb_blanking_t = u32;
pub const xcb_exposures_t_XCB_EXPOSURES_NOT_ALLOWED: xcb_exposures_t = 0;
pub const xcb_exposures_t_XCB_EXPOSURES_ALLOWED: xcb_exposures_t = 1;
pub const xcb_exposures_t_XCB_EXPOSURES_DEFAULT: xcb_exposures_t = 2;
pub type xcb_exposures_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_set_screen_saver_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub timeout: i16,
    pub interval: i16,
    pub prefer_blanking: u8,
    pub allow_exposures: u8,
}
#[test]
fn bindgen_test_layout_xcb_set_screen_saver_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_set_screen_saver_request_t>(),
        10usize,
        concat!("Size of: ", stringify!(xcb_set_screen_saver_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_set_screen_saver_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_set_screen_saver_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_set_screen_saver_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_screen_saver_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_set_screen_saver_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_screen_saver_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_set_screen_saver_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_screen_saver_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_set_screen_saver_request_t>())).timeout as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_screen_saver_request_t),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_set_screen_saver_request_t>())).interval as *const _
                as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_screen_saver_request_t),
            "::",
            stringify!(interval)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_set_screen_saver_request_t>())).prefer_blanking as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_screen_saver_request_t),
            "::",
            stringify!(prefer_blanking)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_set_screen_saver_request_t>())).allow_exposures as *const _
                as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_screen_saver_request_t),
            "::",
            stringify!(allow_exposures)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_screen_saver_cookie_t {
    pub sequence: cty::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_screen_saver_cookie_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_get_screen_saver_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_screen_saver_cookie_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_get_screen_saver_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_screen_saver_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_screen_saver_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_screen_saver_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_screen_saver_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_get_screen_saver_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_get_screen_saver_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_screen_saver_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_get_screen_saver_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_get_screen_saver_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_screen_saver_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_screen_saver_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_screen_saver_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_screen_saver_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_screen_saver_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_screen_saver_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_screen_saver_reply_t {
    pub response_type: u8,
    pub pad0: u8,
    pub sequence: u16,
    pub length: u32,
    pub timeout: u16,
    pub interval: u16,
    pub prefer_blanking: u8,
    pub allow_exposures: u8,
    pub pad1: [u8; 18usize],
}
#[test]
fn bindgen_test_layout_xcb_get_screen_saver_reply_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_get_screen_saver_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_get_screen_saver_reply_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_get_screen_saver_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_screen_saver_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_screen_saver_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_screen_saver_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_screen_saver_reply_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_screen_saver_reply_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_screen_saver_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_screen_saver_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_screen_saver_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_screen_saver_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_screen_saver_reply_t>())).timeout as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_screen_saver_reply_t),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_screen_saver_reply_t>())).interval as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_screen_saver_reply_t),
            "::",
            stringify!(interval)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_screen_saver_reply_t>())).prefer_blanking as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_screen_saver_reply_t),
            "::",
            stringify!(prefer_blanking)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_screen_saver_reply_t>())).allow_exposures as *const _
                as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_screen_saver_reply_t),
            "::",
            stringify!(allow_exposures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_screen_saver_reply_t>())).pad1 as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_screen_saver_reply_t),
            "::",
            stringify!(pad1)
        )
    );
}
pub const xcb_host_mode_t_XCB_HOST_MODE_INSERT: xcb_host_mode_t = 0;
pub const xcb_host_mode_t_XCB_HOST_MODE_DELETE: xcb_host_mode_t = 1;
pub type xcb_host_mode_t = u32;
pub const xcb_family_t_XCB_FAMILY_INTERNET: xcb_family_t = 0;
pub const xcb_family_t_XCB_FAMILY_DECNET: xcb_family_t = 1;
pub const xcb_family_t_XCB_FAMILY_CHAOS: xcb_family_t = 2;
pub const xcb_family_t_XCB_FAMILY_SERVER_INTERPRETED: xcb_family_t = 5;
pub const xcb_family_t_XCB_FAMILY_INTERNET_6: xcb_family_t = 6;
pub type xcb_family_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_change_hosts_request_t {
    pub major_opcode: u8,
    pub mode: u8,
    pub length: u16,
    pub family: u8,
    pub pad0: u8,
    pub address_len: u16,
}
#[test]
fn bindgen_test_layout_xcb_change_hosts_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_change_hosts_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_change_hosts_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_change_hosts_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_change_hosts_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_hosts_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_hosts_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_hosts_request_t>())).mode as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_hosts_request_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_hosts_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_hosts_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_hosts_request_t>())).family as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_hosts_request_t),
            "::",
            stringify!(family)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_hosts_request_t>())).pad0 as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_hosts_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_change_hosts_request_t>())).address_len as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_change_hosts_request_t),
            "::",
            stringify!(address_len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_host_t {
    pub family: u8,
    pub pad0: u8,
    pub address_len: u16,
}
#[test]
fn bindgen_test_layout_xcb_host_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_host_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_host_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_host_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_host_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_host_t>())).family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_host_t),
            "::",
            stringify!(family)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_host_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_host_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_host_t>())).address_len as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_host_t),
            "::",
            stringify!(address_len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_host_iterator_t {
    pub data: *mut xcb_host_t,
    pub rem: cty::c_int,
    pub index: cty::c_int,
}
#[test]
fn bindgen_test_layout_xcb_host_iterator_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_host_iterator_t>(),
        16usize,
        concat!("Size of: ", stringify!(xcb_host_iterator_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_host_iterator_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_host_iterator_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_host_iterator_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_host_iterator_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_host_iterator_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_host_iterator_t),
            "::",
            stringify!(rem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_host_iterator_t>())).index as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_host_iterator_t),
            "::",
            stringify!(index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_hosts_cookie_t {
    pub sequence: cty::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_list_hosts_cookie_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_list_hosts_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_list_hosts_cookie_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_list_hosts_cookie_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_list_hosts_cookie_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_hosts_cookie_t>())).sequence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_hosts_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_hosts_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_list_hosts_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_list_hosts_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_list_hosts_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_list_hosts_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_list_hosts_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_hosts_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_hosts_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_list_hosts_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_hosts_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_hosts_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_hosts_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_list_hosts_reply_t {
    pub response_type: u8,
    pub mode: u8,
    pub sequence: u16,
    pub length: u32,
    pub hosts_len: u16,
    pub pad0: [u8; 22usize],
}
#[test]
fn bindgen_test_layout_xcb_list_hosts_reply_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_list_hosts_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_list_hosts_reply_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_list_hosts_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_list_hosts_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_hosts_reply_t>())).response_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_hosts_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_list_hosts_reply_t>())).mode as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_hosts_reply_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_hosts_reply_t>())).sequence as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_hosts_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_list_hosts_reply_t>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_hosts_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_list_hosts_reply_t>())).hosts_len as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_hosts_reply_t),
            "::",
            stringify!(hosts_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_list_hosts_reply_t>())).pad0 as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_list_hosts_reply_t),
            "::",
            stringify!(pad0)
        )
    );
}
pub const xcb_access_control_t_XCB_ACCESS_CONTROL_DISABLE: xcb_access_control_t = 0;
pub const xcb_access_control_t_XCB_ACCESS_CONTROL_ENABLE: xcb_access_control_t = 1;
pub type xcb_access_control_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_set_access_control_request_t {
    pub major_opcode: u8,
    pub mode: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_set_access_control_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_set_access_control_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_set_access_control_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_set_access_control_request_t>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_set_access_control_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_set_access_control_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_access_control_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_set_access_control_request_t>())).mode as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_access_control_request_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_set_access_control_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_access_control_request_t),
            "::",
            stringify!(length)
        )
    );
}
pub const xcb_close_down_t_XCB_CLOSE_DOWN_DESTROY_ALL: xcb_close_down_t = 0;
pub const xcb_close_down_t_XCB_CLOSE_DOWN_RETAIN_PERMANENT: xcb_close_down_t = 1;
pub const xcb_close_down_t_XCB_CLOSE_DOWN_RETAIN_TEMPORARY: xcb_close_down_t = 2;
pub type xcb_close_down_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_set_close_down_mode_request_t {
    pub major_opcode: u8,
    pub mode: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_set_close_down_mode_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_set_close_down_mode_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_set_close_down_mode_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_set_close_down_mode_request_t>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_set_close_down_mode_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_set_close_down_mode_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_close_down_mode_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_set_close_down_mode_request_t>())).mode as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_close_down_mode_request_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_set_close_down_mode_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_close_down_mode_request_t),
            "::",
            stringify!(length)
        )
    );
}
pub const xcb_kill_t_XCB_KILL_ALL_TEMPORARY: xcb_kill_t = 0;
pub type xcb_kill_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_kill_client_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub resource: u32,
}
#[test]
fn bindgen_test_layout_xcb_kill_client_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_kill_client_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_kill_client_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_kill_client_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_kill_client_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_kill_client_request_t>())).major_opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_kill_client_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_kill_client_request_t>())).pad0 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_kill_client_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_kill_client_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_kill_client_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_kill_client_request_t>())).resource as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_kill_client_request_t),
            "::",
            stringify!(resource)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_rotate_properties_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
    pub window: xcb_window_t,
    pub atoms_len: u16,
    pub delta: i16,
}
#[test]
fn bindgen_test_layout_xcb_rotate_properties_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_rotate_properties_request_t>(),
        12usize,
        concat!("Size of: ", stringify!(xcb_rotate_properties_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_rotate_properties_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_rotate_properties_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_rotate_properties_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rotate_properties_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_rotate_properties_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rotate_properties_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_rotate_properties_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rotate_properties_request_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_rotate_properties_request_t>())).window as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rotate_properties_request_t),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_rotate_properties_request_t>())).atoms_len as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rotate_properties_request_t),
            "::",
            stringify!(atoms_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_rotate_properties_request_t>())).delta as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_rotate_properties_request_t),
            "::",
            stringify!(delta)
        )
    );
}
pub const xcb_screen_saver_t_XCB_SCREEN_SAVER_RESET: xcb_screen_saver_t = 0;
pub const xcb_screen_saver_t_XCB_SCREEN_SAVER_ACTIVE: xcb_screen_saver_t = 1;
pub type xcb_screen_saver_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_force_screen_saver_request_t {
    pub major_opcode: u8,
    pub mode: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_force_screen_saver_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_force_screen_saver_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_force_screen_saver_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_force_screen_saver_request_t>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_force_screen_saver_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_force_screen_saver_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_force_screen_saver_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_force_screen_saver_request_t>())).mode as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_force_screen_saver_request_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_force_screen_saver_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_force_screen_saver_request_t),
            "::",
            stringify!(length)
        )
    );
}
pub const xcb_mapping_status_t_XCB_MAPPING_STATUS_SUCCESS: xcb_mapping_status_t = 0;
pub const xcb_mapping_status_t_XCB_MAPPING_STATUS_BUSY: xcb_mapping_status_t = 1;
pub const xcb_mapping_status_t_XCB_MAPPING_STATUS_FAILURE: xcb_mapping_status_t = 2;
pub type xcb_mapping_status_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_set_pointer_mapping_cookie_t {
    pub sequence: cty::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_set_pointer_mapping_cookie_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_set_pointer_mapping_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_set_pointer_mapping_cookie_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_set_pointer_mapping_cookie_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_set_pointer_mapping_cookie_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_set_pointer_mapping_cookie_t>())).sequence as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_pointer_mapping_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_set_pointer_mapping_request_t {
    pub major_opcode: u8,
    pub map_len: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_set_pointer_mapping_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_set_pointer_mapping_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_set_pointer_mapping_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_set_pointer_mapping_request_t>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_set_pointer_mapping_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_set_pointer_mapping_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_pointer_mapping_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_set_pointer_mapping_request_t>())).map_len as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_pointer_mapping_request_t),
            "::",
            stringify!(map_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_set_pointer_mapping_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_pointer_mapping_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_set_pointer_mapping_reply_t {
    pub response_type: u8,
    pub status: u8,
    pub sequence: u16,
    pub length: u32,
}
#[test]
fn bindgen_test_layout_xcb_set_pointer_mapping_reply_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_set_pointer_mapping_reply_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_set_pointer_mapping_reply_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_set_pointer_mapping_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_set_pointer_mapping_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_set_pointer_mapping_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_pointer_mapping_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_set_pointer_mapping_reply_t>())).status as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_pointer_mapping_reply_t),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_set_pointer_mapping_reply_t>())).sequence as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_pointer_mapping_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_set_pointer_mapping_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_pointer_mapping_reply_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_pointer_mapping_cookie_t {
    pub sequence: cty::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_pointer_mapping_cookie_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_get_pointer_mapping_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_pointer_mapping_cookie_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_get_pointer_mapping_cookie_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_pointer_mapping_cookie_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_pointer_mapping_cookie_t>())).sequence as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_mapping_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_pointer_mapping_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_get_pointer_mapping_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_get_pointer_mapping_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_pointer_mapping_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_get_pointer_mapping_request_t>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_pointer_mapping_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_pointer_mapping_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_mapping_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_pointer_mapping_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_mapping_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_pointer_mapping_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_mapping_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_pointer_mapping_reply_t {
    pub response_type: u8,
    pub map_len: u8,
    pub sequence: u16,
    pub length: u32,
    pub pad0: [u8; 24usize],
}
#[test]
fn bindgen_test_layout_xcb_get_pointer_mapping_reply_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_get_pointer_mapping_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_get_pointer_mapping_reply_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_get_pointer_mapping_reply_t>(),
        4usize,
        concat!("Alignment of ", stringify!(xcb_get_pointer_mapping_reply_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_pointer_mapping_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_mapping_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_pointer_mapping_reply_t>())).map_len as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_mapping_reply_t),
            "::",
            stringify!(map_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_pointer_mapping_reply_t>())).sequence as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_mapping_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_pointer_mapping_reply_t>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_mapping_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_pointer_mapping_reply_t>())).pad0 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_pointer_mapping_reply_t),
            "::",
            stringify!(pad0)
        )
    );
}
pub const xcb_map_index_t_XCB_MAP_INDEX_SHIFT: xcb_map_index_t = 0;
pub const xcb_map_index_t_XCB_MAP_INDEX_LOCK: xcb_map_index_t = 1;
pub const xcb_map_index_t_XCB_MAP_INDEX_CONTROL: xcb_map_index_t = 2;
pub const xcb_map_index_t_XCB_MAP_INDEX_1: xcb_map_index_t = 3;
pub const xcb_map_index_t_XCB_MAP_INDEX_2: xcb_map_index_t = 4;
pub const xcb_map_index_t_XCB_MAP_INDEX_3: xcb_map_index_t = 5;
pub const xcb_map_index_t_XCB_MAP_INDEX_4: xcb_map_index_t = 6;
pub const xcb_map_index_t_XCB_MAP_INDEX_5: xcb_map_index_t = 7;
pub type xcb_map_index_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_set_modifier_mapping_cookie_t {
    pub sequence: cty::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_set_modifier_mapping_cookie_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_set_modifier_mapping_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_set_modifier_mapping_cookie_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_set_modifier_mapping_cookie_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_set_modifier_mapping_cookie_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_set_modifier_mapping_cookie_t>())).sequence as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_modifier_mapping_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_set_modifier_mapping_request_t {
    pub major_opcode: u8,
    pub keycodes_per_modifier: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_set_modifier_mapping_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_set_modifier_mapping_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_set_modifier_mapping_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_set_modifier_mapping_request_t>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_set_modifier_mapping_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_set_modifier_mapping_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_modifier_mapping_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_set_modifier_mapping_request_t>())).keycodes_per_modifier
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_modifier_mapping_request_t),
            "::",
            stringify!(keycodes_per_modifier)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_set_modifier_mapping_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_modifier_mapping_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_set_modifier_mapping_reply_t {
    pub response_type: u8,
    pub status: u8,
    pub sequence: u16,
    pub length: u32,
}
#[test]
fn bindgen_test_layout_xcb_set_modifier_mapping_reply_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_set_modifier_mapping_reply_t>(),
        8usize,
        concat!("Size of: ", stringify!(xcb_set_modifier_mapping_reply_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_set_modifier_mapping_reply_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_set_modifier_mapping_reply_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_set_modifier_mapping_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_modifier_mapping_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_set_modifier_mapping_reply_t>())).status as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_modifier_mapping_reply_t),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_set_modifier_mapping_reply_t>())).sequence as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_modifier_mapping_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_set_modifier_mapping_reply_t>())).length as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_set_modifier_mapping_reply_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_modifier_mapping_cookie_t {
    pub sequence: cty::c_uint,
}
#[test]
fn bindgen_test_layout_xcb_get_modifier_mapping_cookie_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_get_modifier_mapping_cookie_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_modifier_mapping_cookie_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_get_modifier_mapping_cookie_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_modifier_mapping_cookie_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_modifier_mapping_cookie_t>())).sequence as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_modifier_mapping_cookie_t),
            "::",
            stringify!(sequence)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_modifier_mapping_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_get_modifier_mapping_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_get_modifier_mapping_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_get_modifier_mapping_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_get_modifier_mapping_request_t>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_modifier_mapping_request_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_modifier_mapping_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_modifier_mapping_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_modifier_mapping_request_t>())).pad0 as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_modifier_mapping_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_modifier_mapping_request_t>())).length as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_modifier_mapping_request_t),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_get_modifier_mapping_reply_t {
    pub response_type: u8,
    pub keycodes_per_modifier: u8,
    pub sequence: u16,
    pub length: u32,
    pub pad0: [u8; 24usize],
}
#[test]
fn bindgen_test_layout_xcb_get_modifier_mapping_reply_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_get_modifier_mapping_reply_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_get_modifier_mapping_reply_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_get_modifier_mapping_reply_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(xcb_get_modifier_mapping_reply_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_modifier_mapping_reply_t>())).response_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_modifier_mapping_reply_t),
            "::",
            stringify!(response_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_modifier_mapping_reply_t>())).keycodes_per_modifier
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_modifier_mapping_reply_t),
            "::",
            stringify!(keycodes_per_modifier)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_modifier_mapping_reply_t>())).sequence as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_modifier_mapping_reply_t),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_modifier_mapping_reply_t>())).length as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_modifier_mapping_reply_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_get_modifier_mapping_reply_t>())).pad0 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_get_modifier_mapping_reply_t),
            "::",
            stringify!(pad0)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_no_operation_request_t {
    pub major_opcode: u8,
    pub pad0: u8,
    pub length: u16,
}
#[test]
fn bindgen_test_layout_xcb_no_operation_request_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_no_operation_request_t>(),
        4usize,
        concat!("Size of: ", stringify!(xcb_no_operation_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_no_operation_request_t>(),
        2usize,
        concat!("Alignment of ", stringify!(xcb_no_operation_request_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_no_operation_request_t>())).major_opcode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_no_operation_request_t),
            "::",
            stringify!(major_opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_no_operation_request_t>())).pad0 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_no_operation_request_t),
            "::",
            stringify!(pad0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<xcb_no_operation_request_t>())).length as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_no_operation_request_t),
            "::",
            stringify!(length)
        )
    );
}
extern "C" {
    pub fn xcb_char2b_next(i: *mut xcb_char2b_iterator_t);
}
extern "C" {
    pub fn xcb_char2b_end(i: xcb_char2b_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_window_next(i: *mut xcb_window_iterator_t);
}
extern "C" {
    pub fn xcb_window_end(i: xcb_window_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_pixmap_next(i: *mut xcb_pixmap_iterator_t);
}
extern "C" {
    pub fn xcb_pixmap_end(i: xcb_pixmap_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_cursor_next(i: *mut xcb_cursor_iterator_t);
}
extern "C" {
    pub fn xcb_cursor_end(i: xcb_cursor_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_font_next(i: *mut xcb_font_iterator_t);
}
extern "C" {
    pub fn xcb_font_end(i: xcb_font_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_gcontext_next(i: *mut xcb_gcontext_iterator_t);
}
extern "C" {
    pub fn xcb_gcontext_end(i: xcb_gcontext_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_colormap_next(i: *mut xcb_colormap_iterator_t);
}
extern "C" {
    pub fn xcb_colormap_end(i: xcb_colormap_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_atom_next(i: *mut xcb_atom_iterator_t);
}
extern "C" {
    pub fn xcb_atom_end(i: xcb_atom_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_drawable_next(i: *mut xcb_drawable_iterator_t);
}
extern "C" {
    pub fn xcb_drawable_end(i: xcb_drawable_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_fontable_next(i: *mut xcb_fontable_iterator_t);
}
extern "C" {
    pub fn xcb_fontable_end(i: xcb_fontable_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_bool32_next(i: *mut xcb_bool32_iterator_t);
}
extern "C" {
    pub fn xcb_bool32_end(i: xcb_bool32_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_visualid_next(i: *mut xcb_visualid_iterator_t);
}
extern "C" {
    pub fn xcb_visualid_end(i: xcb_visualid_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_timestamp_next(i: *mut xcb_timestamp_iterator_t);
}
extern "C" {
    pub fn xcb_timestamp_end(i: xcb_timestamp_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_keysym_next(i: *mut xcb_keysym_iterator_t);
}
extern "C" {
    pub fn xcb_keysym_end(i: xcb_keysym_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_keycode_next(i: *mut xcb_keycode_iterator_t);
}
extern "C" {
    pub fn xcb_keycode_end(i: xcb_keycode_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_keycode32_next(i: *mut xcb_keycode32_iterator_t);
}
extern "C" {
    pub fn xcb_keycode32_end(i: xcb_keycode32_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_button_next(i: *mut xcb_button_iterator_t);
}
extern "C" {
    pub fn xcb_button_end(i: xcb_button_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_point_next(i: *mut xcb_point_iterator_t);
}
extern "C" {
    pub fn xcb_point_end(i: xcb_point_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_rectangle_next(i: *mut xcb_rectangle_iterator_t);
}
extern "C" {
    pub fn xcb_rectangle_end(i: xcb_rectangle_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_arc_next(i: *mut xcb_arc_iterator_t);
}
extern "C" {
    pub fn xcb_arc_end(i: xcb_arc_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_format_next(i: *mut xcb_format_iterator_t);
}
extern "C" {
    pub fn xcb_format_end(i: xcb_format_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_visualtype_next(i: *mut xcb_visualtype_iterator_t);
}
extern "C" {
    pub fn xcb_visualtype_end(i: xcb_visualtype_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_depth_sizeof(_buffer: *const cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn xcb_depth_visuals(R: *const xcb_depth_t) -> *mut xcb_visualtype_t;
}
extern "C" {
    pub fn xcb_depth_visuals_length(R: *const xcb_depth_t) -> cty::c_int;
}
extern "C" {
    pub fn xcb_depth_visuals_iterator(R: *const xcb_depth_t) -> xcb_visualtype_iterator_t;
}
extern "C" {
    pub fn xcb_depth_next(i: *mut xcb_depth_iterator_t);
}
extern "C" {
    pub fn xcb_depth_end(i: xcb_depth_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_screen_sizeof(_buffer: *const cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn xcb_screen_allowed_depths_length(R: *const xcb_screen_t) -> cty::c_int;
}
extern "C" {
    pub fn xcb_screen_allowed_depths_iterator(R: *const xcb_screen_t) -> xcb_depth_iterator_t;
}
extern "C" {
    pub fn xcb_screen_next(i: *mut xcb_screen_iterator_t);
}
extern "C" {
    pub fn xcb_screen_end(i: xcb_screen_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_setup_request_sizeof(_buffer: *const cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn xcb_setup_request_authorization_protocol_name(
        R: *const xcb_setup_request_t,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn xcb_setup_request_authorization_protocol_name_length(
        R: *const xcb_setup_request_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xcb_setup_request_authorization_protocol_name_end(
        R: *const xcb_setup_request_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_setup_request_authorization_protocol_data(
        R: *const xcb_setup_request_t,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn xcb_setup_request_authorization_protocol_data_length(
        R: *const xcb_setup_request_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xcb_setup_request_authorization_protocol_data_end(
        R: *const xcb_setup_request_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_setup_request_next(i: *mut xcb_setup_request_iterator_t);
}
extern "C" {
    pub fn xcb_setup_request_end(i: xcb_setup_request_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_setup_failed_sizeof(_buffer: *const cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn xcb_setup_failed_reason(R: *const xcb_setup_failed_t) -> *mut cty::c_char;
}
extern "C" {
    pub fn xcb_setup_failed_reason_length(R: *const xcb_setup_failed_t) -> cty::c_int;
}
extern "C" {
    pub fn xcb_setup_failed_reason_end(R: *const xcb_setup_failed_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_setup_failed_next(i: *mut xcb_setup_failed_iterator_t);
}
extern "C" {
    pub fn xcb_setup_failed_end(i: xcb_setup_failed_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_setup_authenticate_sizeof(_buffer: *const cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn xcb_setup_authenticate_reason(R: *const xcb_setup_authenticate_t) -> *mut cty::c_char;
}
extern "C" {
    pub fn xcb_setup_authenticate_reason_length(R: *const xcb_setup_authenticate_t) -> cty::c_int;
}
extern "C" {
    pub fn xcb_setup_authenticate_reason_end(
        R: *const xcb_setup_authenticate_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_setup_authenticate_next(i: *mut xcb_setup_authenticate_iterator_t);
}
extern "C" {
    pub fn xcb_setup_authenticate_end(
        i: xcb_setup_authenticate_iterator_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_setup_sizeof(_buffer: *const cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn xcb_setup_vendor(R: *const xcb_setup_t) -> *mut cty::c_char;
}
extern "C" {
    pub fn xcb_setup_vendor_length(R: *const xcb_setup_t) -> cty::c_int;
}
extern "C" {
    pub fn xcb_setup_vendor_end(R: *const xcb_setup_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_setup_pixmap_formats(R: *const xcb_setup_t) -> *mut xcb_format_t;
}
extern "C" {
    pub fn xcb_setup_pixmap_formats_length(R: *const xcb_setup_t) -> cty::c_int;
}
extern "C" {
    pub fn xcb_setup_pixmap_formats_iterator(R: *const xcb_setup_t) -> xcb_format_iterator_t;
}
extern "C" {
    pub fn xcb_setup_roots_length(R: *const xcb_setup_t) -> cty::c_int;
}
extern "C" {
    pub fn xcb_setup_roots_iterator(R: *const xcb_setup_t) -> xcb_screen_iterator_t;
}
extern "C" {
    pub fn xcb_setup_next(i: *mut xcb_setup_iterator_t);
}
extern "C" {
    pub fn xcb_setup_end(i: xcb_setup_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_client_message_data_next(i: *mut xcb_client_message_data_iterator_t);
}
extern "C" {
    pub fn xcb_client_message_data_end(
        i: xcb_client_message_data_iterator_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_create_window_value_list_serialize(
        _buffer: *mut *mut cty::c_void,
        value_mask: u32,
        _aux: *const xcb_create_window_value_list_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xcb_create_window_value_list_unpack(
        _buffer: *const cty::c_void,
        value_mask: u32,
        _aux: *mut xcb_create_window_value_list_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xcb_create_window_value_list_sizeof(
        _buffer: *const cty::c_void,
        value_mask: u32,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xcb_create_window_sizeof(_buffer: *const cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn xcb_create_window_checked(
        c: *mut xcb_connection_t,
        depth: u8,
        wid: xcb_window_t,
        parent: xcb_window_t,
        x: i16,
        y: i16,
        width: u16,
        height: u16,
        border_width: u16,
        _class: u16,
        visual: xcb_visualid_t,
        value_mask: u32,
        value_list: *const cty::c_void,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_window(
        c: *mut xcb_connection_t,
        depth: u8,
        wid: xcb_window_t,
        parent: xcb_window_t,
        x: i16,
        y: i16,
        width: u16,
        height: u16,
        border_width: u16,
        _class: u16,
        visual: xcb_visualid_t,
        value_mask: u32,
        value_list: *const cty::c_void,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_window_aux_checked(
        c: *mut xcb_connection_t,
        depth: u8,
        wid: xcb_window_t,
        parent: xcb_window_t,
        x: i16,
        y: i16,
        width: u16,
        height: u16,
        border_width: u16,
        _class: u16,
        visual: xcb_visualid_t,
        value_mask: u32,
        value_list: *const xcb_create_window_value_list_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_window_aux(
        c: *mut xcb_connection_t,
        depth: u8,
        wid: xcb_window_t,
        parent: xcb_window_t,
        x: i16,
        y: i16,
        width: u16,
        height: u16,
        border_width: u16,
        _class: u16,
        visual: xcb_visualid_t,
        value_mask: u32,
        value_list: *const xcb_create_window_value_list_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_window_value_list(R: *const xcb_create_window_request_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn xcb_change_window_attributes_value_list_serialize(
        _buffer: *mut *mut cty::c_void,
        value_mask: u32,
        _aux: *const xcb_change_window_attributes_value_list_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xcb_change_window_attributes_value_list_unpack(
        _buffer: *const cty::c_void,
        value_mask: u32,
        _aux: *mut xcb_change_window_attributes_value_list_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xcb_change_window_attributes_value_list_sizeof(
        _buffer: *const cty::c_void,
        value_mask: u32,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xcb_change_window_attributes_sizeof(_buffer: *const cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn xcb_change_window_attributes_checked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        value_mask: u32,
        value_list: *const cty::c_void,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_window_attributes(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        value_mask: u32,
        value_list: *const cty::c_void,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_window_attributes_aux_checked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        value_mask: u32,
        value_list: *const xcb_change_window_attributes_value_list_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_window_attributes_aux(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        value_mask: u32,
        value_list: *const xcb_change_window_attributes_value_list_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_window_attributes_value_list(
        R: *const xcb_change_window_attributes_request_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn xcb_get_window_attributes(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_get_window_attributes_cookie_t;
}
extern "C" {
    pub fn xcb_get_window_attributes_unchecked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_get_window_attributes_cookie_t;
}
extern "C" {
    pub fn xcb_get_window_attributes_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_window_attributes_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_window_attributes_reply_t;
}
extern "C" {
    pub fn xcb_destroy_window_checked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_destroy_window(c: *mut xcb_connection_t, window: xcb_window_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_destroy_subwindows_checked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_destroy_subwindows(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_save_set_checked(
        c: *mut xcb_connection_t,
        mode: u8,
        window: xcb_window_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_save_set(
        c: *mut xcb_connection_t,
        mode: u8,
        window: xcb_window_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_reparent_window_checked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        parent: xcb_window_t,
        x: i16,
        y: i16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_reparent_window(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        parent: xcb_window_t,
        x: i16,
        y: i16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_map_window_checked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_map_window(c: *mut xcb_connection_t, window: xcb_window_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_map_subwindows_checked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_map_subwindows(c: *mut xcb_connection_t, window: xcb_window_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_unmap_window_checked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_unmap_window(c: *mut xcb_connection_t, window: xcb_window_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_unmap_subwindows_checked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_unmap_subwindows(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_configure_window_value_list_serialize(
        _buffer: *mut *mut cty::c_void,
        value_mask: u16,
        _aux: *const xcb_configure_window_value_list_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xcb_configure_window_value_list_unpack(
        _buffer: *const cty::c_void,
        value_mask: u16,
        _aux: *mut xcb_configure_window_value_list_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xcb_configure_window_value_list_sizeof(
        _buffer: *const cty::c_void,
        value_mask: u16,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xcb_configure_window_sizeof(_buffer: *const cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn xcb_configure_window_checked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        value_mask: u16,
        value_list: *const cty::c_void,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_configure_window(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        value_mask: u16,
        value_list: *const cty::c_void,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_configure_window_aux_checked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        value_mask: u16,
        value_list: *const xcb_configure_window_value_list_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_configure_window_aux(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        value_mask: u16,
        value_list: *const xcb_configure_window_value_list_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_configure_window_value_list(
        R: *const xcb_configure_window_request_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn xcb_circulate_window_checked(
        c: *mut xcb_connection_t,
        direction: u8,
        window: xcb_window_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_circulate_window(
        c: *mut xcb_connection_t,
        direction: u8,
        window: xcb_window_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_get_geometry(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
    ) -> xcb_get_geometry_cookie_t;
}
extern "C" {
    pub fn xcb_get_geometry_unchecked(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
    ) -> xcb_get_geometry_cookie_t;
}
extern "C" {
    pub fn xcb_get_geometry_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_geometry_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_geometry_reply_t;
}
extern "C" {
    pub fn xcb_query_tree_sizeof(_buffer: *const cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn xcb_query_tree(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_query_tree_cookie_t;
}
extern "C" {
    pub fn xcb_query_tree_unchecked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_query_tree_cookie_t;
}
extern "C" {
    pub fn xcb_query_tree_children(R: *const xcb_query_tree_reply_t) -> *mut xcb_window_t;
}
extern "C" {
    pub fn xcb_query_tree_children_length(R: *const xcb_query_tree_reply_t) -> cty::c_int;
}
extern "C" {
    pub fn xcb_query_tree_children_end(R: *const xcb_query_tree_reply_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_query_tree_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_query_tree_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_query_tree_reply_t;
}
extern "C" {
    pub fn xcb_intern_atom_sizeof(_buffer: *const cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn xcb_intern_atom(
        c: *mut xcb_connection_t,
        only_if_exists: u8,
        name_len: u16,
        name: *const cty::c_char,
    ) -> xcb_intern_atom_cookie_t;
}
extern "C" {
    pub fn xcb_intern_atom_unchecked(
        c: *mut xcb_connection_t,
        only_if_exists: u8,
        name_len: u16,
        name: *const cty::c_char,
    ) -> xcb_intern_atom_cookie_t;
}
extern "C" {
    pub fn xcb_intern_atom_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_intern_atom_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_intern_atom_reply_t;
}
extern "C" {
    pub fn xcb_get_atom_name_sizeof(_buffer: *const cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn xcb_get_atom_name(
        c: *mut xcb_connection_t,
        atom: xcb_atom_t,
    ) -> xcb_get_atom_name_cookie_t;
}
extern "C" {
    pub fn xcb_get_atom_name_unchecked(
        c: *mut xcb_connection_t,
        atom: xcb_atom_t,
    ) -> xcb_get_atom_name_cookie_t;
}
extern "C" {
    pub fn xcb_get_atom_name_name(R: *const xcb_get_atom_name_reply_t) -> *mut cty::c_char;
}
extern "C" {
    pub fn xcb_get_atom_name_name_length(R: *const xcb_get_atom_name_reply_t) -> cty::c_int;
}
extern "C" {
    pub fn xcb_get_atom_name_name_end(
        R: *const xcb_get_atom_name_reply_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_get_atom_name_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_atom_name_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_atom_name_reply_t;
}
extern "C" {
    pub fn xcb_change_property_sizeof(_buffer: *const cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn xcb_change_property_checked(
        c: *mut xcb_connection_t,
        mode: u8,
        window: xcb_window_t,
        property: xcb_atom_t,
        type_: xcb_atom_t,
        format: u8,
        data_len: u32,
        data: *const cty::c_void,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_property(
        c: *mut xcb_connection_t,
        mode: u8,
        window: xcb_window_t,
        property: xcb_atom_t,
        type_: xcb_atom_t,
        format: u8,
        data_len: u32,
        data: *const cty::c_void,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_property_data(R: *const xcb_change_property_request_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn xcb_change_property_data_length(R: *const xcb_change_property_request_t) -> cty::c_int;
}
extern "C" {
    pub fn xcb_change_property_data_end(
        R: *const xcb_change_property_request_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_delete_property_checked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        property: xcb_atom_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_delete_property(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        property: xcb_atom_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_get_property_sizeof(_buffer: *const cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn xcb_get_property(
        c: *mut xcb_connection_t,
        _delete: u8,
        window: xcb_window_t,
        property: xcb_atom_t,
        type_: xcb_atom_t,
        long_offset: u32,
        long_length: u32,
    ) -> xcb_get_property_cookie_t;
}
extern "C" {
    pub fn xcb_get_property_unchecked(
        c: *mut xcb_connection_t,
        _delete: u8,
        window: xcb_window_t,
        property: xcb_atom_t,
        type_: xcb_atom_t,
        long_offset: u32,
        long_length: u32,
    ) -> xcb_get_property_cookie_t;
}
extern "C" {
    pub fn xcb_get_property_value(R: *const xcb_get_property_reply_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn xcb_get_property_value_length(R: *const xcb_get_property_reply_t) -> cty::c_int;
}
extern "C" {
    pub fn xcb_get_property_value_end(R: *const xcb_get_property_reply_t)
        -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_get_property_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_property_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_property_reply_t;
}
extern "C" {
    pub fn xcb_list_properties_sizeof(_buffer: *const cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn xcb_list_properties(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_list_properties_cookie_t;
}
extern "C" {
    pub fn xcb_list_properties_unchecked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_list_properties_cookie_t;
}
extern "C" {
    pub fn xcb_list_properties_atoms(R: *const xcb_list_properties_reply_t) -> *mut xcb_atom_t;
}
extern "C" {
    pub fn xcb_list_properties_atoms_length(R: *const xcb_list_properties_reply_t) -> cty::c_int;
}
extern "C" {
    pub fn xcb_list_properties_atoms_end(
        R: *const xcb_list_properties_reply_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_list_properties_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_list_properties_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_list_properties_reply_t;
}
extern "C" {
    pub fn xcb_set_selection_owner_checked(
        c: *mut xcb_connection_t,
        owner: xcb_window_t,
        selection: xcb_atom_t,
        time: xcb_timestamp_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_selection_owner(
        c: *mut xcb_connection_t,
        owner: xcb_window_t,
        selection: xcb_atom_t,
        time: xcb_timestamp_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_get_selection_owner(
        c: *mut xcb_connection_t,
        selection: xcb_atom_t,
    ) -> xcb_get_selection_owner_cookie_t;
}
extern "C" {
    pub fn xcb_get_selection_owner_unchecked(
        c: *mut xcb_connection_t,
        selection: xcb_atom_t,
    ) -> xcb_get_selection_owner_cookie_t;
}
extern "C" {
    pub fn xcb_get_selection_owner_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_selection_owner_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_selection_owner_reply_t;
}
extern "C" {
    pub fn xcb_convert_selection_checked(
        c: *mut xcb_connection_t,
        requestor: xcb_window_t,
        selection: xcb_atom_t,
        target: xcb_atom_t,
        property: xcb_atom_t,
        time: xcb_timestamp_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_convert_selection(
        c: *mut xcb_connection_t,
        requestor: xcb_window_t,
        selection: xcb_atom_t,
        target: xcb_atom_t,
        property: xcb_atom_t,
        time: xcb_timestamp_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_send_event_checked(
        c: *mut xcb_connection_t,
        propagate: u8,
        destination: xcb_window_t,
        event_mask: u32,
        event: *const cty::c_char,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_send_event(
        c: *mut xcb_connection_t,
        propagate: u8,
        destination: xcb_window_t,
        event_mask: u32,
        event: *const cty::c_char,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_grab_pointer(
        c: *mut xcb_connection_t,
        owner_events: u8,
        grab_window: xcb_window_t,
        event_mask: u16,
        pointer_mode: u8,
        keyboard_mode: u8,
        confine_to: xcb_window_t,
        cursor: xcb_cursor_t,
        time: xcb_timestamp_t,
    ) -> xcb_grab_pointer_cookie_t;
}
extern "C" {
    pub fn xcb_grab_pointer_unchecked(
        c: *mut xcb_connection_t,
        owner_events: u8,
        grab_window: xcb_window_t,
        event_mask: u16,
        pointer_mode: u8,
        keyboard_mode: u8,
        confine_to: xcb_window_t,
        cursor: xcb_cursor_t,
        time: xcb_timestamp_t,
    ) -> xcb_grab_pointer_cookie_t;
}
extern "C" {
    pub fn xcb_grab_pointer_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_grab_pointer_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_grab_pointer_reply_t;
}
extern "C" {
    pub fn xcb_ungrab_pointer_checked(
        c: *mut xcb_connection_t,
        time: xcb_timestamp_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_ungrab_pointer(c: *mut xcb_connection_t, time: xcb_timestamp_t)
        -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_grab_button_checked(
        c: *mut xcb_connection_t,
        owner_events: u8,
        grab_window: xcb_window_t,
        event_mask: u16,
        pointer_mode: u8,
        keyboard_mode: u8,
        confine_to: xcb_window_t,
        cursor: xcb_cursor_t,
        button: u8,
        modifiers: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_grab_button(
        c: *mut xcb_connection_t,
        owner_events: u8,
        grab_window: xcb_window_t,
        event_mask: u16,
        pointer_mode: u8,
        keyboard_mode: u8,
        confine_to: xcb_window_t,
        cursor: xcb_cursor_t,
        button: u8,
        modifiers: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_ungrab_button_checked(
        c: *mut xcb_connection_t,
        button: u8,
        grab_window: xcb_window_t,
        modifiers: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_ungrab_button(
        c: *mut xcb_connection_t,
        button: u8,
        grab_window: xcb_window_t,
        modifiers: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_active_pointer_grab_checked(
        c: *mut xcb_connection_t,
        cursor: xcb_cursor_t,
        time: xcb_timestamp_t,
        event_mask: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_active_pointer_grab(
        c: *mut xcb_connection_t,
        cursor: xcb_cursor_t,
        time: xcb_timestamp_t,
        event_mask: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_grab_keyboard(
        c: *mut xcb_connection_t,
        owner_events: u8,
        grab_window: xcb_window_t,
        time: xcb_timestamp_t,
        pointer_mode: u8,
        keyboard_mode: u8,
    ) -> xcb_grab_keyboard_cookie_t;
}
extern "C" {
    pub fn xcb_grab_keyboard_unchecked(
        c: *mut xcb_connection_t,
        owner_events: u8,
        grab_window: xcb_window_t,
        time: xcb_timestamp_t,
        pointer_mode: u8,
        keyboard_mode: u8,
    ) -> xcb_grab_keyboard_cookie_t;
}
extern "C" {
    pub fn xcb_grab_keyboard_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_grab_keyboard_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_grab_keyboard_reply_t;
}
extern "C" {
    pub fn xcb_ungrab_keyboard_checked(
        c: *mut xcb_connection_t,
        time: xcb_timestamp_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_ungrab_keyboard(
        c: *mut xcb_connection_t,
        time: xcb_timestamp_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_grab_key_checked(
        c: *mut xcb_connection_t,
        owner_events: u8,
        grab_window: xcb_window_t,
        modifiers: u16,
        key: xcb_keycode_t,
        pointer_mode: u8,
        keyboard_mode: u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_grab_key(
        c: *mut xcb_connection_t,
        owner_events: u8,
        grab_window: xcb_window_t,
        modifiers: u16,
        key: xcb_keycode_t,
        pointer_mode: u8,
        keyboard_mode: u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_ungrab_key_checked(
        c: *mut xcb_connection_t,
        key: xcb_keycode_t,
        grab_window: xcb_window_t,
        modifiers: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_ungrab_key(
        c: *mut xcb_connection_t,
        key: xcb_keycode_t,
        grab_window: xcb_window_t,
        modifiers: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_allow_events_checked(
        c: *mut xcb_connection_t,
        mode: u8,
        time: xcb_timestamp_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_allow_events(
        c: *mut xcb_connection_t,
        mode: u8,
        time: xcb_timestamp_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_grab_server_checked(c: *mut xcb_connection_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_grab_server(c: *mut xcb_connection_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_ungrab_server_checked(c: *mut xcb_connection_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_ungrab_server(c: *mut xcb_connection_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_query_pointer(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_query_pointer_cookie_t;
}
extern "C" {
    pub fn xcb_query_pointer_unchecked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_query_pointer_cookie_t;
}
extern "C" {
    pub fn xcb_query_pointer_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_query_pointer_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_query_pointer_reply_t;
}
extern "C" {
    pub fn xcb_timecoord_next(i: *mut xcb_timecoord_iterator_t);
}
extern "C" {
    pub fn xcb_timecoord_end(i: xcb_timecoord_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_get_motion_events_sizeof(_buffer: *const cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn xcb_get_motion_events(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        start: xcb_timestamp_t,
        stop: xcb_timestamp_t,
    ) -> xcb_get_motion_events_cookie_t;
}
extern "C" {
    pub fn xcb_get_motion_events_unchecked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        start: xcb_timestamp_t,
        stop: xcb_timestamp_t,
    ) -> xcb_get_motion_events_cookie_t;
}
extern "C" {
    pub fn xcb_get_motion_events_events(
        R: *const xcb_get_motion_events_reply_t,
    ) -> *mut xcb_timecoord_t;
}
extern "C" {
    pub fn xcb_get_motion_events_events_length(
        R: *const xcb_get_motion_events_reply_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xcb_get_motion_events_events_iterator(
        R: *const xcb_get_motion_events_reply_t,
    ) -> xcb_timecoord_iterator_t;
}
extern "C" {
    pub fn xcb_get_motion_events_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_motion_events_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_motion_events_reply_t;
}
extern "C" {
    pub fn xcb_translate_coordinates(
        c: *mut xcb_connection_t,
        src_window: xcb_window_t,
        dst_window: xcb_window_t,
        src_x: i16,
        src_y: i16,
    ) -> xcb_translate_coordinates_cookie_t;
}
extern "C" {
    pub fn xcb_translate_coordinates_unchecked(
        c: *mut xcb_connection_t,
        src_window: xcb_window_t,
        dst_window: xcb_window_t,
        src_x: i16,
        src_y: i16,
    ) -> xcb_translate_coordinates_cookie_t;
}
extern "C" {
    pub fn xcb_translate_coordinates_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_translate_coordinates_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_translate_coordinates_reply_t;
}
extern "C" {
    pub fn xcb_warp_pointer_checked(
        c: *mut xcb_connection_t,
        src_window: xcb_window_t,
        dst_window: xcb_window_t,
        src_x: i16,
        src_y: i16,
        src_width: u16,
        src_height: u16,
        dst_x: i16,
        dst_y: i16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_warp_pointer(
        c: *mut xcb_connection_t,
        src_window: xcb_window_t,
        dst_window: xcb_window_t,
        src_x: i16,
        src_y: i16,
        src_width: u16,
        src_height: u16,
        dst_x: i16,
        dst_y: i16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_input_focus_checked(
        c: *mut xcb_connection_t,
        revert_to: u8,
        focus: xcb_window_t,
        time: xcb_timestamp_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_input_focus(
        c: *mut xcb_connection_t,
        revert_to: u8,
        focus: xcb_window_t,
        time: xcb_timestamp_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_get_input_focus(c: *mut xcb_connection_t) -> xcb_get_input_focus_cookie_t;
}
extern "C" {
    pub fn xcb_get_input_focus_unchecked(c: *mut xcb_connection_t) -> xcb_get_input_focus_cookie_t;
}
extern "C" {
    pub fn xcb_get_input_focus_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_input_focus_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_input_focus_reply_t;
}
extern "C" {
    pub fn xcb_query_keymap(c: *mut xcb_connection_t) -> xcb_query_keymap_cookie_t;
}
extern "C" {
    pub fn xcb_query_keymap_unchecked(c: *mut xcb_connection_t) -> xcb_query_keymap_cookie_t;
}
extern "C" {
    pub fn xcb_query_keymap_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_query_keymap_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_query_keymap_reply_t;
}
extern "C" {
    pub fn xcb_open_font_sizeof(_buffer: *const cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn xcb_open_font_checked(
        c: *mut xcb_connection_t,
        fid: xcb_font_t,
        name_len: u16,
        name: *const cty::c_char,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_open_font(
        c: *mut xcb_connection_t,
        fid: xcb_font_t,
        name_len: u16,
        name: *const cty::c_char,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_open_font_name(R: *const xcb_open_font_request_t) -> *mut cty::c_char;
}
extern "C" {
    pub fn xcb_open_font_name_length(R: *const xcb_open_font_request_t) -> cty::c_int;
}
extern "C" {
    pub fn xcb_open_font_name_end(R: *const xcb_open_font_request_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_close_font_checked(c: *mut xcb_connection_t, font: xcb_font_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_close_font(c: *mut xcb_connection_t, font: xcb_font_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_fontprop_next(i: *mut xcb_fontprop_iterator_t);
}
extern "C" {
    pub fn xcb_fontprop_end(i: xcb_fontprop_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_charinfo_next(i: *mut xcb_charinfo_iterator_t);
}
extern "C" {
    pub fn xcb_charinfo_end(i: xcb_charinfo_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_query_font_sizeof(_buffer: *const cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn xcb_query_font(
        c: *mut xcb_connection_t,
        font: xcb_fontable_t,
    ) -> xcb_query_font_cookie_t;
}
extern "C" {
    pub fn xcb_query_font_unchecked(
        c: *mut xcb_connection_t,
        font: xcb_fontable_t,
    ) -> xcb_query_font_cookie_t;
}
extern "C" {
    pub fn xcb_query_font_properties(R: *const xcb_query_font_reply_t) -> *mut xcb_fontprop_t;
}
extern "C" {
    pub fn xcb_query_font_properties_length(R: *const xcb_query_font_reply_t) -> cty::c_int;
}
extern "C" {
    pub fn xcb_query_font_properties_iterator(
        R: *const xcb_query_font_reply_t,
    ) -> xcb_fontprop_iterator_t;
}
extern "C" {
    pub fn xcb_query_font_char_infos(R: *const xcb_query_font_reply_t) -> *mut xcb_charinfo_t;
}
extern "C" {
    pub fn xcb_query_font_char_infos_length(R: *const xcb_query_font_reply_t) -> cty::c_int;
}
extern "C" {
    pub fn xcb_query_font_char_infos_iterator(
        R: *const xcb_query_font_reply_t,
    ) -> xcb_charinfo_iterator_t;
}
extern "C" {
    pub fn xcb_query_font_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_query_font_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_query_font_reply_t;
}
extern "C" {
    pub fn xcb_query_text_extents_sizeof(
        _buffer: *const cty::c_void,
        string_len: u32,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xcb_query_text_extents(
        c: *mut xcb_connection_t,
        font: xcb_fontable_t,
        string_len: u32,
        string: *const xcb_char2b_t,
    ) -> xcb_query_text_extents_cookie_t;
}
extern "C" {
    pub fn xcb_query_text_extents_unchecked(
        c: *mut xcb_connection_t,
        font: xcb_fontable_t,
        string_len: u32,
        string: *const xcb_char2b_t,
    ) -> xcb_query_text_extents_cookie_t;
}
extern "C" {
    pub fn xcb_query_text_extents_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_query_text_extents_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_query_text_extents_reply_t;
}
extern "C" {
    pub fn xcb_str_sizeof(_buffer: *const cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn xcb_str_name(R: *const xcb_str_t) -> *mut cty::c_char;
}
extern "C" {
    pub fn xcb_str_name_length(R: *const xcb_str_t) -> cty::c_int;
}
extern "C" {
    pub fn xcb_str_name_end(R: *const xcb_str_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_str_next(i: *mut xcb_str_iterator_t);
}
extern "C" {
    pub fn xcb_str_end(i: xcb_str_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_list_fonts_sizeof(_buffer: *const cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn xcb_list_fonts(
        c: *mut xcb_connection_t,
        max_names: u16,
        pattern_len: u16,
        pattern: *const cty::c_char,
    ) -> xcb_list_fonts_cookie_t;
}
extern "C" {
    pub fn xcb_list_fonts_unchecked(
        c: *mut xcb_connection_t,
        max_names: u16,
        pattern_len: u16,
        pattern: *const cty::c_char,
    ) -> xcb_list_fonts_cookie_t;
}
extern "C" {
    pub fn xcb_list_fonts_names_length(R: *const xcb_list_fonts_reply_t) -> cty::c_int;
}
extern "C" {
    pub fn xcb_list_fonts_names_iterator(R: *const xcb_list_fonts_reply_t) -> xcb_str_iterator_t;
}
extern "C" {
    pub fn xcb_list_fonts_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_list_fonts_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_list_fonts_reply_t;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_sizeof(_buffer: *const cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn xcb_list_fonts_with_info(
        c: *mut xcb_connection_t,
        max_names: u16,
        pattern_len: u16,
        pattern: *const cty::c_char,
    ) -> xcb_list_fonts_with_info_cookie_t;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_unchecked(
        c: *mut xcb_connection_t,
        max_names: u16,
        pattern_len: u16,
        pattern: *const cty::c_char,
    ) -> xcb_list_fonts_with_info_cookie_t;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_properties(
        R: *const xcb_list_fonts_with_info_reply_t,
    ) -> *mut xcb_fontprop_t;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_properties_length(
        R: *const xcb_list_fonts_with_info_reply_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_properties_iterator(
        R: *const xcb_list_fonts_with_info_reply_t,
    ) -> xcb_fontprop_iterator_t;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_name(
        R: *const xcb_list_fonts_with_info_reply_t,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_name_length(
        R: *const xcb_list_fonts_with_info_reply_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_name_end(
        R: *const xcb_list_fonts_with_info_reply_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_list_fonts_with_info_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_list_fonts_with_info_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_list_fonts_with_info_reply_t;
}
extern "C" {
    pub fn xcb_set_font_path_sizeof(_buffer: *const cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn xcb_set_font_path_checked(
        c: *mut xcb_connection_t,
        font_qty: u16,
        font: *const xcb_str_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_font_path(
        c: *mut xcb_connection_t,
        font_qty: u16,
        font: *const xcb_str_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_font_path_font_length(R: *const xcb_set_font_path_request_t) -> cty::c_int;
}
extern "C" {
    pub fn xcb_set_font_path_font_iterator(
        R: *const xcb_set_font_path_request_t,
    ) -> xcb_str_iterator_t;
}
extern "C" {
    pub fn xcb_get_font_path_sizeof(_buffer: *const cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn xcb_get_font_path(c: *mut xcb_connection_t) -> xcb_get_font_path_cookie_t;
}
extern "C" {
    pub fn xcb_get_font_path_unchecked(c: *mut xcb_connection_t) -> xcb_get_font_path_cookie_t;
}
extern "C" {
    pub fn xcb_get_font_path_path_length(R: *const xcb_get_font_path_reply_t) -> cty::c_int;
}
extern "C" {
    pub fn xcb_get_font_path_path_iterator(
        R: *const xcb_get_font_path_reply_t,
    ) -> xcb_str_iterator_t;
}
extern "C" {
    pub fn xcb_get_font_path_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_font_path_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_font_path_reply_t;
}
extern "C" {
    pub fn xcb_create_pixmap_checked(
        c: *mut xcb_connection_t,
        depth: u8,
        pid: xcb_pixmap_t,
        drawable: xcb_drawable_t,
        width: u16,
        height: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_pixmap(
        c: *mut xcb_connection_t,
        depth: u8,
        pid: xcb_pixmap_t,
        drawable: xcb_drawable_t,
        width: u16,
        height: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_free_pixmap_checked(
        c: *mut xcb_connection_t,
        pixmap: xcb_pixmap_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_free_pixmap(c: *mut xcb_connection_t, pixmap: xcb_pixmap_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_gc_value_list_serialize(
        _buffer: *mut *mut cty::c_void,
        value_mask: u32,
        _aux: *const xcb_create_gc_value_list_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xcb_create_gc_value_list_unpack(
        _buffer: *const cty::c_void,
        value_mask: u32,
        _aux: *mut xcb_create_gc_value_list_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xcb_create_gc_value_list_sizeof(
        _buffer: *const cty::c_void,
        value_mask: u32,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xcb_create_gc_sizeof(_buffer: *const cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn xcb_create_gc_checked(
        c: *mut xcb_connection_t,
        cid: xcb_gcontext_t,
        drawable: xcb_drawable_t,
        value_mask: u32,
        value_list: *const cty::c_void,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_gc(
        c: *mut xcb_connection_t,
        cid: xcb_gcontext_t,
        drawable: xcb_drawable_t,
        value_mask: u32,
        value_list: *const cty::c_void,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_gc_aux_checked(
        c: *mut xcb_connection_t,
        cid: xcb_gcontext_t,
        drawable: xcb_drawable_t,
        value_mask: u32,
        value_list: *const xcb_create_gc_value_list_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_gc_aux(
        c: *mut xcb_connection_t,
        cid: xcb_gcontext_t,
        drawable: xcb_drawable_t,
        value_mask: u32,
        value_list: *const xcb_create_gc_value_list_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_gc_value_list(R: *const xcb_create_gc_request_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn xcb_change_gc_value_list_serialize(
        _buffer: *mut *mut cty::c_void,
        value_mask: u32,
        _aux: *const xcb_change_gc_value_list_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xcb_change_gc_value_list_unpack(
        _buffer: *const cty::c_void,
        value_mask: u32,
        _aux: *mut xcb_change_gc_value_list_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xcb_change_gc_value_list_sizeof(
        _buffer: *const cty::c_void,
        value_mask: u32,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xcb_change_gc_sizeof(_buffer: *const cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn xcb_change_gc_checked(
        c: *mut xcb_connection_t,
        gc: xcb_gcontext_t,
        value_mask: u32,
        value_list: *const cty::c_void,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_gc(
        c: *mut xcb_connection_t,
        gc: xcb_gcontext_t,
        value_mask: u32,
        value_list: *const cty::c_void,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_gc_aux_checked(
        c: *mut xcb_connection_t,
        gc: xcb_gcontext_t,
        value_mask: u32,
        value_list: *const xcb_change_gc_value_list_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_gc_aux(
        c: *mut xcb_connection_t,
        gc: xcb_gcontext_t,
        value_mask: u32,
        value_list: *const xcb_change_gc_value_list_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_gc_value_list(R: *const xcb_change_gc_request_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn xcb_copy_gc_checked(
        c: *mut xcb_connection_t,
        src_gc: xcb_gcontext_t,
        dst_gc: xcb_gcontext_t,
        value_mask: u32,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_copy_gc(
        c: *mut xcb_connection_t,
        src_gc: xcb_gcontext_t,
        dst_gc: xcb_gcontext_t,
        value_mask: u32,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_dashes_sizeof(_buffer: *const cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn xcb_set_dashes_checked(
        c: *mut xcb_connection_t,
        gc: xcb_gcontext_t,
        dash_offset: u16,
        dashes_len: u16,
        dashes: *const u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_dashes(
        c: *mut xcb_connection_t,
        gc: xcb_gcontext_t,
        dash_offset: u16,
        dashes_len: u16,
        dashes: *const u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_dashes_dashes(R: *const xcb_set_dashes_request_t) -> *mut u8;
}
extern "C" {
    pub fn xcb_set_dashes_dashes_length(R: *const xcb_set_dashes_request_t) -> cty::c_int;
}
extern "C" {
    pub fn xcb_set_dashes_dashes_end(R: *const xcb_set_dashes_request_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_set_clip_rectangles_sizeof(
        _buffer: *const cty::c_void,
        rectangles_len: u32,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xcb_set_clip_rectangles_checked(
        c: *mut xcb_connection_t,
        ordering: u8,
        gc: xcb_gcontext_t,
        clip_x_origin: i16,
        clip_y_origin: i16,
        rectangles_len: u32,
        rectangles: *const xcb_rectangle_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_clip_rectangles(
        c: *mut xcb_connection_t,
        ordering: u8,
        gc: xcb_gcontext_t,
        clip_x_origin: i16,
        clip_y_origin: i16,
        rectangles_len: u32,
        rectangles: *const xcb_rectangle_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_clip_rectangles_rectangles(
        R: *const xcb_set_clip_rectangles_request_t,
    ) -> *mut xcb_rectangle_t;
}
extern "C" {
    pub fn xcb_set_clip_rectangles_rectangles_length(
        R: *const xcb_set_clip_rectangles_request_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xcb_set_clip_rectangles_rectangles_iterator(
        R: *const xcb_set_clip_rectangles_request_t,
    ) -> xcb_rectangle_iterator_t;
}
extern "C" {
    pub fn xcb_free_gc_checked(c: *mut xcb_connection_t, gc: xcb_gcontext_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_free_gc(c: *mut xcb_connection_t, gc: xcb_gcontext_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_clear_area_checked(
        c: *mut xcb_connection_t,
        exposures: u8,
        window: xcb_window_t,
        x: i16,
        y: i16,
        width: u16,
        height: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_clear_area(
        c: *mut xcb_connection_t,
        exposures: u8,
        window: xcb_window_t,
        x: i16,
        y: i16,
        width: u16,
        height: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_copy_area_checked(
        c: *mut xcb_connection_t,
        src_drawable: xcb_drawable_t,
        dst_drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        src_x: i16,
        src_y: i16,
        dst_x: i16,
        dst_y: i16,
        width: u16,
        height: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_copy_area(
        c: *mut xcb_connection_t,
        src_drawable: xcb_drawable_t,
        dst_drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        src_x: i16,
        src_y: i16,
        dst_x: i16,
        dst_y: i16,
        width: u16,
        height: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_copy_plane_checked(
        c: *mut xcb_connection_t,
        src_drawable: xcb_drawable_t,
        dst_drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        src_x: i16,
        src_y: i16,
        dst_x: i16,
        dst_y: i16,
        width: u16,
        height: u16,
        bit_plane: u32,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_copy_plane(
        c: *mut xcb_connection_t,
        src_drawable: xcb_drawable_t,
        dst_drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        src_x: i16,
        src_y: i16,
        dst_x: i16,
        dst_y: i16,
        width: u16,
        height: u16,
        bit_plane: u32,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_point_sizeof(_buffer: *const cty::c_void, points_len: u32) -> cty::c_int;
}
extern "C" {
    pub fn xcb_poly_point_checked(
        c: *mut xcb_connection_t,
        coordinate_mode: u8,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        points_len: u32,
        points: *const xcb_point_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_point(
        c: *mut xcb_connection_t,
        coordinate_mode: u8,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        points_len: u32,
        points: *const xcb_point_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_point_points(R: *const xcb_poly_point_request_t) -> *mut xcb_point_t;
}
extern "C" {
    pub fn xcb_poly_point_points_length(R: *const xcb_poly_point_request_t) -> cty::c_int;
}
extern "C" {
    pub fn xcb_poly_point_points_iterator(
        R: *const xcb_poly_point_request_t,
    ) -> xcb_point_iterator_t;
}
extern "C" {
    pub fn xcb_poly_line_sizeof(_buffer: *const cty::c_void, points_len: u32) -> cty::c_int;
}
extern "C" {
    pub fn xcb_poly_line_checked(
        c: *mut xcb_connection_t,
        coordinate_mode: u8,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        points_len: u32,
        points: *const xcb_point_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_line(
        c: *mut xcb_connection_t,
        coordinate_mode: u8,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        points_len: u32,
        points: *const xcb_point_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_line_points(R: *const xcb_poly_line_request_t) -> *mut xcb_point_t;
}
extern "C" {
    pub fn xcb_poly_line_points_length(R: *const xcb_poly_line_request_t) -> cty::c_int;
}
extern "C" {
    pub fn xcb_poly_line_points_iterator(R: *const xcb_poly_line_request_t)
        -> xcb_point_iterator_t;
}
extern "C" {
    pub fn xcb_segment_next(i: *mut xcb_segment_iterator_t);
}
extern "C" {
    pub fn xcb_segment_end(i: xcb_segment_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_poly_segment_sizeof(_buffer: *const cty::c_void, segments_len: u32) -> cty::c_int;
}
extern "C" {
    pub fn xcb_poly_segment_checked(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        segments_len: u32,
        segments: *const xcb_segment_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_segment(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        segments_len: u32,
        segments: *const xcb_segment_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_segment_segments(R: *const xcb_poly_segment_request_t) -> *mut xcb_segment_t;
}
extern "C" {
    pub fn xcb_poly_segment_segments_length(R: *const xcb_poly_segment_request_t) -> cty::c_int;
}
extern "C" {
    pub fn xcb_poly_segment_segments_iterator(
        R: *const xcb_poly_segment_request_t,
    ) -> xcb_segment_iterator_t;
}
extern "C" {
    pub fn xcb_poly_rectangle_sizeof(
        _buffer: *const cty::c_void,
        rectangles_len: u32,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xcb_poly_rectangle_checked(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        rectangles_len: u32,
        rectangles: *const xcb_rectangle_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_rectangle(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        rectangles_len: u32,
        rectangles: *const xcb_rectangle_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_rectangle_rectangles(
        R: *const xcb_poly_rectangle_request_t,
    ) -> *mut xcb_rectangle_t;
}
extern "C" {
    pub fn xcb_poly_rectangle_rectangles_length(
        R: *const xcb_poly_rectangle_request_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xcb_poly_rectangle_rectangles_iterator(
        R: *const xcb_poly_rectangle_request_t,
    ) -> xcb_rectangle_iterator_t;
}
extern "C" {
    pub fn xcb_poly_arc_sizeof(_buffer: *const cty::c_void, arcs_len: u32) -> cty::c_int;
}
extern "C" {
    pub fn xcb_poly_arc_checked(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        arcs_len: u32,
        arcs: *const xcb_arc_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_arc(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        arcs_len: u32,
        arcs: *const xcb_arc_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_arc_arcs(R: *const xcb_poly_arc_request_t) -> *mut xcb_arc_t;
}
extern "C" {
    pub fn xcb_poly_arc_arcs_length(R: *const xcb_poly_arc_request_t) -> cty::c_int;
}
extern "C" {
    pub fn xcb_poly_arc_arcs_iterator(R: *const xcb_poly_arc_request_t) -> xcb_arc_iterator_t;
}
extern "C" {
    pub fn xcb_fill_poly_sizeof(_buffer: *const cty::c_void, points_len: u32) -> cty::c_int;
}
extern "C" {
    pub fn xcb_fill_poly_checked(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        shape: u8,
        coordinate_mode: u8,
        points_len: u32,
        points: *const xcb_point_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_fill_poly(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        shape: u8,
        coordinate_mode: u8,
        points_len: u32,
        points: *const xcb_point_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_fill_poly_points(R: *const xcb_fill_poly_request_t) -> *mut xcb_point_t;
}
extern "C" {
    pub fn xcb_fill_poly_points_length(R: *const xcb_fill_poly_request_t) -> cty::c_int;
}
extern "C" {
    pub fn xcb_fill_poly_points_iterator(R: *const xcb_fill_poly_request_t)
        -> xcb_point_iterator_t;
}
extern "C" {
    pub fn xcb_poly_fill_rectangle_sizeof(
        _buffer: *const cty::c_void,
        rectangles_len: u32,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xcb_poly_fill_rectangle_checked(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        rectangles_len: u32,
        rectangles: *const xcb_rectangle_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_fill_rectangle(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        rectangles_len: u32,
        rectangles: *const xcb_rectangle_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_fill_rectangle_rectangles(
        R: *const xcb_poly_fill_rectangle_request_t,
    ) -> *mut xcb_rectangle_t;
}
extern "C" {
    pub fn xcb_poly_fill_rectangle_rectangles_length(
        R: *const xcb_poly_fill_rectangle_request_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xcb_poly_fill_rectangle_rectangles_iterator(
        R: *const xcb_poly_fill_rectangle_request_t,
    ) -> xcb_rectangle_iterator_t;
}
extern "C" {
    pub fn xcb_poly_fill_arc_sizeof(_buffer: *const cty::c_void, arcs_len: u32) -> cty::c_int;
}
extern "C" {
    pub fn xcb_poly_fill_arc_checked(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        arcs_len: u32,
        arcs: *const xcb_arc_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_fill_arc(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        arcs_len: u32,
        arcs: *const xcb_arc_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_fill_arc_arcs(R: *const xcb_poly_fill_arc_request_t) -> *mut xcb_arc_t;
}
extern "C" {
    pub fn xcb_poly_fill_arc_arcs_length(R: *const xcb_poly_fill_arc_request_t) -> cty::c_int;
}
extern "C" {
    pub fn xcb_poly_fill_arc_arcs_iterator(
        R: *const xcb_poly_fill_arc_request_t,
    ) -> xcb_arc_iterator_t;
}
extern "C" {
    pub fn xcb_put_image_sizeof(_buffer: *const cty::c_void, data_len: u32) -> cty::c_int;
}
extern "C" {
    pub fn xcb_put_image_checked(
        c: *mut xcb_connection_t,
        format: u8,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        width: u16,
        height: u16,
        dst_x: i16,
        dst_y: i16,
        left_pad: u8,
        depth: u8,
        data_len: u32,
        data: *const u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_put_image(
        c: *mut xcb_connection_t,
        format: u8,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        width: u16,
        height: u16,
        dst_x: i16,
        dst_y: i16,
        left_pad: u8,
        depth: u8,
        data_len: u32,
        data: *const u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_put_image_data(R: *const xcb_put_image_request_t) -> *mut u8;
}
extern "C" {
    pub fn xcb_put_image_data_length(R: *const xcb_put_image_request_t) -> cty::c_int;
}
extern "C" {
    pub fn xcb_put_image_data_end(R: *const xcb_put_image_request_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_get_image_sizeof(_buffer: *const cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn xcb_get_image(
        c: *mut xcb_connection_t,
        format: u8,
        drawable: xcb_drawable_t,
        x: i16,
        y: i16,
        width: u16,
        height: u16,
        plane_mask: u32,
    ) -> xcb_get_image_cookie_t;
}
extern "C" {
    pub fn xcb_get_image_unchecked(
        c: *mut xcb_connection_t,
        format: u8,
        drawable: xcb_drawable_t,
        x: i16,
        y: i16,
        width: u16,
        height: u16,
        plane_mask: u32,
    ) -> xcb_get_image_cookie_t;
}
extern "C" {
    pub fn xcb_get_image_data(R: *const xcb_get_image_reply_t) -> *mut u8;
}
extern "C" {
    pub fn xcb_get_image_data_length(R: *const xcb_get_image_reply_t) -> cty::c_int;
}
extern "C" {
    pub fn xcb_get_image_data_end(R: *const xcb_get_image_reply_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_get_image_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_image_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_image_reply_t;
}
extern "C" {
    pub fn xcb_poly_text_8_sizeof(_buffer: *const cty::c_void, items_len: u32) -> cty::c_int;
}
extern "C" {
    pub fn xcb_poly_text_8_checked(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        x: i16,
        y: i16,
        items_len: u32,
        items: *const u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_text_8(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        x: i16,
        y: i16,
        items_len: u32,
        items: *const u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_text_8_items(R: *const xcb_poly_text_8_request_t) -> *mut u8;
}
extern "C" {
    pub fn xcb_poly_text_8_items_length(R: *const xcb_poly_text_8_request_t) -> cty::c_int;
}
extern "C" {
    pub fn xcb_poly_text_8_items_end(R: *const xcb_poly_text_8_request_t)
        -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_poly_text_16_sizeof(_buffer: *const cty::c_void, items_len: u32) -> cty::c_int;
}
extern "C" {
    pub fn xcb_poly_text_16_checked(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        x: i16,
        y: i16,
        items_len: u32,
        items: *const u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_text_16(
        c: *mut xcb_connection_t,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        x: i16,
        y: i16,
        items_len: u32,
        items: *const u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_poly_text_16_items(R: *const xcb_poly_text_16_request_t) -> *mut u8;
}
extern "C" {
    pub fn xcb_poly_text_16_items_length(R: *const xcb_poly_text_16_request_t) -> cty::c_int;
}
extern "C" {
    pub fn xcb_poly_text_16_items_end(
        R: *const xcb_poly_text_16_request_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_image_text_8_sizeof(_buffer: *const cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn xcb_image_text_8_checked(
        c: *mut xcb_connection_t,
        string_len: u8,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        x: i16,
        y: i16,
        string: *const cty::c_char,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_image_text_8(
        c: *mut xcb_connection_t,
        string_len: u8,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        x: i16,
        y: i16,
        string: *const cty::c_char,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_image_text_8_string(R: *const xcb_image_text_8_request_t) -> *mut cty::c_char;
}
extern "C" {
    pub fn xcb_image_text_8_string_length(R: *const xcb_image_text_8_request_t) -> cty::c_int;
}
extern "C" {
    pub fn xcb_image_text_8_string_end(
        R: *const xcb_image_text_8_request_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_image_text_16_sizeof(_buffer: *const cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn xcb_image_text_16_checked(
        c: *mut xcb_connection_t,
        string_len: u8,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        x: i16,
        y: i16,
        string: *const xcb_char2b_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_image_text_16(
        c: *mut xcb_connection_t,
        string_len: u8,
        drawable: xcb_drawable_t,
        gc: xcb_gcontext_t,
        x: i16,
        y: i16,
        string: *const xcb_char2b_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_image_text_16_string(R: *const xcb_image_text_16_request_t) -> *mut xcb_char2b_t;
}
extern "C" {
    pub fn xcb_image_text_16_string_length(R: *const xcb_image_text_16_request_t) -> cty::c_int;
}
extern "C" {
    pub fn xcb_image_text_16_string_iterator(
        R: *const xcb_image_text_16_request_t,
    ) -> xcb_char2b_iterator_t;
}
extern "C" {
    pub fn xcb_create_colormap_checked(
        c: *mut xcb_connection_t,
        alloc: u8,
        mid: xcb_colormap_t,
        window: xcb_window_t,
        visual: xcb_visualid_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_colormap(
        c: *mut xcb_connection_t,
        alloc: u8,
        mid: xcb_colormap_t,
        window: xcb_window_t,
        visual: xcb_visualid_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_free_colormap_checked(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_free_colormap(c: *mut xcb_connection_t, cmap: xcb_colormap_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_copy_colormap_and_free_checked(
        c: *mut xcb_connection_t,
        mid: xcb_colormap_t,
        src_cmap: xcb_colormap_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_copy_colormap_and_free(
        c: *mut xcb_connection_t,
        mid: xcb_colormap_t,
        src_cmap: xcb_colormap_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_install_colormap_checked(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_install_colormap(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_uninstall_colormap_checked(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_uninstall_colormap(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_list_installed_colormaps_sizeof(_buffer: *const cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn xcb_list_installed_colormaps(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_list_installed_colormaps_cookie_t;
}
extern "C" {
    pub fn xcb_list_installed_colormaps_unchecked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
    ) -> xcb_list_installed_colormaps_cookie_t;
}
extern "C" {
    pub fn xcb_list_installed_colormaps_cmaps(
        R: *const xcb_list_installed_colormaps_reply_t,
    ) -> *mut xcb_colormap_t;
}
extern "C" {
    pub fn xcb_list_installed_colormaps_cmaps_length(
        R: *const xcb_list_installed_colormaps_reply_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xcb_list_installed_colormaps_cmaps_end(
        R: *const xcb_list_installed_colormaps_reply_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_list_installed_colormaps_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_list_installed_colormaps_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_list_installed_colormaps_reply_t;
}
extern "C" {
    pub fn xcb_alloc_color(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
        red: u16,
        green: u16,
        blue: u16,
    ) -> xcb_alloc_color_cookie_t;
}
extern "C" {
    pub fn xcb_alloc_color_unchecked(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
        red: u16,
        green: u16,
        blue: u16,
    ) -> xcb_alloc_color_cookie_t;
}
extern "C" {
    pub fn xcb_alloc_color_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_alloc_color_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_alloc_color_reply_t;
}
extern "C" {
    pub fn xcb_alloc_named_color_sizeof(_buffer: *const cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn xcb_alloc_named_color(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
        name_len: u16,
        name: *const cty::c_char,
    ) -> xcb_alloc_named_color_cookie_t;
}
extern "C" {
    pub fn xcb_alloc_named_color_unchecked(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
        name_len: u16,
        name: *const cty::c_char,
    ) -> xcb_alloc_named_color_cookie_t;
}
extern "C" {
    pub fn xcb_alloc_named_color_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_alloc_named_color_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_alloc_named_color_reply_t;
}
extern "C" {
    pub fn xcb_alloc_color_cells_sizeof(_buffer: *const cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn xcb_alloc_color_cells(
        c: *mut xcb_connection_t,
        contiguous: u8,
        cmap: xcb_colormap_t,
        colors: u16,
        planes: u16,
    ) -> xcb_alloc_color_cells_cookie_t;
}
extern "C" {
    pub fn xcb_alloc_color_cells_unchecked(
        c: *mut xcb_connection_t,
        contiguous: u8,
        cmap: xcb_colormap_t,
        colors: u16,
        planes: u16,
    ) -> xcb_alloc_color_cells_cookie_t;
}
extern "C" {
    pub fn xcb_alloc_color_cells_pixels(R: *const xcb_alloc_color_cells_reply_t) -> *mut u32;
}
extern "C" {
    pub fn xcb_alloc_color_cells_pixels_length(
        R: *const xcb_alloc_color_cells_reply_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xcb_alloc_color_cells_pixels_end(
        R: *const xcb_alloc_color_cells_reply_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_alloc_color_cells_masks(R: *const xcb_alloc_color_cells_reply_t) -> *mut u32;
}
extern "C" {
    pub fn xcb_alloc_color_cells_masks_length(
        R: *const xcb_alloc_color_cells_reply_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xcb_alloc_color_cells_masks_end(
        R: *const xcb_alloc_color_cells_reply_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_alloc_color_cells_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_alloc_color_cells_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_alloc_color_cells_reply_t;
}
extern "C" {
    pub fn xcb_alloc_color_planes_sizeof(_buffer: *const cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn xcb_alloc_color_planes(
        c: *mut xcb_connection_t,
        contiguous: u8,
        cmap: xcb_colormap_t,
        colors: u16,
        reds: u16,
        greens: u16,
        blues: u16,
    ) -> xcb_alloc_color_planes_cookie_t;
}
extern "C" {
    pub fn xcb_alloc_color_planes_unchecked(
        c: *mut xcb_connection_t,
        contiguous: u8,
        cmap: xcb_colormap_t,
        colors: u16,
        reds: u16,
        greens: u16,
        blues: u16,
    ) -> xcb_alloc_color_planes_cookie_t;
}
extern "C" {
    pub fn xcb_alloc_color_planes_pixels(R: *const xcb_alloc_color_planes_reply_t) -> *mut u32;
}
extern "C" {
    pub fn xcb_alloc_color_planes_pixels_length(
        R: *const xcb_alloc_color_planes_reply_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xcb_alloc_color_planes_pixels_end(
        R: *const xcb_alloc_color_planes_reply_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_alloc_color_planes_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_alloc_color_planes_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_alloc_color_planes_reply_t;
}
extern "C" {
    pub fn xcb_free_colors_sizeof(_buffer: *const cty::c_void, pixels_len: u32) -> cty::c_int;
}
extern "C" {
    pub fn xcb_free_colors_checked(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
        plane_mask: u32,
        pixels_len: u32,
        pixels: *const u32,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_free_colors(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
        plane_mask: u32,
        pixels_len: u32,
        pixels: *const u32,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_free_colors_pixels(R: *const xcb_free_colors_request_t) -> *mut u32;
}
extern "C" {
    pub fn xcb_free_colors_pixels_length(R: *const xcb_free_colors_request_t) -> cty::c_int;
}
extern "C" {
    pub fn xcb_free_colors_pixels_end(
        R: *const xcb_free_colors_request_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_coloritem_next(i: *mut xcb_coloritem_iterator_t);
}
extern "C" {
    pub fn xcb_coloritem_end(i: xcb_coloritem_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_store_colors_sizeof(_buffer: *const cty::c_void, items_len: u32) -> cty::c_int;
}
extern "C" {
    pub fn xcb_store_colors_checked(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
        items_len: u32,
        items: *const xcb_coloritem_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_store_colors(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
        items_len: u32,
        items: *const xcb_coloritem_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_store_colors_items(R: *const xcb_store_colors_request_t) -> *mut xcb_coloritem_t;
}
extern "C" {
    pub fn xcb_store_colors_items_length(R: *const xcb_store_colors_request_t) -> cty::c_int;
}
extern "C" {
    pub fn xcb_store_colors_items_iterator(
        R: *const xcb_store_colors_request_t,
    ) -> xcb_coloritem_iterator_t;
}
extern "C" {
    pub fn xcb_store_named_color_sizeof(_buffer: *const cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn xcb_store_named_color_checked(
        c: *mut xcb_connection_t,
        flags: u8,
        cmap: xcb_colormap_t,
        pixel: u32,
        name_len: u16,
        name: *const cty::c_char,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_store_named_color(
        c: *mut xcb_connection_t,
        flags: u8,
        cmap: xcb_colormap_t,
        pixel: u32,
        name_len: u16,
        name: *const cty::c_char,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_store_named_color_name(
        R: *const xcb_store_named_color_request_t,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn xcb_store_named_color_name_length(
        R: *const xcb_store_named_color_request_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xcb_store_named_color_name_end(
        R: *const xcb_store_named_color_request_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_rgb_next(i: *mut xcb_rgb_iterator_t);
}
extern "C" {
    pub fn xcb_rgb_end(i: xcb_rgb_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_query_colors_sizeof(_buffer: *const cty::c_void, pixels_len: u32) -> cty::c_int;
}
extern "C" {
    pub fn xcb_query_colors(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
        pixels_len: u32,
        pixels: *const u32,
    ) -> xcb_query_colors_cookie_t;
}
extern "C" {
    pub fn xcb_query_colors_unchecked(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
        pixels_len: u32,
        pixels: *const u32,
    ) -> xcb_query_colors_cookie_t;
}
extern "C" {
    pub fn xcb_query_colors_colors(R: *const xcb_query_colors_reply_t) -> *mut xcb_rgb_t;
}
extern "C" {
    pub fn xcb_query_colors_colors_length(R: *const xcb_query_colors_reply_t) -> cty::c_int;
}
extern "C" {
    pub fn xcb_query_colors_colors_iterator(
        R: *const xcb_query_colors_reply_t,
    ) -> xcb_rgb_iterator_t;
}
extern "C" {
    pub fn xcb_query_colors_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_query_colors_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_query_colors_reply_t;
}
extern "C" {
    pub fn xcb_lookup_color_sizeof(_buffer: *const cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn xcb_lookup_color(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
        name_len: u16,
        name: *const cty::c_char,
    ) -> xcb_lookup_color_cookie_t;
}
extern "C" {
    pub fn xcb_lookup_color_unchecked(
        c: *mut xcb_connection_t,
        cmap: xcb_colormap_t,
        name_len: u16,
        name: *const cty::c_char,
    ) -> xcb_lookup_color_cookie_t;
}
extern "C" {
    pub fn xcb_lookup_color_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_lookup_color_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_lookup_color_reply_t;
}
extern "C" {
    pub fn xcb_create_cursor_checked(
        c: *mut xcb_connection_t,
        cid: xcb_cursor_t,
        source: xcb_pixmap_t,
        mask: xcb_pixmap_t,
        fore_red: u16,
        fore_green: u16,
        fore_blue: u16,
        back_red: u16,
        back_green: u16,
        back_blue: u16,
        x: u16,
        y: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_cursor(
        c: *mut xcb_connection_t,
        cid: xcb_cursor_t,
        source: xcb_pixmap_t,
        mask: xcb_pixmap_t,
        fore_red: u16,
        fore_green: u16,
        fore_blue: u16,
        back_red: u16,
        back_green: u16,
        back_blue: u16,
        x: u16,
        y: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_glyph_cursor_checked(
        c: *mut xcb_connection_t,
        cid: xcb_cursor_t,
        source_font: xcb_font_t,
        mask_font: xcb_font_t,
        source_char: u16,
        mask_char: u16,
        fore_red: u16,
        fore_green: u16,
        fore_blue: u16,
        back_red: u16,
        back_green: u16,
        back_blue: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_create_glyph_cursor(
        c: *mut xcb_connection_t,
        cid: xcb_cursor_t,
        source_font: xcb_font_t,
        mask_font: xcb_font_t,
        source_char: u16,
        mask_char: u16,
        fore_red: u16,
        fore_green: u16,
        fore_blue: u16,
        back_red: u16,
        back_green: u16,
        back_blue: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_free_cursor_checked(
        c: *mut xcb_connection_t,
        cursor: xcb_cursor_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_free_cursor(c: *mut xcb_connection_t, cursor: xcb_cursor_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_recolor_cursor_checked(
        c: *mut xcb_connection_t,
        cursor: xcb_cursor_t,
        fore_red: u16,
        fore_green: u16,
        fore_blue: u16,
        back_red: u16,
        back_green: u16,
        back_blue: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_recolor_cursor(
        c: *mut xcb_connection_t,
        cursor: xcb_cursor_t,
        fore_red: u16,
        fore_green: u16,
        fore_blue: u16,
        back_red: u16,
        back_green: u16,
        back_blue: u16,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_query_best_size(
        c: *mut xcb_connection_t,
        _class: u8,
        drawable: xcb_drawable_t,
        width: u16,
        height: u16,
    ) -> xcb_query_best_size_cookie_t;
}
extern "C" {
    pub fn xcb_query_best_size_unchecked(
        c: *mut xcb_connection_t,
        _class: u8,
        drawable: xcb_drawable_t,
        width: u16,
        height: u16,
    ) -> xcb_query_best_size_cookie_t;
}
extern "C" {
    pub fn xcb_query_best_size_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_query_best_size_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_query_best_size_reply_t;
}
extern "C" {
    pub fn xcb_query_extension_sizeof(_buffer: *const cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn xcb_query_extension(
        c: *mut xcb_connection_t,
        name_len: u16,
        name: *const cty::c_char,
    ) -> xcb_query_extension_cookie_t;
}
extern "C" {
    pub fn xcb_query_extension_unchecked(
        c: *mut xcb_connection_t,
        name_len: u16,
        name: *const cty::c_char,
    ) -> xcb_query_extension_cookie_t;
}
extern "C" {
    pub fn xcb_query_extension_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_query_extension_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_query_extension_reply_t;
}
extern "C" {
    pub fn xcb_list_extensions_sizeof(_buffer: *const cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn xcb_list_extensions(c: *mut xcb_connection_t) -> xcb_list_extensions_cookie_t;
}
extern "C" {
    pub fn xcb_list_extensions_unchecked(c: *mut xcb_connection_t) -> xcb_list_extensions_cookie_t;
}
extern "C" {
    pub fn xcb_list_extensions_names_length(R: *const xcb_list_extensions_reply_t) -> cty::c_int;
}
extern "C" {
    pub fn xcb_list_extensions_names_iterator(
        R: *const xcb_list_extensions_reply_t,
    ) -> xcb_str_iterator_t;
}
extern "C" {
    pub fn xcb_list_extensions_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_list_extensions_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_list_extensions_reply_t;
}
extern "C" {
    pub fn xcb_change_keyboard_mapping_sizeof(_buffer: *const cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn xcb_change_keyboard_mapping_checked(
        c: *mut xcb_connection_t,
        keycode_count: u8,
        first_keycode: xcb_keycode_t,
        keysyms_per_keycode: u8,
        keysyms: *const xcb_keysym_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_keyboard_mapping(
        c: *mut xcb_connection_t,
        keycode_count: u8,
        first_keycode: xcb_keycode_t,
        keysyms_per_keycode: u8,
        keysyms: *const xcb_keysym_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_keyboard_mapping_keysyms(
        R: *const xcb_change_keyboard_mapping_request_t,
    ) -> *mut xcb_keysym_t;
}
extern "C" {
    pub fn xcb_change_keyboard_mapping_keysyms_length(
        R: *const xcb_change_keyboard_mapping_request_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xcb_change_keyboard_mapping_keysyms_end(
        R: *const xcb_change_keyboard_mapping_request_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_get_keyboard_mapping_sizeof(_buffer: *const cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn xcb_get_keyboard_mapping(
        c: *mut xcb_connection_t,
        first_keycode: xcb_keycode_t,
        count: u8,
    ) -> xcb_get_keyboard_mapping_cookie_t;
}
extern "C" {
    pub fn xcb_get_keyboard_mapping_unchecked(
        c: *mut xcb_connection_t,
        first_keycode: xcb_keycode_t,
        count: u8,
    ) -> xcb_get_keyboard_mapping_cookie_t;
}
extern "C" {
    pub fn xcb_get_keyboard_mapping_keysyms(
        R: *const xcb_get_keyboard_mapping_reply_t,
    ) -> *mut xcb_keysym_t;
}
extern "C" {
    pub fn xcb_get_keyboard_mapping_keysyms_length(
        R: *const xcb_get_keyboard_mapping_reply_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xcb_get_keyboard_mapping_keysyms_end(
        R: *const xcb_get_keyboard_mapping_reply_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_get_keyboard_mapping_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_keyboard_mapping_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_keyboard_mapping_reply_t;
}
extern "C" {
    pub fn xcb_change_keyboard_control_value_list_serialize(
        _buffer: *mut *mut cty::c_void,
        value_mask: u32,
        _aux: *const xcb_change_keyboard_control_value_list_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xcb_change_keyboard_control_value_list_unpack(
        _buffer: *const cty::c_void,
        value_mask: u32,
        _aux: *mut xcb_change_keyboard_control_value_list_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xcb_change_keyboard_control_value_list_sizeof(
        _buffer: *const cty::c_void,
        value_mask: u32,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xcb_change_keyboard_control_sizeof(_buffer: *const cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn xcb_change_keyboard_control_checked(
        c: *mut xcb_connection_t,
        value_mask: u32,
        value_list: *const cty::c_void,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_keyboard_control(
        c: *mut xcb_connection_t,
        value_mask: u32,
        value_list: *const cty::c_void,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_keyboard_control_aux_checked(
        c: *mut xcb_connection_t,
        value_mask: u32,
        value_list: *const xcb_change_keyboard_control_value_list_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_keyboard_control_aux(
        c: *mut xcb_connection_t,
        value_mask: u32,
        value_list: *const xcb_change_keyboard_control_value_list_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_keyboard_control_value_list(
        R: *const xcb_change_keyboard_control_request_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn xcb_get_keyboard_control(c: *mut xcb_connection_t) -> xcb_get_keyboard_control_cookie_t;
}
extern "C" {
    pub fn xcb_get_keyboard_control_unchecked(
        c: *mut xcb_connection_t,
    ) -> xcb_get_keyboard_control_cookie_t;
}
extern "C" {
    pub fn xcb_get_keyboard_control_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_keyboard_control_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_keyboard_control_reply_t;
}
extern "C" {
    pub fn xcb_bell_checked(c: *mut xcb_connection_t, percent: i8) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_bell(c: *mut xcb_connection_t, percent: i8) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_pointer_control_checked(
        c: *mut xcb_connection_t,
        acceleration_numerator: i16,
        acceleration_denominator: i16,
        threshold: i16,
        do_acceleration: u8,
        do_threshold: u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_pointer_control(
        c: *mut xcb_connection_t,
        acceleration_numerator: i16,
        acceleration_denominator: i16,
        threshold: i16,
        do_acceleration: u8,
        do_threshold: u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_get_pointer_control(c: *mut xcb_connection_t) -> xcb_get_pointer_control_cookie_t;
}
extern "C" {
    pub fn xcb_get_pointer_control_unchecked(
        c: *mut xcb_connection_t,
    ) -> xcb_get_pointer_control_cookie_t;
}
extern "C" {
    pub fn xcb_get_pointer_control_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_pointer_control_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_pointer_control_reply_t;
}
extern "C" {
    pub fn xcb_set_screen_saver_checked(
        c: *mut xcb_connection_t,
        timeout: i16,
        interval: i16,
        prefer_blanking: u8,
        allow_exposures: u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_screen_saver(
        c: *mut xcb_connection_t,
        timeout: i16,
        interval: i16,
        prefer_blanking: u8,
        allow_exposures: u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_get_screen_saver(c: *mut xcb_connection_t) -> xcb_get_screen_saver_cookie_t;
}
extern "C" {
    pub fn xcb_get_screen_saver_unchecked(
        c: *mut xcb_connection_t,
    ) -> xcb_get_screen_saver_cookie_t;
}
extern "C" {
    pub fn xcb_get_screen_saver_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_screen_saver_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_screen_saver_reply_t;
}
extern "C" {
    pub fn xcb_change_hosts_sizeof(_buffer: *const cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn xcb_change_hosts_checked(
        c: *mut xcb_connection_t,
        mode: u8,
        family: u8,
        address_len: u16,
        address: *const u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_hosts(
        c: *mut xcb_connection_t,
        mode: u8,
        family: u8,
        address_len: u16,
        address: *const u8,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_change_hosts_address(R: *const xcb_change_hosts_request_t) -> *mut u8;
}
extern "C" {
    pub fn xcb_change_hosts_address_length(R: *const xcb_change_hosts_request_t) -> cty::c_int;
}
extern "C" {
    pub fn xcb_change_hosts_address_end(
        R: *const xcb_change_hosts_request_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_host_sizeof(_buffer: *const cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn xcb_host_address(R: *const xcb_host_t) -> *mut u8;
}
extern "C" {
    pub fn xcb_host_address_length(R: *const xcb_host_t) -> cty::c_int;
}
extern "C" {
    pub fn xcb_host_address_end(R: *const xcb_host_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_host_next(i: *mut xcb_host_iterator_t);
}
extern "C" {
    pub fn xcb_host_end(i: xcb_host_iterator_t) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_list_hosts_sizeof(_buffer: *const cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn xcb_list_hosts(c: *mut xcb_connection_t) -> xcb_list_hosts_cookie_t;
}
extern "C" {
    pub fn xcb_list_hosts_unchecked(c: *mut xcb_connection_t) -> xcb_list_hosts_cookie_t;
}
extern "C" {
    pub fn xcb_list_hosts_hosts_length(R: *const xcb_list_hosts_reply_t) -> cty::c_int;
}
extern "C" {
    pub fn xcb_list_hosts_hosts_iterator(R: *const xcb_list_hosts_reply_t) -> xcb_host_iterator_t;
}
extern "C" {
    pub fn xcb_list_hosts_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_list_hosts_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_list_hosts_reply_t;
}
extern "C" {
    pub fn xcb_set_access_control_checked(c: *mut xcb_connection_t, mode: u8) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_access_control(c: *mut xcb_connection_t, mode: u8) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_close_down_mode_checked(c: *mut xcb_connection_t, mode: u8)
        -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_close_down_mode(c: *mut xcb_connection_t, mode: u8) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_kill_client_checked(c: *mut xcb_connection_t, resource: u32) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_kill_client(c: *mut xcb_connection_t, resource: u32) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_rotate_properties_sizeof(_buffer: *const cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn xcb_rotate_properties_checked(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        atoms_len: u16,
        delta: i16,
        atoms: *const xcb_atom_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_rotate_properties(
        c: *mut xcb_connection_t,
        window: xcb_window_t,
        atoms_len: u16,
        delta: i16,
        atoms: *const xcb_atom_t,
    ) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_rotate_properties_atoms(
        R: *const xcb_rotate_properties_request_t,
    ) -> *mut xcb_atom_t;
}
extern "C" {
    pub fn xcb_rotate_properties_atoms_length(
        R: *const xcb_rotate_properties_request_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xcb_rotate_properties_atoms_end(
        R: *const xcb_rotate_properties_request_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_force_screen_saver_checked(c: *mut xcb_connection_t, mode: u8) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_force_screen_saver(c: *mut xcb_connection_t, mode: u8) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_set_pointer_mapping_sizeof(_buffer: *const cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn xcb_set_pointer_mapping(
        c: *mut xcb_connection_t,
        map_len: u8,
        map: *const u8,
    ) -> xcb_set_pointer_mapping_cookie_t;
}
extern "C" {
    pub fn xcb_set_pointer_mapping_unchecked(
        c: *mut xcb_connection_t,
        map_len: u8,
        map: *const u8,
    ) -> xcb_set_pointer_mapping_cookie_t;
}
extern "C" {
    pub fn xcb_set_pointer_mapping_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_set_pointer_mapping_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_set_pointer_mapping_reply_t;
}
extern "C" {
    pub fn xcb_get_pointer_mapping_sizeof(_buffer: *const cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn xcb_get_pointer_mapping(c: *mut xcb_connection_t) -> xcb_get_pointer_mapping_cookie_t;
}
extern "C" {
    pub fn xcb_get_pointer_mapping_unchecked(
        c: *mut xcb_connection_t,
    ) -> xcb_get_pointer_mapping_cookie_t;
}
extern "C" {
    pub fn xcb_get_pointer_mapping_map(R: *const xcb_get_pointer_mapping_reply_t) -> *mut u8;
}
extern "C" {
    pub fn xcb_get_pointer_mapping_map_length(
        R: *const xcb_get_pointer_mapping_reply_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xcb_get_pointer_mapping_map_end(
        R: *const xcb_get_pointer_mapping_reply_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_get_pointer_mapping_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_pointer_mapping_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_pointer_mapping_reply_t;
}
extern "C" {
    pub fn xcb_set_modifier_mapping_sizeof(_buffer: *const cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn xcb_set_modifier_mapping(
        c: *mut xcb_connection_t,
        keycodes_per_modifier: u8,
        keycodes: *const xcb_keycode_t,
    ) -> xcb_set_modifier_mapping_cookie_t;
}
extern "C" {
    pub fn xcb_set_modifier_mapping_unchecked(
        c: *mut xcb_connection_t,
        keycodes_per_modifier: u8,
        keycodes: *const xcb_keycode_t,
    ) -> xcb_set_modifier_mapping_cookie_t;
}
extern "C" {
    pub fn xcb_set_modifier_mapping_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_set_modifier_mapping_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_set_modifier_mapping_reply_t;
}
extern "C" {
    pub fn xcb_get_modifier_mapping_sizeof(_buffer: *const cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn xcb_get_modifier_mapping(c: *mut xcb_connection_t) -> xcb_get_modifier_mapping_cookie_t;
}
extern "C" {
    pub fn xcb_get_modifier_mapping_unchecked(
        c: *mut xcb_connection_t,
    ) -> xcb_get_modifier_mapping_cookie_t;
}
extern "C" {
    pub fn xcb_get_modifier_mapping_keycodes(
        R: *const xcb_get_modifier_mapping_reply_t,
    ) -> *mut xcb_keycode_t;
}
extern "C" {
    pub fn xcb_get_modifier_mapping_keycodes_length(
        R: *const xcb_get_modifier_mapping_reply_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xcb_get_modifier_mapping_keycodes_end(
        R: *const xcb_get_modifier_mapping_reply_t,
    ) -> xcb_generic_iterator_t;
}
extern "C" {
    pub fn xcb_get_modifier_mapping_reply(
        c: *mut xcb_connection_t,
        cookie: xcb_get_modifier_mapping_cookie_t,
        e: *mut *mut xcb_generic_error_t,
    ) -> *mut xcb_get_modifier_mapping_reply_t;
}
extern "C" {
    pub fn xcb_no_operation_checked(c: *mut xcb_connection_t) -> xcb_void_cookie_t;
}
extern "C" {
    pub fn xcb_no_operation(c: *mut xcb_connection_t) -> xcb_void_cookie_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_auth_info_t {
    pub namelen: cty::c_int,
    pub name: *mut cty::c_char,
    pub datalen: cty::c_int,
    pub data: *mut cty::c_char,
}
#[test]
fn bindgen_test_layout_xcb_auth_info_t() {
    assert_eq!(
        ::core::mem::size_of::<xcb_auth_info_t>(),
        32usize,
        concat!("Size of: ", stringify!(xcb_auth_info_t))
    );
    assert_eq!(
        ::core::mem::align_of::<xcb_auth_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(xcb_auth_info_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_auth_info_t>())).namelen as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_auth_info_t),
            "::",
            stringify!(namelen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_auth_info_t>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_auth_info_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_auth_info_t>())).datalen as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_auth_info_t),
            "::",
            stringify!(datalen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xcb_auth_info_t>())).data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xcb_auth_info_t),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    pub fn xcb_flush(c: *mut xcb_connection_t) -> cty::c_int;
}
extern "C" {
    pub fn xcb_get_maximum_request_length(c: *mut xcb_connection_t) -> u32;
}
extern "C" {
    pub fn xcb_prefetch_maximum_request_length(c: *mut xcb_connection_t);
}
extern "C" {
    pub fn xcb_wait_for_event(c: *mut xcb_connection_t) -> *mut xcb_generic_event_t;
}
extern "C" {
    pub fn xcb_poll_for_event(c: *mut xcb_connection_t) -> *mut xcb_generic_event_t;
}
extern "C" {
    pub fn xcb_poll_for_queued_event(c: *mut xcb_connection_t) -> *mut xcb_generic_event_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_special_event {
    _unused: [u8; 0],
}
pub type xcb_special_event_t = xcb_special_event;
extern "C" {
    pub fn xcb_poll_for_special_event(
        c: *mut xcb_connection_t,
        se: *mut xcb_special_event_t,
    ) -> *mut xcb_generic_event_t;
}
extern "C" {
    pub fn xcb_wait_for_special_event(
        c: *mut xcb_connection_t,
        se: *mut xcb_special_event_t,
    ) -> *mut xcb_generic_event_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xcb_extension_t {
    _unused: [u8; 0],
}
extern "C" {
    pub fn xcb_register_for_special_xge(
        c: *mut xcb_connection_t,
        ext: *mut xcb_extension_t,
        eid: u32,
        stamp: *mut u32,
    ) -> *mut xcb_special_event_t;
}
extern "C" {
    pub fn xcb_unregister_for_special_event(c: *mut xcb_connection_t, se: *mut xcb_special_event_t);
}
extern "C" {
    pub fn xcb_request_check(
        c: *mut xcb_connection_t,
        cookie: xcb_void_cookie_t,
    ) -> *mut xcb_generic_error_t;
}
extern "C" {
    pub fn xcb_discard_reply(c: *mut xcb_connection_t, sequence: cty::c_uint);
}
extern "C" {
    pub fn xcb_discard_reply64(c: *mut xcb_connection_t, sequence: u64);
}
extern "C" {
    pub fn xcb_get_extension_data(
        c: *mut xcb_connection_t,
        ext: *mut xcb_extension_t,
    ) -> *const xcb_query_extension_reply_t;
}
extern "C" {
    pub fn xcb_prefetch_extension_data(c: *mut xcb_connection_t, ext: *mut xcb_extension_t);
}
extern "C" {
    pub fn xcb_get_setup(c: *mut xcb_connection_t) -> *const xcb_setup_t;
}
extern "C" {
    pub fn xcb_get_file_descriptor(c: *mut xcb_connection_t) -> cty::c_int;
}
extern "C" {
    pub fn xcb_connection_has_error(c: *mut xcb_connection_t) -> cty::c_int;
}
extern "C" {
    pub fn xcb_connect_to_fd(
        fd: cty::c_int,
        auth_info: *mut xcb_auth_info_t,
    ) -> *mut xcb_connection_t;
}
extern "C" {
    pub fn xcb_disconnect(c: *mut xcb_connection_t);
}
extern "C" {
    pub fn xcb_parse_display(
        name: *const cty::c_char,
        host: *mut *mut cty::c_char,
        display: *mut cty::c_int,
        screen: *mut cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xcb_connect(
        displayname: *const cty::c_char,
        screenp: *mut cty::c_int,
    ) -> *mut xcb_connection_t;
}
extern "C" {
    pub fn xcb_connect_to_display_with_auth_info(
        display: *const cty::c_char,
        auth: *mut xcb_auth_info_t,
        screen: *mut cty::c_int,
    ) -> *mut xcb_connection_t;
}
extern "C" {
    pub fn xcb_generate_id(c: *mut xcb_connection_t) -> u32;
}
extern "C" {
    pub fn xcb_total_read(c: *mut xcb_connection_t) -> u64;
}
extern "C" {
    pub fn xcb_total_written(c: *mut xcb_connection_t) -> u64;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: cty::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: cty::c_uint,
    pub __wchb: [cty::c_char; 4usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::core::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(
        ::core::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_G_fpos_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_G_fpos_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(
        ::core::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_G_fpos64_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_G_fpos64_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = cty::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: cty::c_int,
    pub _IO_read_ptr: *mut cty::c_char,
    pub _IO_read_end: *mut cty::c_char,
    pub _IO_read_base: *mut cty::c_char,
    pub _IO_write_base: *mut cty::c_char,
    pub _IO_write_ptr: *mut cty::c_char,
    pub _IO_write_end: *mut cty::c_char,
    pub _IO_buf_base: *mut cty::c_char,
    pub _IO_buf_end: *mut cty::c_char,
    pub _IO_save_base: *mut cty::c_char,
    pub _IO_backup_base: *mut cty::c_char,
    pub _IO_save_end: *mut cty::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: cty::c_int,
    pub _flags2: cty::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: cty::c_ushort,
    pub _vtable_offset: cty::c_schar,
    pub _shortbuf: [cty::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut cty::c_void,
    pub __pad5: size_t,
    pub _mode: cty::c_int,
    pub _unused2: [cty::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::core::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._codecvt as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._wide_data as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._freeres_list as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._freeres_buf as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn rename(__old: *const cty::c_char, __new: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: cty::c_int,
        __old: *const cty::c_char,
        __newfd: cty::c_int,
        __new: *const cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn tempnam(__dir: *const cty::c_char, __pfx: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fopen(__filename: *const cty::c_char, __modes: *const cty::c_char) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const cty::c_char,
        __modes: *const cty::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: cty::c_int, __modes: *const cty::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(__s: *mut cty::c_void, __len: size_t, __modes: *const cty::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(__bufloc: *mut *mut cty::c_char, __sizeloc: *mut size_t) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut cty::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut cty::c_char,
        __modes: cty::c_int,
        __n: size_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut cty::c_char, __size: size_t);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(__stream: *mut FILE, __format: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn printf(__format: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn sprintf(__s: *mut cty::c_char, __format: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const cty::c_char,
        __arg: *mut __va_list_tag,
    ) -> cty::c_int;
}
extern "C" {
    pub fn vprintf(__format: *const cty::c_char, __arg: *mut __va_list_tag) -> cty::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut cty::c_char,
        __format: *const cty::c_char,
        __arg: *mut __va_list_tag,
    ) -> cty::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut cty::c_char,
        __maxlen: cty::c_ulong,
        __format: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut cty::c_char,
        __maxlen: cty::c_ulong,
        __format: *const cty::c_char,
        __arg: *mut __va_list_tag,
    ) -> cty::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: cty::c_int,
        __fmt: *const cty::c_char,
        __arg: *mut __va_list_tag,
    ) -> cty::c_int;
}
extern "C" {
    pub fn dprintf(__fd: cty::c_int, __fmt: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn fscanf(__stream: *mut FILE, __format: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn scanf(__format: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn sscanf(__s: *const cty::c_char, __format: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const cty::c_char,
        __arg: *mut __va_list_tag,
    ) -> cty::c_int;
}
extern "C" {
    pub fn vscanf(__format: *const cty::c_char, __arg: *mut __va_list_tag) -> cty::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const cty::c_char,
        __format: *const cty::c_char,
        __arg: *mut __va_list_tag,
    ) -> cty::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn getchar() -> cty::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> cty::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fputc(__c: cty::c_int, __stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn putc(__c: cty::c_int, __stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn putchar(__c: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: cty::c_int, __stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: cty::c_int, __stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn putw(__w: cty::c_int, __stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fgets(__s: *mut cty::c_char, __n: cty::c_int, __stream: *mut FILE) -> *mut cty::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut cty::c_char,
        __n: *mut size_t,
        __delimiter: cty::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut cty::c_char,
        __n: *mut size_t,
        __delimiter: cty::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut cty::c_char,
        __n: *mut size_t,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const cty::c_char, __stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn puts(__s: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn ungetc(__c: cty::c_int, __stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut cty::c_void,
        __size: cty::c_ulong,
        __n: cty::c_ulong,
        __stream: *mut FILE,
    ) -> cty::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const cty::c_void,
        __size: cty::c_ulong,
        __n: cty::c_ulong,
        __s: *mut FILE,
    ) -> cty::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut cty::c_void,
        __size: size_t,
        __n: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const cty::c_void,
        __size: size_t,
        __n: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fseek(__stream: *mut FILE, __off: cty::c_long, __whence: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> cty::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(__stream: *mut FILE, __off: __off_t, __whence: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> cty::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> cty::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn perror(__s: *const cty::c_char);
}
extern "C" {
    pub static mut sys_nerr: cty::c_int;
}
extern "C" {
    pub static mut sys_errlist: [*const cty::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn popen(__command: *const cty::c_char, __modes: *const cty::c_char) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: cty::c_int) -> cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xkb_context {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xkb_keymap {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xkb_state {
    _unused: [u8; 0],
}
pub type xkb_keycode_t = u32;
pub type xkb_keysym_t = u32;
pub type xkb_layout_index_t = u32;
pub type xkb_layout_mask_t = u32;
pub type xkb_level_index_t = u32;
pub type xkb_mod_index_t = u32;
pub type xkb_mod_mask_t = u32;
pub type xkb_led_index_t = u32;
pub type xkb_led_mask_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xkb_rule_names {
    pub rules: *const cty::c_char,
    pub model: *const cty::c_char,
    pub layout: *const cty::c_char,
    pub variant: *const cty::c_char,
    pub options: *const cty::c_char,
}
#[test]
fn bindgen_test_layout_xkb_rule_names() {
    assert_eq!(
        ::core::mem::size_of::<xkb_rule_names>(),
        40usize,
        concat!("Size of: ", stringify!(xkb_rule_names))
    );
    assert_eq!(
        ::core::mem::align_of::<xkb_rule_names>(),
        8usize,
        concat!("Alignment of ", stringify!(xkb_rule_names))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xkb_rule_names>())).rules as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xkb_rule_names),
            "::",
            stringify!(rules)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xkb_rule_names>())).model as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xkb_rule_names),
            "::",
            stringify!(model)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xkb_rule_names>())).layout as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xkb_rule_names),
            "::",
            stringify!(layout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xkb_rule_names>())).variant as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xkb_rule_names),
            "::",
            stringify!(variant)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xkb_rule_names>())).options as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xkb_rule_names),
            "::",
            stringify!(options)
        )
    );
}
extern "C" {
    pub fn xkb_keysym_get_name(
        keysym: xkb_keysym_t,
        buffer: *mut cty::c_char,
        size: size_t,
    ) -> cty::c_int;
}
pub const xkb_keysym_flags_XKB_KEYSYM_NO_FLAGS: xkb_keysym_flags = 0;
pub const xkb_keysym_flags_XKB_KEYSYM_CASE_INSENSITIVE: xkb_keysym_flags = 1;
pub type xkb_keysym_flags = u32;
extern "C" {
    pub fn xkb_keysym_from_name(name: *const cty::c_char, flags: xkb_keysym_flags) -> xkb_keysym_t;
}
extern "C" {
    pub fn xkb_keysym_to_utf8(
        keysym: xkb_keysym_t,
        buffer: *mut cty::c_char,
        size: size_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xkb_keysym_to_utf32(keysym: xkb_keysym_t) -> u32;
}
extern "C" {
    pub fn xkb_keysym_to_upper(ks: xkb_keysym_t) -> xkb_keysym_t;
}
extern "C" {
    pub fn xkb_keysym_to_lower(ks: xkb_keysym_t) -> xkb_keysym_t;
}
pub const xkb_context_flags_XKB_CONTEXT_NO_FLAGS: xkb_context_flags = 0;
pub const xkb_context_flags_XKB_CONTEXT_NO_DEFAULT_INCLUDES: xkb_context_flags = 1;
pub const xkb_context_flags_XKB_CONTEXT_NO_ENVIRONMENT_NAMES: xkb_context_flags = 2;
pub type xkb_context_flags = u32;
extern "C" {
    pub fn xkb_context_new(flags: xkb_context_flags) -> *mut xkb_context;
}
extern "C" {
    pub fn xkb_context_ref(context: *mut xkb_context) -> *mut xkb_context;
}
extern "C" {
    pub fn xkb_context_unref(context: *mut xkb_context);
}
extern "C" {
    pub fn xkb_context_set_user_data(context: *mut xkb_context, user_data: *mut cty::c_void);
}
extern "C" {
    pub fn xkb_context_get_user_data(context: *mut xkb_context) -> *mut cty::c_void;
}
extern "C" {
    pub fn xkb_context_include_path_append(
        context: *mut xkb_context,
        path: *const cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xkb_context_include_path_append_default(context: *mut xkb_context) -> cty::c_int;
}
extern "C" {
    pub fn xkb_context_include_path_reset_defaults(context: *mut xkb_context) -> cty::c_int;
}
extern "C" {
    pub fn xkb_context_include_path_clear(context: *mut xkb_context);
}
extern "C" {
    pub fn xkb_context_num_include_paths(context: *mut xkb_context) -> cty::c_uint;
}
extern "C" {
    pub fn xkb_context_include_path_get(
        context: *mut xkb_context,
        index: cty::c_uint,
    ) -> *const cty::c_char;
}
pub const xkb_log_level_XKB_LOG_LEVEL_CRITICAL: xkb_log_level = 10;
pub const xkb_log_level_XKB_LOG_LEVEL_ERROR: xkb_log_level = 20;
pub const xkb_log_level_XKB_LOG_LEVEL_WARNING: xkb_log_level = 30;
pub const xkb_log_level_XKB_LOG_LEVEL_INFO: xkb_log_level = 40;
pub const xkb_log_level_XKB_LOG_LEVEL_DEBUG: xkb_log_level = 50;
pub type xkb_log_level = u32;
extern "C" {
    pub fn xkb_context_set_log_level(context: *mut xkb_context, level: xkb_log_level);
}
extern "C" {
    pub fn xkb_context_get_log_level(context: *mut xkb_context) -> xkb_log_level;
}
extern "C" {
    pub fn xkb_context_set_log_verbosity(context: *mut xkb_context, verbosity: cty::c_int);
}
extern "C" {
    pub fn xkb_context_get_log_verbosity(context: *mut xkb_context) -> cty::c_int;
}
extern "C" {
    pub fn xkb_context_set_log_fn(
        context: *mut xkb_context,
        log_fn: ::core::option::Option<
            unsafe extern "C" fn(
                context: *mut xkb_context,
                level: xkb_log_level,
                format: *const cty::c_char,
                args: *mut __va_list_tag,
            ),
        >,
    );
}
pub const xkb_keymap_compile_flags_XKB_KEYMAP_COMPILE_NO_FLAGS: xkb_keymap_compile_flags = 0;
pub type xkb_keymap_compile_flags = u32;
extern "C" {
    pub fn xkb_keymap_new_from_names(
        context: *mut xkb_context,
        names: *const xkb_rule_names,
        flags: xkb_keymap_compile_flags,
    ) -> *mut xkb_keymap;
}
pub const xkb_keymap_format_XKB_KEYMAP_FORMAT_TEXT_V1: xkb_keymap_format = 1;
pub type xkb_keymap_format = u32;
extern "C" {
    pub fn xkb_keymap_new_from_file(
        context: *mut xkb_context,
        file: *mut FILE,
        format: xkb_keymap_format,
        flags: xkb_keymap_compile_flags,
    ) -> *mut xkb_keymap;
}
extern "C" {
    pub fn xkb_keymap_new_from_string(
        context: *mut xkb_context,
        string: *const cty::c_char,
        format: xkb_keymap_format,
        flags: xkb_keymap_compile_flags,
    ) -> *mut xkb_keymap;
}
extern "C" {
    pub fn xkb_keymap_new_from_buffer(
        context: *mut xkb_context,
        buffer: *const cty::c_char,
        length: size_t,
        format: xkb_keymap_format,
        flags: xkb_keymap_compile_flags,
    ) -> *mut xkb_keymap;
}
extern "C" {
    pub fn xkb_keymap_ref(keymap: *mut xkb_keymap) -> *mut xkb_keymap;
}
extern "C" {
    pub fn xkb_keymap_unref(keymap: *mut xkb_keymap);
}
extern "C" {
    pub fn xkb_keymap_get_as_string(
        keymap: *mut xkb_keymap,
        format: xkb_keymap_format,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn xkb_keymap_min_keycode(keymap: *mut xkb_keymap) -> xkb_keycode_t;
}
extern "C" {
    pub fn xkb_keymap_max_keycode(keymap: *mut xkb_keymap) -> xkb_keycode_t;
}
pub type xkb_keymap_key_iter_t = ::core::option::Option<
    unsafe extern "C" fn(keymap: *mut xkb_keymap, key: xkb_keycode_t, data: *mut cty::c_void),
>;
extern "C" {
    pub fn xkb_keymap_key_for_each(
        keymap: *mut xkb_keymap,
        iter: xkb_keymap_key_iter_t,
        data: *mut cty::c_void,
    );
}
extern "C" {
    pub fn xkb_keymap_key_get_name(
        keymap: *mut xkb_keymap,
        key: xkb_keycode_t,
    ) -> *const cty::c_char;
}
extern "C" {
    pub fn xkb_keymap_key_by_name(
        keymap: *mut xkb_keymap,
        name: *const cty::c_char,
    ) -> xkb_keycode_t;
}
extern "C" {
    pub fn xkb_keymap_num_mods(keymap: *mut xkb_keymap) -> xkb_mod_index_t;
}
extern "C" {
    pub fn xkb_keymap_mod_get_name(
        keymap: *mut xkb_keymap,
        idx: xkb_mod_index_t,
    ) -> *const cty::c_char;
}
extern "C" {
    pub fn xkb_keymap_mod_get_index(
        keymap: *mut xkb_keymap,
        name: *const cty::c_char,
    ) -> xkb_mod_index_t;
}
extern "C" {
    pub fn xkb_keymap_num_layouts(keymap: *mut xkb_keymap) -> xkb_layout_index_t;
}
extern "C" {
    pub fn xkb_keymap_layout_get_name(
        keymap: *mut xkb_keymap,
        idx: xkb_layout_index_t,
    ) -> *const cty::c_char;
}
extern "C" {
    pub fn xkb_keymap_layout_get_index(
        keymap: *mut xkb_keymap,
        name: *const cty::c_char,
    ) -> xkb_layout_index_t;
}
extern "C" {
    pub fn xkb_keymap_num_leds(keymap: *mut xkb_keymap) -> xkb_led_index_t;
}
extern "C" {
    pub fn xkb_keymap_led_get_name(
        keymap: *mut xkb_keymap,
        idx: xkb_led_index_t,
    ) -> *const cty::c_char;
}
extern "C" {
    pub fn xkb_keymap_led_get_index(
        keymap: *mut xkb_keymap,
        name: *const cty::c_char,
    ) -> xkb_led_index_t;
}
extern "C" {
    pub fn xkb_keymap_num_layouts_for_key(
        keymap: *mut xkb_keymap,
        key: xkb_keycode_t,
    ) -> xkb_layout_index_t;
}
extern "C" {
    pub fn xkb_keymap_num_levels_for_key(
        keymap: *mut xkb_keymap,
        key: xkb_keycode_t,
        layout: xkb_layout_index_t,
    ) -> xkb_level_index_t;
}
extern "C" {
    pub fn xkb_keymap_key_get_syms_by_level(
        keymap: *mut xkb_keymap,
        key: xkb_keycode_t,
        layout: xkb_layout_index_t,
        level: xkb_level_index_t,
        syms_out: *mut *const xkb_keysym_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xkb_keymap_key_repeats(keymap: *mut xkb_keymap, key: xkb_keycode_t) -> cty::c_int;
}
extern "C" {
    pub fn xkb_state_new(keymap: *mut xkb_keymap) -> *mut xkb_state;
}
extern "C" {
    pub fn xkb_state_ref(state: *mut xkb_state) -> *mut xkb_state;
}
extern "C" {
    pub fn xkb_state_unref(state: *mut xkb_state);
}
extern "C" {
    pub fn xkb_state_get_keymap(state: *mut xkb_state) -> *mut xkb_keymap;
}
pub const xkb_key_direction_XKB_KEY_UP: xkb_key_direction = 0;
pub const xkb_key_direction_XKB_KEY_DOWN: xkb_key_direction = 1;
pub type xkb_key_direction = u32;
pub const xkb_state_component_XKB_STATE_MODS_DEPRESSED: xkb_state_component = 1;
pub const xkb_state_component_XKB_STATE_MODS_LATCHED: xkb_state_component = 2;
pub const xkb_state_component_XKB_STATE_MODS_LOCKED: xkb_state_component = 4;
pub const xkb_state_component_XKB_STATE_MODS_EFFECTIVE: xkb_state_component = 8;
pub const xkb_state_component_XKB_STATE_LAYOUT_DEPRESSED: xkb_state_component = 16;
pub const xkb_state_component_XKB_STATE_LAYOUT_LATCHED: xkb_state_component = 32;
pub const xkb_state_component_XKB_STATE_LAYOUT_LOCKED: xkb_state_component = 64;
pub const xkb_state_component_XKB_STATE_LAYOUT_EFFECTIVE: xkb_state_component = 128;
pub const xkb_state_component_XKB_STATE_LEDS: xkb_state_component = 256;
pub type xkb_state_component = u32;
extern "C" {
    pub fn xkb_state_update_key(
        state: *mut xkb_state,
        key: xkb_keycode_t,
        direction: xkb_key_direction,
    ) -> xkb_state_component;
}
extern "C" {
    pub fn xkb_state_update_mask(
        state: *mut xkb_state,
        depressed_mods: xkb_mod_mask_t,
        latched_mods: xkb_mod_mask_t,
        locked_mods: xkb_mod_mask_t,
        depressed_layout: xkb_layout_index_t,
        latched_layout: xkb_layout_index_t,
        locked_layout: xkb_layout_index_t,
    ) -> xkb_state_component;
}
extern "C" {
    pub fn xkb_state_key_get_syms(
        state: *mut xkb_state,
        key: xkb_keycode_t,
        syms_out: *mut *const xkb_keysym_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xkb_state_key_get_utf8(
        state: *mut xkb_state,
        key: xkb_keycode_t,
        buffer: *mut cty::c_char,
        size: size_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xkb_state_key_get_utf32(state: *mut xkb_state, key: xkb_keycode_t) -> u32;
}
extern "C" {
    pub fn xkb_state_key_get_one_sym(state: *mut xkb_state, key: xkb_keycode_t) -> xkb_keysym_t;
}
extern "C" {
    pub fn xkb_state_key_get_layout(
        state: *mut xkb_state,
        key: xkb_keycode_t,
    ) -> xkb_layout_index_t;
}
extern "C" {
    pub fn xkb_state_key_get_level(
        state: *mut xkb_state,
        key: xkb_keycode_t,
        layout: xkb_layout_index_t,
    ) -> xkb_level_index_t;
}
pub const xkb_state_match_XKB_STATE_MATCH_ANY: xkb_state_match = 1;
pub const xkb_state_match_XKB_STATE_MATCH_ALL: xkb_state_match = 2;
pub const xkb_state_match_XKB_STATE_MATCH_NON_EXCLUSIVE: xkb_state_match = 65536;
pub type xkb_state_match = u32;
extern "C" {
    pub fn xkb_state_serialize_mods(
        state: *mut xkb_state,
        components: xkb_state_component,
    ) -> xkb_mod_mask_t;
}
extern "C" {
    pub fn xkb_state_serialize_layout(
        state: *mut xkb_state,
        components: xkb_state_component,
    ) -> xkb_layout_index_t;
}
extern "C" {
    pub fn xkb_state_mod_name_is_active(
        state: *mut xkb_state,
        name: *const cty::c_char,
        type_: xkb_state_component,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xkb_state_mod_names_are_active(
        state: *mut xkb_state,
        type_: xkb_state_component,
        match_: xkb_state_match,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn xkb_state_mod_index_is_active(
        state: *mut xkb_state,
        idx: xkb_mod_index_t,
        type_: xkb_state_component,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xkb_state_mod_indices_are_active(
        state: *mut xkb_state,
        type_: xkb_state_component,
        match_: xkb_state_match,
        ...
    ) -> cty::c_int;
}
pub const xkb_consumed_mode_XKB_CONSUMED_MODE_XKB: xkb_consumed_mode = 0;
pub const xkb_consumed_mode_XKB_CONSUMED_MODE_GTK: xkb_consumed_mode = 1;
pub type xkb_consumed_mode = u32;
extern "C" {
    pub fn xkb_state_key_get_consumed_mods2(
        state: *mut xkb_state,
        key: xkb_keycode_t,
        mode: xkb_consumed_mode,
    ) -> xkb_mod_mask_t;
}
extern "C" {
    pub fn xkb_state_key_get_consumed_mods(
        state: *mut xkb_state,
        key: xkb_keycode_t,
    ) -> xkb_mod_mask_t;
}
extern "C" {
    pub fn xkb_state_mod_index_is_consumed2(
        state: *mut xkb_state,
        key: xkb_keycode_t,
        idx: xkb_mod_index_t,
        mode: xkb_consumed_mode,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xkb_state_mod_index_is_consumed(
        state: *mut xkb_state,
        key: xkb_keycode_t,
        idx: xkb_mod_index_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xkb_state_mod_mask_remove_consumed(
        state: *mut xkb_state,
        key: xkb_keycode_t,
        mask: xkb_mod_mask_t,
    ) -> xkb_mod_mask_t;
}
extern "C" {
    pub fn xkb_state_layout_name_is_active(
        state: *mut xkb_state,
        name: *const cty::c_char,
        type_: xkb_state_component,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xkb_state_layout_index_is_active(
        state: *mut xkb_state,
        idx: xkb_layout_index_t,
        type_: xkb_state_component,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xkb_state_led_name_is_active(
        state: *mut xkb_state,
        name: *const cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    pub fn xkb_state_led_index_is_active(state: *mut xkb_state, idx: xkb_led_index_t)
        -> cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NkBindings {
    _unused: [u8; 0],
}
pub type NkBindings = _NkBindings;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NkBindingsSeat {
    _unused: [u8; 0],
}
pub type NkBindingsSeat = _NkBindingsSeat;
pub const NkBindingsModifiers_NK_BINDINGS_MODIFIER_SHIFT: NkBindingsModifiers = 0;
pub const NkBindingsModifiers_NK_BINDINGS_MODIFIER_CONTROL: NkBindingsModifiers = 1;
pub const NkBindingsModifiers_NK_BINDINGS_MODIFIER_ALT: NkBindingsModifiers = 2;
pub const NkBindingsModifiers_NK_BINDINGS_MODIFIER_SUPER: NkBindingsModifiers = 3;
pub const NkBindingsModifiers_NK_BINDINGS_MODIFIER_META: NkBindingsModifiers = 4;
pub const NkBindingsModifiers_NK_BINDINGS_MODIFIER_HYPER: NkBindingsModifiers = 5;
pub type NkBindingsModifiers = u32;
pub const NkBindingsKeyState_NK_BINDINGS_KEY_STATE_PRESS: NkBindingsKeyState = 0;
pub const NkBindingsKeyState_NK_BINDINGS_KEY_STATE_PRESSED: NkBindingsKeyState = 1;
pub const NkBindingsKeyState_NK_BINDINGS_KEY_STATE_RELEASE: NkBindingsKeyState = 2;
pub type NkBindingsKeyState = u32;
pub const NkBindingsButtonState_NK_BINDINGS_BUTTON_STATE_PRESS: NkBindingsButtonState = 0;
pub const NkBindingsButtonState_NK_BINDINGS_BUTTON_STATE_RELEASE: NkBindingsButtonState = 1;
pub type NkBindingsButtonState = u32;
pub const NkBindingsMouseButton_NK_BINDINGS_MOUSE_BUTTON_PRIMARY: NkBindingsMouseButton = 0;
pub const NkBindingsMouseButton_NK_BINDINGS_MOUSE_BUTTON_SECONDARY: NkBindingsMouseButton = 1;
pub const NkBindingsMouseButton_NK_BINDINGS_MOUSE_BUTTON_MIDDLE: NkBindingsMouseButton = 2;
pub const NkBindingsMouseButton_NK_BINDINGS_MOUSE_BUTTON_BACK: NkBindingsMouseButton = 3;
pub const NkBindingsMouseButton_NK_BINDINGS_MOUSE_BUTTON_FORWARD: NkBindingsMouseButton = 4;
pub const NkBindingsMouseButton_NK_BINDINGS_MOUSE_BUTTON_EXTRA: NkBindingsMouseButton = 5;
pub type NkBindingsMouseButton = u32;
pub const NkBindingsScrollAxis_NK_BINDINGS_SCROLL_AXIS_VERTICAL: NkBindingsScrollAxis = 0;
pub const NkBindingsScrollAxis_NK_BINDINGS_SCROLL_AXIS_HORIZONTAL: NkBindingsScrollAxis = 1;
pub type NkBindingsScrollAxis = u32;
pub const NkBindingsError_NK_BINDINGS_ERROR_SYNTAX: NkBindingsError = 0;
pub const NkBindingsError_NK_BINDINGS_ERROR_NOTHING: NkBindingsError = 1;
pub const NkBindingsError_NK_BINDINGS_ERROR_ALREADY_REGISTERED: NkBindingsError = 2;
pub type NkBindingsError = u32;
extern "C" {
    pub fn nk_bindings_error() -> GQuark;
}
extern "C" {
    pub fn nk_bindings_new(double_click_delay: guint64) -> *mut NkBindings;
}
extern "C" {
    pub fn nk_bindings_free(bindings: *mut NkBindings);
}
pub type NkBindingsCallback = ::core::option::Option<
    unsafe extern "C" fn(scope: guint64, target: gpointer, user_data: gpointer) -> gboolean,
>;
extern "C" {
    pub fn nk_bindings_add_binding(
        bindings: *mut NkBindings,
        scope: guint64,
        string: *const gchar,
        callback: NkBindingsCallback,
        user_data: gpointer,
        notify: GDestroyNotify,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    pub fn nk_bindings_reset_bindings(bindings: *mut NkBindings);
}
extern "C" {
    pub fn nk_bindings_seat_new(
        bindings: *mut NkBindings,
        flags: xkb_context_flags,
    ) -> *mut NkBindingsSeat;
}
extern "C" {
    pub fn nk_bindings_seat_free(seat: *mut NkBindingsSeat);
}
extern "C" {
    pub fn nk_bindings_seat_update_keymap(
        seat: *mut NkBindingsSeat,
        keymap: *mut xkb_keymap,
        state: *mut xkb_state,
    );
}
extern "C" {
    pub fn nk_bindings_seat_get_context(seat: *mut NkBindingsSeat) -> *mut xkb_context;
}
extern "C" {
    pub fn nk_bindings_seat_handle_key(
        seat: *mut NkBindingsSeat,
        target: gpointer,
        key: xkb_keycode_t,
        state: NkBindingsKeyState,
    ) -> *mut gchar;
}
extern "C" {
    pub fn nk_bindings_seat_handle_key_with_modmask(
        self_: *mut NkBindingsSeat,
        target: gpointer,
        modmask: xkb_mod_mask_t,
        keycode: xkb_keycode_t,
        state: NkBindingsKeyState,
    ) -> *mut gchar;
}
extern "C" {
    pub fn nk_bindings_seat_handle_button(
        seat: *mut NkBindingsSeat,
        target: gpointer,
        button: NkBindingsMouseButton,
        state: NkBindingsButtonState,
        timestamp: guint64,
    ) -> gboolean;
}
extern "C" {
    pub fn nk_bindings_seat_handle_scroll(
        seat: *mut NkBindingsSeat,
        target: gpointer,
        axis: NkBindingsScrollAxis,
        steps: gint32,
    ) -> gboolean;
}
extern "C" {
    pub fn nk_bindings_seat_update_mask(
        seat: *mut NkBindingsSeat,
        target: gpointer,
        depressed_mods: xkb_mod_mask_t,
        latched_mods: xkb_mod_mask_t,
        locked_mods: xkb_mod_mask_t,
        depressed_layout: xkb_layout_index_t,
        latched_layout: xkb_layout_index_t,
        locked_layout: xkb_layout_index_t,
    );
}
extern "C" {
    pub fn nk_bindings_seat_reset(seat: *mut NkBindingsSeat);
}
pub const BindingsScope_SCOPE_GLOBAL: BindingsScope = 0;
pub const BindingsScope_SCOPE_MOUSE_LISTVIEW: BindingsScope = 1;
pub const BindingsScope_SCOPE_MOUSE_LISTVIEW_ELEMENT: BindingsScope = 2;
pub const BindingsScope_SCOPE_MOUSE_EDITBOX: BindingsScope = 3;
pub const BindingsScope_SCOPE_MOUSE_SCROLLBAR: BindingsScope = 4;
pub const BindingsScope_SCOPE_MOUSE_MODE_SWITCHER: BindingsScope = 5;
#[doc = " List of all scopes the mouse can interact on."]
pub type BindingsScope = u32;
#[doc = " Paste from primary clipboard"]
pub const KeyBindingAction_PASTE_PRIMARY: KeyBindingAction = 1;
#[doc = " Paste from secondary clipboard"]
pub const KeyBindingAction_PASTE_SECONDARY: KeyBindingAction = 2;
#[doc = " Clear the entry box."]
pub const KeyBindingAction_CLEAR_LINE: KeyBindingAction = 3;
#[doc = " Move to front of text"]
pub const KeyBindingAction_MOVE_FRONT: KeyBindingAction = 4;
#[doc = " Move to end of text"]
pub const KeyBindingAction_MOVE_END: KeyBindingAction = 5;
#[doc = " Move on word back"]
pub const KeyBindingAction_MOVE_WORD_BACK: KeyBindingAction = 6;
#[doc = " Move on word forward"]
pub const KeyBindingAction_MOVE_WORD_FORWARD: KeyBindingAction = 7;
#[doc = " Move character back"]
pub const KeyBindingAction_MOVE_CHAR_BACK: KeyBindingAction = 8;
#[doc = " Move character forward"]
pub const KeyBindingAction_MOVE_CHAR_FORWARD: KeyBindingAction = 9;
#[doc = " Remove previous word"]
pub const KeyBindingAction_REMOVE_WORD_BACK: KeyBindingAction = 10;
#[doc = " Remove next work"]
pub const KeyBindingAction_REMOVE_WORD_FORWARD: KeyBindingAction = 11;
#[doc = " Remove next character"]
pub const KeyBindingAction_REMOVE_CHAR_FORWARD: KeyBindingAction = 12;
#[doc = " Remove previous character"]
pub const KeyBindingAction_REMOVE_CHAR_BACK: KeyBindingAction = 13;
#[doc = " Remove till EOL"]
pub const KeyBindingAction_REMOVE_TO_EOL: KeyBindingAction = 14;
#[doc = " Remove till SOL"]
pub const KeyBindingAction_REMOVE_TO_SOL: KeyBindingAction = 15;
#[doc = " Accept the current selected entry"]
pub const KeyBindingAction_ACCEPT_ENTRY: KeyBindingAction = 16;
#[doc = " Accept the current selected entry"]
pub const KeyBindingAction_ACCEPT_ALT: KeyBindingAction = 17;
#[doc = " Accept the current selected entry"]
pub const KeyBindingAction_ACCEPT_CUSTOM: KeyBindingAction = 18;
#[doc = " Accept the current selected entry"]
pub const KeyBindingAction_MODE_NEXT: KeyBindingAction = 19;
#[doc = " Accept the current selected entry"]
pub const KeyBindingAction_MODE_PREVIOUS: KeyBindingAction = 20;
#[doc = " Accept the current selected entry"]
pub const KeyBindingAction_TOGGLE_CASE_SENSITIVITY: KeyBindingAction = 21;
#[doc = " Accept the current selected entry"]
pub const KeyBindingAction_DELETE_ENTRY: KeyBindingAction = 22;
#[doc = " Accept the current selected entry"]
pub const KeyBindingAction_ROW_LEFT: KeyBindingAction = 23;
#[doc = " Accept the current selected entry"]
pub const KeyBindingAction_ROW_RIGHT: KeyBindingAction = 24;
#[doc = " Accept the current selected entry"]
pub const KeyBindingAction_ROW_UP: KeyBindingAction = 25;
#[doc = " Accept the current selected entry"]
pub const KeyBindingAction_ROW_DOWN: KeyBindingAction = 26;
#[doc = " Accept the current selected entry"]
pub const KeyBindingAction_ROW_TAB: KeyBindingAction = 27;
#[doc = " Accept the current selected entry"]
pub const KeyBindingAction_PAGE_PREV: KeyBindingAction = 28;
#[doc = " Accept the current selected entry"]
pub const KeyBindingAction_PAGE_NEXT: KeyBindingAction = 29;
#[doc = " Accept the current selected entry"]
pub const KeyBindingAction_ROW_FIRST: KeyBindingAction = 30;
#[doc = " Accept the current selected entry"]
pub const KeyBindingAction_ROW_LAST: KeyBindingAction = 31;
#[doc = " Accept the current selected entry"]
pub const KeyBindingAction_ROW_SELECT: KeyBindingAction = 32;
#[doc = " Accept the current selected entry"]
pub const KeyBindingAction_CANCEL: KeyBindingAction = 33;
#[doc = " Accept the current selected entry"]
pub const KeyBindingAction_CUSTOM_1: KeyBindingAction = 34;
#[doc = " Accept the current selected entry"]
pub const KeyBindingAction_CUSTOM_2: KeyBindingAction = 35;
#[doc = " Accept the current selected entry"]
pub const KeyBindingAction_CUSTOM_3: KeyBindingAction = 36;
#[doc = " Accept the current selected entry"]
pub const KeyBindingAction_CUSTOM_4: KeyBindingAction = 37;
#[doc = " Accept the current selected entry"]
pub const KeyBindingAction_CUSTOM_5: KeyBindingAction = 38;
#[doc = " Accept the current selected entry"]
pub const KeyBindingAction_CUSTOM_6: KeyBindingAction = 39;
#[doc = " Accept the current selected entry"]
pub const KeyBindingAction_CUSTOM_7: KeyBindingAction = 40;
#[doc = " Accept the current selected entry"]
pub const KeyBindingAction_CUSTOM_8: KeyBindingAction = 41;
#[doc = " Accept the current selected entry"]
pub const KeyBindingAction_CUSTOM_9: KeyBindingAction = 42;
#[doc = " Accept the current selected entry"]
pub const KeyBindingAction_CUSTOM_10: KeyBindingAction = 43;
#[doc = " Accept the current selected entry"]
pub const KeyBindingAction_CUSTOM_11: KeyBindingAction = 44;
#[doc = " Accept the current selected entry"]
pub const KeyBindingAction_CUSTOM_12: KeyBindingAction = 45;
#[doc = " Accept the current selected entry"]
pub const KeyBindingAction_CUSTOM_13: KeyBindingAction = 46;
#[doc = " Accept the current selected entry"]
pub const KeyBindingAction_CUSTOM_14: KeyBindingAction = 47;
#[doc = " Accept the current selected entry"]
pub const KeyBindingAction_CUSTOM_15: KeyBindingAction = 48;
#[doc = " Accept the current selected entry"]
pub const KeyBindingAction_CUSTOM_16: KeyBindingAction = 49;
#[doc = " Accept the current selected entry"]
pub const KeyBindingAction_CUSTOM_17: KeyBindingAction = 50;
#[doc = " Accept the current selected entry"]
pub const KeyBindingAction_CUSTOM_18: KeyBindingAction = 51;
#[doc = " Accept the current selected entry"]
pub const KeyBindingAction_CUSTOM_19: KeyBindingAction = 52;
#[doc = " Accept the current selected entry"]
pub const KeyBindingAction_SCREENSHOT: KeyBindingAction = 53;
#[doc = " Accept the current selected entry"]
pub const KeyBindingAction_CHANGE_ELLIPSIZE: KeyBindingAction = 54;
#[doc = " Accept the current selected entry"]
pub const KeyBindingAction_TOGGLE_SORT: KeyBindingAction = 55;
#[doc = " Accept the current selected entry"]
pub const KeyBindingAction_SELECT_ELEMENT_1: KeyBindingAction = 56;
#[doc = " Accept the current selected entry"]
pub const KeyBindingAction_SELECT_ELEMENT_2: KeyBindingAction = 57;
#[doc = " Accept the current selected entry"]
pub const KeyBindingAction_SELECT_ELEMENT_3: KeyBindingAction = 58;
#[doc = " Accept the current selected entry"]
pub const KeyBindingAction_SELECT_ELEMENT_4: KeyBindingAction = 59;
#[doc = " Accept the current selected entry"]
pub const KeyBindingAction_SELECT_ELEMENT_5: KeyBindingAction = 60;
#[doc = " Accept the current selected entry"]
pub const KeyBindingAction_SELECT_ELEMENT_6: KeyBindingAction = 61;
#[doc = " Accept the current selected entry"]
pub const KeyBindingAction_SELECT_ELEMENT_7: KeyBindingAction = 62;
#[doc = " Accept the current selected entry"]
pub const KeyBindingAction_SELECT_ELEMENT_8: KeyBindingAction = 63;
#[doc = " Accept the current selected entry"]
pub const KeyBindingAction_SELECT_ELEMENT_9: KeyBindingAction = 64;
#[doc = " Accept the current selected entry"]
pub const KeyBindingAction_SELECT_ELEMENT_10: KeyBindingAction = 65;
#[doc = " List of all possible actions that can be triggered by a keybinding."]
pub type KeyBindingAction = u32;
pub const MouseBindingListviewAction_SCROLL_LEFT: MouseBindingListviewAction = 1;
pub const MouseBindingListviewAction_SCROLL_RIGHT: MouseBindingListviewAction = 2;
pub const MouseBindingListviewAction_SCROLL_DOWN: MouseBindingListviewAction = 3;
pub const MouseBindingListviewAction_SCROLL_UP: MouseBindingListviewAction = 4;
#[doc = " Actions mouse can take on the ListView."]
pub type MouseBindingListviewAction = u32;
pub const MouseBindingListviewElementAction_SELECT_HOVERED_ENTRY:
    MouseBindingListviewElementAction = 1;
pub const MouseBindingListviewElementAction_ACCEPT_HOVERED_ENTRY:
    MouseBindingListviewElementAction = 2;
pub const MouseBindingListviewElementAction_ACCEPT_HOVERED_CUSTOM:
    MouseBindingListviewElementAction = 3;
#[doc = " Actions mouse can take on the ListView element."]
pub type MouseBindingListviewElementAction = u32;
pub const MouseBindingMouseDefaultAction_MOUSE_CLICK_DOWN: MouseBindingMouseDefaultAction = 1;
pub const MouseBindingMouseDefaultAction_MOUSE_CLICK_UP: MouseBindingMouseDefaultAction = 2;
pub const MouseBindingMouseDefaultAction_MOUSE_DCLICK_DOWN: MouseBindingMouseDefaultAction = 3;
pub const MouseBindingMouseDefaultAction_MOUSE_DCLICK_UP: MouseBindingMouseDefaultAction = 4;
#[doc = " Default mouse actions."]
pub type MouseBindingMouseDefaultAction = u32;
extern "C" {
    #[doc = " Parse the keybindings."]
    #[doc = " This should be called after the setting system is initialized."]
    pub fn parse_keys_abe(bindings: *mut NkBindings) -> gboolean;
}
extern "C" {
    #[doc = " Setup the keybindings"]
    #[doc = " This adds all the entries to the settings system."]
    pub fn setup_abe();
}
#[doc = " Abstract structure holding internal state of a widget."]
#[doc = " Structure is elaborated in widget-internal.h"]
pub type widget = _widget;
#[doc = " Default type"]
pub const WidgetType_WIDGET_TYPE_UNKNOWN: WidgetType = 0;
#[doc = " The listview widget"]
pub const WidgetType_WIDGET_TYPE_LISTVIEW: WidgetType = 1;
#[doc = " An element in the listview"]
pub const WidgetType_WIDGET_TYPE_LISTVIEW_ELEMENT: WidgetType = 2;
#[doc = " The input bar edit box"]
pub const WidgetType_WIDGET_TYPE_EDITBOX: WidgetType = 3;
#[doc = " The listview scrollbar"]
pub const WidgetType_WIDGET_TYPE_SCROLLBAR: WidgetType = 4;
#[doc = " A widget allowing user to swithc between modi"]
pub const WidgetType_WIDGET_TYPE_MODE_SWITCHER: WidgetType = 5;
#[doc = " Text-only textbox"]
pub const WidgetType_WIDGET_TYPE_TEXTBOX_TEXT: WidgetType = 6;
#[doc = " Type of the widget. It is used to bubble events to the relevant widget."]
pub type WidgetType = u32;
#[doc = " The action was ignore and should bubble"]
pub const WidgetTriggerActionResult_WIDGET_TRIGGER_ACTION_RESULT_IGNORED:
    WidgetTriggerActionResult = 0;
#[doc = " The action was handled directly"]
pub const WidgetTriggerActionResult_WIDGET_TRIGGER_ACTION_RESULT_HANDLED:
    WidgetTriggerActionResult = 1;
#[doc = " The action was handled and should start the grab for motion events"]
pub const WidgetTriggerActionResult_WIDGET_TRIGGER_ACTION_RESULT_GRAB_MOTION_BEGIN:
    WidgetTriggerActionResult = 2;
#[doc = " The action was handled and should stop the grab for motion events"]
pub const WidgetTriggerActionResult_WIDGET_TRIGGER_ACTION_RESULT_GRAB_MOTION_END:
    WidgetTriggerActionResult = 3;
#[doc = " Whether and how the action was handled"]
pub type WidgetTriggerActionResult = u32;
#[doc = " @param widget The container widget itself"]
#[doc = " @param type The widget type searched for"]
#[doc = " @param x The X coordination of the mouse event relative to @param widget"]
#[doc = " @param y The Y coordination of the mouse event relative to @param widget"]
#[doc = ""]
#[doc = " This callback must only iterate over the children of a Widget, and return NULL if none of them is relevant."]
#[doc = ""]
#[doc = " @returns A child widget if found, NULL otherwise"]
pub type widget_find_mouse_target_cb = ::core::option::Option<
    unsafe extern "C" fn(widget: *mut widget, type_: WidgetType, x: gint, y: gint) -> *mut widget,
>;
#[doc = " @param widget The target widget"]
#[doc = " @param action The action value (which enum it is depends on the widget type)"]
#[doc = " @param x The X coordination of the mouse event relative to @param widget"]
#[doc = " @param y The Y coordination of the mouse event relative to @param widget"]
#[doc = " @param user_data The data passed to widget_set_trigger_action_handler()"]
#[doc = ""]
#[doc = " This callback should handle the action if relevant, and returns whether it did or not."]
#[doc = ""]
#[doc = " @returns Whether the action was handled or not, see enum values for details"]
pub type widget_trigger_action_cb = ::core::option::Option<
    unsafe extern "C" fn(
        widget: *mut widget,
        action: guint,
        x: gint,
        y: gint,
        user_data: *mut cty::c_void,
    ) -> WidgetTriggerActionResult,
>;
extern "C" {
    #[doc = " @param widget The widget to check"]
    #[doc = " @param x The X position relative to parent window"]
    #[doc = " @param y the Y position relative to parent window"]
    #[doc = ""]
    #[doc = " Check if x,y falls within the widget."]
    #[doc = ""]
    #[doc = " @return TRUE if x,y falls within the widget"]
    pub fn widget_intersect(widget: *const widget, x: cty::c_int, y: cty::c_int) -> cty::c_int;
}
extern "C" {
    #[doc = " @param widget The widget to move"]
    #[doc = " @param x The new X position relative to parent window"]
    #[doc = " @param y The new Y position relative to parent window"]
    #[doc = ""]
    #[doc = " Moves the widget."]
    pub fn widget_move(widget: *mut widget, x: cty::c_short, y: cty::c_short);
}
extern "C" {
    #[doc = " @param widget Handle to widget"]
    #[doc = ""]
    #[doc = " Get the type of the widget."]
    #[doc = " @returns The type of the widget."]
    pub fn widget_type(widget: *mut widget) -> WidgetType;
}
extern "C" {
    #[doc = " @param widget Handle to widget"]
    #[doc = " @param type The widget type."]
    #[doc = ""]
    #[doc = " Set the widget type."]
    pub fn widget_set_type(widget: *mut widget, type_: WidgetType);
}
extern "C" {
    #[doc = " @param widget Handle to widget"]
    #[doc = ""]
    #[doc = " Check if widget is enabled."]
    #[doc = " @returns TRUE when widget is enabled."]
    pub fn widget_enabled(widget: *mut widget) -> gboolean;
}
extern "C" {
    #[doc = " @param widget Handle to widget"]
    #[doc = " @param enabled The new state"]
    #[doc = ""]
    #[doc = " Disable the widget."]
    pub fn widget_set_enabled(widget: *mut widget, enabled: gboolean);
}
extern "C" {
    #[doc = " @param widget widget  Handle to the widget"]
    #[doc = " @param d The cairo object used to draw itself."]
    #[doc = ""]
    #[doc = " Render the textbox."]
    pub fn widget_draw(widget: *mut widget, d: *mut cairo_t);
}
extern "C" {
    #[doc = " @param wid Handle to the widget"]
    #[doc = ""]
    #[doc = " Free the widget and all allocated memory."]
    pub fn widget_free(wid: *mut widget);
}
extern "C" {
    #[doc = " @param widget The widget toresize"]
    #[doc = " @param w The new width"]
    #[doc = " @param h The new height"]
    #[doc = ""]
    #[doc = " Resizes the widget."]
    pub fn widget_resize(widget: *mut widget, w: cty::c_short, h: cty::c_short);
}
extern "C" {
    #[doc = " @param widget The widget handle"]
    #[doc = ""]
    #[doc = " @returns the height of the widget."]
    pub fn widget_get_height(widget: *mut widget) -> cty::c_int;
}
extern "C" {
    #[doc = " @param widget The widget handle"]
    #[doc = ""]
    #[doc = " @returns the width of the widget."]
    pub fn widget_get_width(widget: *mut widget) -> cty::c_int;
}
extern "C" {
    #[doc = " @param widget The widget handle"]
    #[doc = ""]
    #[doc = " @returns the y position of the widget relative to its parent."]
    pub fn widget_get_y_pos(widget: *mut widget) -> cty::c_int;
}
extern "C" {
    #[doc = " @param widget The widget handle"]
    #[doc = ""]
    #[doc = " @returns the x position of the widget relative to its parent."]
    pub fn widget_get_x_pos(widget: *mut widget) -> cty::c_int;
}
extern "C" {
    #[doc = " @param widget The widget handle"]
    #[doc = " @param x A pointer to the absolute X coordinates"]
    #[doc = " @param y A pointer to the absolute Y coordinates"]
    #[doc = ""]
    #[doc = " Will modify @param x and @param y to make them relative to @param widget ."]
    pub fn widget_xy_to_relative(widget: *mut widget, x: *mut gint, y: *mut gint);
}
extern "C" {
    #[doc = " @param widget The widget handle"]
    #[doc = ""]
    #[doc = " Update the widget, and its parent recursively."]
    #[doc = " This should be called when size of widget changes."]
    pub fn widget_update(widget: *mut widget);
}
extern "C" {
    #[doc = " @param wid The widget handle"]
    #[doc = ""]
    #[doc = " Indicate that the widget needs to be redrawn."]
    #[doc = " This is done by setting the redraw flag on the toplevel widget."]
    pub fn widget_queue_redraw(wid: *mut widget);
}
extern "C" {
    #[doc = " @param wid The widget handle"]
    #[doc = ""]
    #[doc = " Check the flag indicating the widget needs to be redrawn."]
    pub fn widget_need_redraw(wid: *mut widget) -> gboolean;
}
extern "C" {
    #[doc = " @param wid The widget handle"]
    #[doc = " @param type The type of the wanted widget"]
    #[doc = " @param x The x coordinate of the mouse event"]
    #[doc = " @param y The y coordinate of the mouse event"]
    #[doc = ""]
    #[doc = " Get the widget that should handle a mouse event."]
    #[doc = ""]
    #[doc = " @returns returns the widget that should handle the mouse event."]
    pub fn widget_find_mouse_target(
        wid: *mut widget,
        type_: WidgetType,
        x: gint,
        y: gint,
    ) -> *mut widget;
}
extern "C" {
    #[doc = " @param wid The widget handle"]
    #[doc = " @param action The action to trigger"]
    #[doc = " @param x A pointer to the x coordinate of the click"]
    #[doc = " @param y A pointer to the y coordinate of the click"]
    #[doc = ""]
    #[doc = " Trigger an action on widget."]
    #[doc = " @param x and @param y are relative to @param wid ."]
    #[doc = ""]
    #[doc = " @returns Whether the action was handled or not"]
    pub fn widget_trigger_action(
        wid: *mut widget,
        action: guint,
        x: gint,
        y: gint,
    ) -> WidgetTriggerActionResult;
}
extern "C" {
    #[doc = " @param wid The widget handle"]
    #[doc = " @param cb The widget trigger action callback"]
    #[doc = " @param cb_data the user data to pass to callback"]
    #[doc = ""]
    #[doc = " Override the widget trigger action handler on widget."]
    pub fn widget_set_trigger_action_handler(
        wid: *mut widget,
        cb: widget_trigger_action_cb,
        cb_data: *mut cty::c_void,
    );
}
extern "C" {
    #[doc = " @param wid The widget handle"]
    #[doc = " @param x The x coordinate of the mouse event"]
    #[doc = " @param y The y coordinate of the mouse event"]
    #[doc = ""]
    #[doc = " Motion notify."]
    #[doc = ""]
    #[doc = " @returns TRUE when handled."]
    pub fn widget_motion_notify(wid: *mut widget, x: gint, y: gint) -> gboolean;
}
extern "C" {
    #[doc = " @param wid The widget handle"]
    #[doc = ""]
    #[doc = " Get the desired height of this widget recursively."]
    #[doc = ""]
    #[doc = " @returns the desired height of the widget in pixels."]
    pub fn widget_get_desired_height(wid: *mut widget) -> cty::c_int;
}
extern "C" {
    #[doc = " @param wid The widget handle"]
    #[doc = ""]
    #[doc = " Get the desired width of this widget recursively."]
    #[doc = ""]
    #[doc = " @returns the desired width of the widget in pixels."]
    pub fn widget_get_desired_width(wid: *mut widget) -> cty::c_int;
}
extern "C" {
    #[doc = " @param wid The widget handle"]
    #[doc = ""]
    #[doc = " Get the absolute x-position on the root widget.."]
    #[doc = ""]
    #[doc = " @returns the absolute x-position of widget of the widget in pixels."]
    pub fn widget_get_absolute_xpos(wid: *mut widget) -> cty::c_int;
}
extern "C" {
    #[doc = " @param wid The widget handle"]
    #[doc = ""]
    #[doc = " Get the absolute y-position on the root widget.."]
    #[doc = ""]
    #[doc = " @returns the absolute y-position of widget of the widget in pixels."]
    pub fn widget_get_absolute_ypos(wid: *mut widget) -> cty::c_int;
}
#[doc = " Integer"]
pub const PropertyType_P_INTEGER: PropertyType = 0;
#[doc = " Double"]
pub const PropertyType_P_DOUBLE: PropertyType = 1;
#[doc = " String"]
pub const PropertyType_P_STRING: PropertyType = 2;
#[doc = " Character"]
pub const PropertyType_P_CHAR: PropertyType = 3;
#[doc = " Boolean"]
pub const PropertyType_P_BOOLEAN: PropertyType = 4;
#[doc = " Color"]
pub const PropertyType_P_COLOR: PropertyType = 5;
#[doc = " RofiPadding"]
pub const PropertyType_P_PADDING: PropertyType = 6;
#[doc = " Link to global setting"]
pub const PropertyType_P_LINK: PropertyType = 7;
#[doc = " Position"]
pub const PropertyType_P_POSITION: PropertyType = 8;
#[doc = " Highlight"]
pub const PropertyType_P_HIGHLIGHT: PropertyType = 9;
#[doc = " List"]
pub const PropertyType_P_LIST: PropertyType = 10;
#[doc = " Orientation"]
pub const PropertyType_P_ORIENTATION: PropertyType = 11;
#[doc = " Inherit"]
pub const PropertyType_P_INHERIT: PropertyType = 12;
#[doc = " Number of types."]
pub const PropertyType_P_NUM_TYPES: PropertyType = 13;
#[doc = " Type of property"]
pub type PropertyType = u32;
extern "C" {
    pub static PropertyTypeName: [*const cty::c_char; 13usize];
}
#[doc = " no highlight"]
pub const RofiHighlightStyle_ROFI_HL_NONE: RofiHighlightStyle = 0;
#[doc = " bold"]
pub const RofiHighlightStyle_ROFI_HL_BOLD: RofiHighlightStyle = 1;
#[doc = " underline"]
pub const RofiHighlightStyle_ROFI_HL_UNDERLINE: RofiHighlightStyle = 2;
#[doc = " strikethrough"]
pub const RofiHighlightStyle_ROFI_HL_STRIKETHROUGH: RofiHighlightStyle = 16;
#[doc = " small caps"]
pub const RofiHighlightStyle_ROFI_HL_SMALL_CAPS: RofiHighlightStyle = 32;
#[doc = " italic"]
pub const RofiHighlightStyle_ROFI_HL_ITALIC: RofiHighlightStyle = 4;
#[doc = " color"]
pub const RofiHighlightStyle_ROFI_HL_COLOR: RofiHighlightStyle = 8;
#[doc = " Style of text highlight"]
pub type RofiHighlightStyle = u32;
#[doc = " Solid line"]
pub const RofiLineStyle_ROFI_HL_SOLID: RofiLineStyle = 0;
#[doc = " Dashed line"]
pub const RofiLineStyle_ROFI_HL_DASH: RofiLineStyle = 1;
#[doc = " Style of line"]
pub type RofiLineStyle = u32;
#[doc = " PixelWidth in pixels."]
pub const RofiPixelUnit_ROFI_PU_PX: RofiPixelUnit = 0;
#[doc = " PixelWidth in millimeters."]
pub const RofiPixelUnit_ROFI_PU_MM: RofiPixelUnit = 1;
#[doc = " PixelWidth in EM."]
pub const RofiPixelUnit_ROFI_PU_EM: RofiPixelUnit = 2;
#[doc = " PixelWidget in percentage"]
pub const RofiPixelUnit_ROFI_PU_PERCENT: RofiPixelUnit = 3;
#[doc = " PixelWidth in CH."]
pub const RofiPixelUnit_ROFI_PU_CH: RofiPixelUnit = 4;
#[doc = " Distance unit type."]
pub type RofiPixelUnit = u32;
pub const RofiDistanceModifier_ROFI_DISTANCE_MODIFIER_NONE: RofiDistanceModifier = 0;
pub const RofiDistanceModifier_ROFI_DISTANCE_MODIFIER_ADD: RofiDistanceModifier = 1;
pub const RofiDistanceModifier_ROFI_DISTANCE_MODIFIER_SUBTRACT: RofiDistanceModifier = 2;
pub const RofiDistanceModifier_ROFI_DISTANCE_MODIFIER_DIVIDE: RofiDistanceModifier = 3;
pub const RofiDistanceModifier_ROFI_DISTANCE_MODIFIER_MULTIPLY: RofiDistanceModifier = 4;
pub const RofiDistanceModifier_ROFI_DISTANCE_MODIFIER_MODULO: RofiDistanceModifier = 5;
pub const RofiDistanceModifier_ROFI_DISTANCE_MODIFIER_GROUP: RofiDistanceModifier = 6;
#[doc = " Structure representing a distance."]
pub type RofiDistanceModifier = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RofiDistanceUnit {
    #[doc = " Distance"]
    pub distance: f64,
    #[doc = " Unit type of the distance"]
    pub type_: RofiPixelUnit,
    #[doc = " Type"]
    pub modtype: RofiDistanceModifier,
    #[doc = " Modifier"]
    pub left: *mut RofiDistanceUnit,
    #[doc = " Modifier"]
    pub right: *mut RofiDistanceUnit,
}
#[test]
fn bindgen_test_layout_RofiDistanceUnit() {
    assert_eq!(
        ::core::mem::size_of::<RofiDistanceUnit>(),
        32usize,
        concat!("Size of: ", stringify!(RofiDistanceUnit))
    );
    assert_eq!(
        ::core::mem::align_of::<RofiDistanceUnit>(),
        8usize,
        concat!("Alignment of ", stringify!(RofiDistanceUnit))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RofiDistanceUnit>())).distance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RofiDistanceUnit),
            "::",
            stringify!(distance)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RofiDistanceUnit>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RofiDistanceUnit),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RofiDistanceUnit>())).modtype as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RofiDistanceUnit),
            "::",
            stringify!(modtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RofiDistanceUnit>())).left as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RofiDistanceUnit),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RofiDistanceUnit>())).right as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RofiDistanceUnit),
            "::",
            stringify!(right)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RofiDistance {
    #[doc = " Base"]
    pub base: RofiDistanceUnit,
    #[doc = " Style of the line (optional)"]
    pub style: RofiLineStyle,
}
#[test]
fn bindgen_test_layout_RofiDistance() {
    assert_eq!(
        ::core::mem::size_of::<RofiDistance>(),
        40usize,
        concat!("Size of: ", stringify!(RofiDistance))
    );
    assert_eq!(
        ::core::mem::align_of::<RofiDistance>(),
        8usize,
        concat!("Alignment of ", stringify!(RofiDistance))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RofiDistance>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RofiDistance),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RofiDistance>())).style as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RofiDistance),
            "::",
            stringify!(style)
        )
    );
}
pub const RofiOrientation_ROFI_ORIENTATION_VERTICAL: RofiOrientation = 0;
pub const RofiOrientation_ROFI_ORIENTATION_HORIZONTAL: RofiOrientation = 1;
#[doc = " Type of orientation."]
pub type RofiOrientation = u32;
#[doc = " Represent the color in theme."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ThemeColor {
    #[doc = " red channel"]
    pub red: f64,
    #[doc = " green channel"]
    pub green: f64,
    #[doc = " blue channel"]
    pub blue: f64,
    #[doc = "  alpha channel"]
    pub alpha: f64,
}
#[test]
fn bindgen_test_layout_ThemeColor() {
    assert_eq!(
        ::core::mem::size_of::<ThemeColor>(),
        32usize,
        concat!("Size of: ", stringify!(ThemeColor))
    );
    assert_eq!(
        ::core::mem::align_of::<ThemeColor>(),
        8usize,
        concat!("Alignment of ", stringify!(ThemeColor))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThemeColor>())).red as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ThemeColor),
            "::",
            stringify!(red)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThemeColor>())).green as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ThemeColor),
            "::",
            stringify!(green)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThemeColor>())).blue as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ThemeColor),
            "::",
            stringify!(blue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThemeColor>())).alpha as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ThemeColor),
            "::",
            stringify!(alpha)
        )
    );
}
#[doc = " RofiPadding"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RofiPadding {
    pub top: RofiDistance,
    pub right: RofiDistance,
    pub bottom: RofiDistance,
    pub left: RofiDistance,
}
#[test]
fn bindgen_test_layout_RofiPadding() {
    assert_eq!(
        ::core::mem::size_of::<RofiPadding>(),
        160usize,
        concat!("Size of: ", stringify!(RofiPadding))
    );
    assert_eq!(
        ::core::mem::align_of::<RofiPadding>(),
        8usize,
        concat!("Alignment of ", stringify!(RofiPadding))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RofiPadding>())).top as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RofiPadding),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RofiPadding>())).right as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(RofiPadding),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RofiPadding>())).bottom as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(RofiPadding),
            "::",
            stringify!(bottom)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RofiPadding>())).left as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(RofiPadding),
            "::",
            stringify!(left)
        )
    );
}
#[doc = " Theme highlight."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RofiHighlightColorStyle {
    #[doc = " style to display"]
    pub style: RofiHighlightStyle,
    #[doc = " Color"]
    pub color: ThemeColor,
}
#[test]
fn bindgen_test_layout_RofiHighlightColorStyle() {
    assert_eq!(
        ::core::mem::size_of::<RofiHighlightColorStyle>(),
        40usize,
        concat!("Size of: ", stringify!(RofiHighlightColorStyle))
    );
    assert_eq!(
        ::core::mem::align_of::<RofiHighlightColorStyle>(),
        8usize,
        concat!("Alignment of ", stringify!(RofiHighlightColorStyle))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RofiHighlightColorStyle>())).style as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RofiHighlightColorStyle),
            "::",
            stringify!(style)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RofiHighlightColorStyle>())).color as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RofiHighlightColorStyle),
            "::",
            stringify!(color)
        )
    );
}
#[doc = " Center"]
pub const WindowLocation_WL_CENTER: WindowLocation = 0;
#[doc = " Top middle"]
pub const WindowLocation_WL_NORTH: WindowLocation = 1;
#[doc = " Middle right"]
pub const WindowLocation_WL_EAST: WindowLocation = 2;
#[doc = " Bottom middle"]
pub const WindowLocation_WL_SOUTH: WindowLocation = 4;
#[doc = " Middle left"]
pub const WindowLocation_WL_WEST: WindowLocation = 8;
#[doc = " Left top corner."]
pub const WindowLocation_WL_NORTH_WEST: WindowLocation = 9;
#[doc = " Top right"]
pub const WindowLocation_WL_NORTH_EAST: WindowLocation = 3;
#[doc = " Bottom right"]
pub const WindowLocation_WL_SOUTH_EAST: WindowLocation = 6;
#[doc = " Bottom left"]
pub const WindowLocation_WL_SOUTH_WEST: WindowLocation = 12;
#[doc = " Enumeration indicating location or gravity of window."]
#[doc = ""]
#[doc = " \\verbatim WL_NORTH_WEST      WL_NORTH      WL_NORTH_EAST \\endverbatim"]
#[doc = " \\verbatim WL_EAST            WL_CENTER     WL_EAST \\endverbatim"]
#[doc = " \\verbatim WL_SOUTH_WEST      WL_SOUTH      WL_SOUTH_EAST\\endverbatim"]
#[doc = ""]
#[doc = " @ingroup CONFIGURATION"]
pub type WindowLocation = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PropertyValue {
    #[doc = " integer"]
    pub i: cty::c_int,
    #[doc = " Double"]
    pub f: f64,
    #[doc = " String"]
    pub s: *mut cty::c_char,
    #[doc = " Character"]
    pub c: cty::c_char,
    #[doc = " boolean"]
    pub b: gboolean,
    #[doc = " Color"]
    pub color: ThemeColor,
    #[doc = " RofiPadding"]
    pub padding: RofiPadding,
    pub link: _PropertyValue__bindgen_ty_1,
    #[doc = " Highlight Style"]
    pub highlight: RofiHighlightColorStyle,
    #[doc = " List"]
    pub list: *mut GList,
    _bindgen_union_align: [u64; 20usize],
}
#[doc = " Reference"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PropertyValue__bindgen_ty_1 {
    #[doc = " Name"]
    pub name: *mut cty::c_char,
    #[doc = " Cached looked up ref"]
    pub ref_: *mut Property,
    #[doc = " Property default"]
    pub def_value: *mut Property,
}
#[test]
fn bindgen_test_layout__PropertyValue__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_PropertyValue__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(_PropertyValue__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_PropertyValue__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_PropertyValue__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_PropertyValue__bindgen_ty_1>())).name as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PropertyValue__bindgen_ty_1),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_PropertyValue__bindgen_ty_1>())).ref_ as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PropertyValue__bindgen_ty_1),
            "::",
            stringify!(ref_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_PropertyValue__bindgen_ty_1>())).def_value as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_PropertyValue__bindgen_ty_1),
            "::",
            stringify!(def_value)
        )
    );
}
#[test]
fn bindgen_test_layout__PropertyValue() {
    assert_eq!(
        ::core::mem::size_of::<_PropertyValue>(),
        160usize,
        concat!("Size of: ", stringify!(_PropertyValue))
    );
    assert_eq!(
        ::core::mem::align_of::<_PropertyValue>(),
        8usize,
        concat!("Alignment of ", stringify!(_PropertyValue))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PropertyValue>())).i as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PropertyValue),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PropertyValue>())).f as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PropertyValue),
            "::",
            stringify!(f)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PropertyValue>())).s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PropertyValue),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PropertyValue>())).c as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PropertyValue),
            "::",
            stringify!(c)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PropertyValue>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PropertyValue),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PropertyValue>())).color as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PropertyValue),
            "::",
            stringify!(color)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PropertyValue>())).padding as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PropertyValue),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PropertyValue>())).link as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PropertyValue),
            "::",
            stringify!(link)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PropertyValue>())).highlight as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PropertyValue),
            "::",
            stringify!(highlight)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_PropertyValue>())).list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PropertyValue),
            "::",
            stringify!(list)
        )
    );
}
pub type PropertyValue = _PropertyValue;
#[doc = " Property structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Property {
    #[doc = " Name of property"]
    pub name: *mut cty::c_char,
    #[doc = " Type of property."]
    pub type_: PropertyType,
    #[doc = " Value"]
    pub value: PropertyValue,
}
#[test]
fn bindgen_test_layout_Property() {
    assert_eq!(
        ::core::mem::size_of::<Property>(),
        176usize,
        concat!("Size of: ", stringify!(Property))
    );
    assert_eq!(
        ::core::mem::align_of::<Property>(),
        8usize,
        concat!("Alignment of ", stringify!(Property))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Property>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Property),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Property>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Property),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<Property>())).value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Property),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " Structure to hold a range."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rofi_range_pair {
    pub start: cty::c_int,
    pub stop: cty::c_int,
}
#[test]
fn bindgen_test_layout_rofi_range_pair() {
    assert_eq!(
        ::core::mem::size_of::<rofi_range_pair>(),
        8usize,
        concat!("Size of: ", stringify!(rofi_range_pair))
    );
    assert_eq!(
        ::core::mem::align_of::<rofi_range_pair>(),
        4usize,
        concat!("Alignment of ", stringify!(rofi_range_pair))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rofi_range_pair>())).start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rofi_range_pair),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rofi_range_pair>())).stop as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rofi_range_pair),
            "::",
            stringify!(stop)
        )
    );
}
#[doc = " Internal structure for matching."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rofi_int_matcher_t {
    pub regex: *mut GRegex,
    pub invert: gboolean,
}
#[test]
fn bindgen_test_layout_rofi_int_matcher_t() {
    assert_eq!(
        ::core::mem::size_of::<rofi_int_matcher_t>(),
        16usize,
        concat!("Size of: ", stringify!(rofi_int_matcher_t))
    );
    assert_eq!(
        ::core::mem::align_of::<rofi_int_matcher_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rofi_int_matcher_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rofi_int_matcher_t>())).regex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rofi_int_matcher_t),
            "::",
            stringify!(regex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rofi_int_matcher_t>())).invert as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rofi_int_matcher_t),
            "::",
            stringify!(invert)
        )
    );
}
#[doc = " Internal structure for matching."]
pub type rofi_int_matcher = rofi_int_matcher_t;
#[doc = " Structure with data to process by each worker thread."]
#[doc = " TODO: Make this more generic wrapper."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _thread_state {
    pub callback:
        ::core::option::Option<unsafe extern "C" fn(t: *mut _thread_state, data: gpointer)>,
}
#[test]
fn bindgen_test_layout__thread_state() {
    assert_eq!(
        ::core::mem::size_of::<_thread_state>(),
        8usize,
        concat!("Size of: ", stringify!(_thread_state))
    );
    assert_eq!(
        ::core::mem::align_of::<_thread_state>(),
        8usize,
        concat!("Alignment of ", stringify!(_thread_state))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_thread_state>())).callback as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_thread_state),
            "::",
            stringify!(callback)
        )
    );
}
#[doc = " Structure with data to process by each worker thread."]
#[doc = " TODO: Make this more generic wrapper."]
pub type thread_state = _thread_state;
extern "C" {
    pub static mut tpool: *mut GThreadPool;
}
#[doc = " Minimum width constraint."]
pub const ThemeMediaType_THEME_MEDIA_TYPE_MIN_WIDTH: ThemeMediaType = 0;
#[doc = " Maximum width constraint."]
pub const ThemeMediaType_THEME_MEDIA_TYPE_MAX_WIDTH: ThemeMediaType = 1;
#[doc = " Minimum height constraint."]
pub const ThemeMediaType_THEME_MEDIA_TYPE_MIN_HEIGHT: ThemeMediaType = 2;
#[doc = " Maximum height constraint."]
pub const ThemeMediaType_THEME_MEDIA_TYPE_MAX_HEIGHT: ThemeMediaType = 3;
#[doc = " Monitor id constraint."]
pub const ThemeMediaType_THEME_MEDIA_TYPE_MON_ID: ThemeMediaType = 4;
#[doc = " Minimum aspect ratio constraint."]
pub const ThemeMediaType_THEME_MEDIA_TYPE_MIN_ASPECT_RATIO: ThemeMediaType = 5;
#[doc = " Maximum aspect ratio constraint."]
pub const ThemeMediaType_THEME_MEDIA_TYPE_MAX_ASPECT_RATIO: ThemeMediaType = 6;
#[doc = " Invalid entry."]
pub const ThemeMediaType_THEME_MEDIA_TYPE_INVALID: ThemeMediaType = 7;
#[doc = " Describe the media constraint type."]
pub type ThemeMediaType = u32;
#[doc = " Theme Media description."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ThemeMedia {
    pub type_: ThemeMediaType,
    pub value: f64,
}
#[test]
fn bindgen_test_layout_ThemeMedia() {
    assert_eq!(
        ::core::mem::size_of::<ThemeMedia>(),
        16usize,
        concat!("Size of: ", stringify!(ThemeMedia))
    );
    assert_eq!(
        ::core::mem::align_of::<ThemeMedia>(),
        8usize,
        concat!("Alignment of ", stringify!(ThemeMedia))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThemeMedia>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ThemeMedia),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThemeMedia>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ThemeMedia),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " ThemeWidget."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ThemeWidget {
    pub set: cty::c_int,
    pub name: *mut cty::c_char,
    pub num_widgets: cty::c_uint,
    pub widgets: *mut *mut ThemeWidget,
    pub media: *mut ThemeMedia,
    pub properties: *mut GHashTable,
    pub parent: *mut ThemeWidget,
}
#[test]
fn bindgen_test_layout_ThemeWidget() {
    assert_eq!(
        ::core::mem::size_of::<ThemeWidget>(),
        56usize,
        concat!("Size of: ", stringify!(ThemeWidget))
    );
    assert_eq!(
        ::core::mem::align_of::<ThemeWidget>(),
        8usize,
        concat!("Alignment of ", stringify!(ThemeWidget))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThemeWidget>())).set as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ThemeWidget),
            "::",
            stringify!(set)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThemeWidget>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ThemeWidget),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThemeWidget>())).num_widgets as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ThemeWidget),
            "::",
            stringify!(num_widgets)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThemeWidget>())).widgets as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ThemeWidget),
            "::",
            stringify!(widgets)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThemeWidget>())).media as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ThemeWidget),
            "::",
            stringify!(media)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThemeWidget>())).properties as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ThemeWidget),
            "::",
            stringify!(properties)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ThemeWidget>())).parent as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ThemeWidget),
            "::",
            stringify!(parent)
        )
    );
}
extern "C" {
    pub static mut rofi_theme: *mut ThemeWidget;
}
extern "C" {
    #[doc = " @param base Handle to the current level in the theme."]
    #[doc = " @param name Name of the new element."]
    #[doc = ""]
    #[doc = " Create a new element in the theme structure."]
    #[doc = ""]
    #[doc = " @returns handle to the new entry."]
    pub fn rofi_theme_find_or_create_name(
        base: *mut ThemeWidget,
        name: *const cty::c_char,
    ) -> *mut ThemeWidget;
}
extern "C" {
    #[doc = " @param widget The widget handle."]
    #[doc = ""]
    #[doc = " Print out the widget to the commandline."]
    pub fn rofi_theme_print(widget: *mut ThemeWidget);
}
extern "C" {
    #[doc = " @param type The type of the property to create."]
    #[doc = ""]
    #[doc = " Create a theme property of type."]
    #[doc = ""]
    #[doc = " @returns a new property."]
    pub fn rofi_theme_property_create(type_: PropertyType) -> *mut Property;
}
extern "C" {
    #[doc = " @param p The property to free."]
    #[doc = ""]
    #[doc = " Free the content of the property."]
    pub fn rofi_theme_property_free(p: *mut Property);
}
extern "C" {
    #[doc = " @param p The property to free."]
    #[doc = ""]
    #[doc = " @returns a copy of p"]
    pub fn rofi_theme_property_copy(p: *mut Property) -> *mut Property;
}
extern "C" {
    #[doc = " @param widget"]
    #[doc = ""]
    #[doc = " Free the widget and alll children."]
    pub fn rofi_theme_free(widget: *mut ThemeWidget);
}
extern "C" {
    #[doc = " @param file filename to parse."]
    #[doc = ""]
    #[doc = " Parse the input theme file."]
    #[doc = ""]
    #[doc = " @returns returns TRUE when error."]
    pub fn rofi_theme_parse_file(file: *const cty::c_char) -> gboolean;
}
extern "C" {
    #[doc = " @param string to parse."]
    #[doc = ""]
    #[doc = " Parse the input string in addition to theme file."]
    #[doc = ""]
    #[doc = " @returns returns TRUE when error."]
    pub fn rofi_theme_parse_string(string: *const cty::c_char) -> gboolean;
}
extern "C" {
    #[doc = " @param widget The widget handle."]
    #[doc = " @param table HashTable containing properties set."]
    #[doc = ""]
    #[doc = " Merge properties with widgets current property."]
    pub fn rofi_theme_widget_add_properties(widget: *mut ThemeWidget, table: *mut GHashTable);
}
extern "C" {
    #[doc = " @param widget   The widget to query"]
    #[doc = " @param property The property to query."]
    #[doc = " @param def      The default value."]
    #[doc = ""]
    #[doc = " Obtain the distance of the widget."]
    #[doc = ""]
    #[doc = " @returns The distance value of this property for this widget."]
    pub fn rofi_theme_get_distance(
        widget: *const widget,
        property: *const cty::c_char,
        def: cty::c_int,
    ) -> RofiDistance;
}
extern "C" {
    #[doc = " @param widget   The widget to query"]
    #[doc = " @param property The property to query."]
    #[doc = " @param def      The default value."]
    #[doc = ""]
    #[doc = " Obtain the integer of the widget."]
    #[doc = ""]
    #[doc = " @returns The integer value of this property for this widget."]
    pub fn rofi_theme_get_integer(
        widget: *const widget,
        property: *const cty::c_char,
        def: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @param widget   The widget to query"]
    #[doc = " @param property The property to query."]
    #[doc = " @param def      The default value."]
    #[doc = ""]
    #[doc = " Obtain the position of the widget."]
    #[doc = ""]
    #[doc = " @returns The position value of this property for this widget."]
    pub fn rofi_theme_get_position(
        widget: *const widget,
        property: *const cty::c_char,
        def: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @param widget   The widget to query"]
    #[doc = " @param property The property to query."]
    #[doc = " @param def      The default value."]
    #[doc = ""]
    #[doc = " Obtain the boolean of the widget."]
    #[doc = ""]
    #[doc = " @returns The boolean value of this property for this widget."]
    pub fn rofi_theme_get_boolean(
        widget: *const widget,
        property: *const cty::c_char,
        def: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @param widget   The widget to query"]
    #[doc = " @param property The property to query."]
    #[doc = " @param def      The default value."]
    #[doc = ""]
    #[doc = " Obtain the orientation indicated by %property of the widget."]
    #[doc = ""]
    #[doc = " @returns The orientation of this property for this widget or %def not found."]
    pub fn rofi_theme_get_orientation(
        widget: *const widget,
        property: *const cty::c_char,
        def: RofiOrientation,
    ) -> RofiOrientation;
}
extern "C" {
    #[doc = " @param widget   The widget to query"]
    #[doc = " @param property The property to query."]
    #[doc = " @param def      The default value."]
    #[doc = ""]
    #[doc = " Obtain the string of the widget."]
    #[doc = ""]
    #[doc = " @returns The string value of this property for this widget."]
    pub fn rofi_theme_get_string(
        widget: *const widget,
        property: *const cty::c_char,
        def: *const cty::c_char,
    ) -> *const cty::c_char;
}
extern "C" {
    #[doc = " @param widget   The widget to query"]
    #[doc = " @param property The property to query."]
    #[doc = " @param def      The default value."]
    #[doc = ""]
    #[doc = " Obtain the double of the widget."]
    #[doc = ""]
    #[doc = " @returns The double value of this property for this widget."]
    pub fn rofi_theme_get_double(
        widget: *const widget,
        property: *const cty::c_char,
        def: f64,
    ) -> f64;
}
extern "C" {
    #[doc = " @param widget   The widget to query"]
    #[doc = " @param property The property to query."]
    #[doc = " @param d        The drawable to apply color."]
    #[doc = ""]
    #[doc = " Obtain the color of the widget and applies this to the drawable d."]
    #[doc = ""]
    pub fn rofi_theme_get_color(
        widget: *const widget,
        property: *const cty::c_char,
        d: *mut cairo_t,
    );
}
extern "C" {
    #[doc = " @param widget   The widget to query"]
    #[doc = " @param property The property to query."]
    #[doc = ""]
    #[doc = " Check if a rofi theme has a property set."]
    #[doc = ""]
    pub fn rofi_theme_has_property(widget: *const widget, property: *const cty::c_char)
        -> gboolean;
}
extern "C" {
    #[doc = " @param widget   The widget to query"]
    #[doc = " @param property The property to query."]
    #[doc = " @param pad      The default value."]
    #[doc = ""]
    #[doc = " Obtain the padding of the widget."]
    #[doc = ""]
    #[doc = " @returns The padding of this property for this widget."]
    pub fn rofi_theme_get_padding(
        widget: *const widget,
        property: *const cty::c_char,
        pad: RofiPadding,
    ) -> RofiPadding;
}
extern "C" {
    #[doc = " @param widget   The widget to query"]
    #[doc = " @param property The property to query."]
    #[doc = " @param th The default value."]
    #[doc = ""]
    #[doc = " Obtain the highlight ."]
    #[doc = ""]
    #[doc = " @returns The highlight of this property for this widget."]
    pub fn rofi_theme_get_highlight(
        widget: *mut widget,
        property: *const cty::c_char,
        th: RofiHighlightColorStyle,
    ) -> RofiHighlightColorStyle;
}
extern "C" {
    #[doc = " @param d The distance handle."]
    #[doc = " @param ori The orientation."]
    #[doc = ""]
    #[doc = " Convert RofiDistance into pixels."]
    #[doc = " @returns the number of pixels this distance represents."]
    pub fn distance_get_pixel(d: RofiDistance, ori: RofiOrientation) -> cty::c_int;
}
extern "C" {
    #[doc = " @param d The distance handle."]
    #[doc = " @param draw The cairo drawable."]
    #[doc = ""]
    #[doc = " Set linestyle."]
    pub fn distance_get_linestyle(d: RofiDistance, draw: *mut cairo_t);
}
extern "C" {
    #[doc = " Low-level functions."]
    #[doc = " These can be used by non-widgets to obtain values."]
    #[doc = " @param name The name of the element to find."]
    #[doc = " @param state The state of the element."]
    #[doc = " @param exact If the match should be exact, or parent can be included."]
    #[doc = ""]
    #[doc = " Find the theme element. If not exact, the closest specified element is returned."]
    #[doc = ""]
    #[doc = " @returns the ThemeWidget if found, otherwise NULL."]
    pub fn rofi_theme_find_widget(
        name: *const cty::c_char,
        state: *const cty::c_char,
        exact: gboolean,
    ) -> *mut ThemeWidget;
}
extern "C" {
    #[doc = " @param widget The widget to find the property on."]
    #[doc = " @param type   The %PropertyType to find."]
    #[doc = " @param property The property to find."]
    #[doc = " @param exact  If the property should only be found on this widget, or on parents if not found."]
    #[doc = ""]
    #[doc = " Find the property on the widget. If not exact, the parents are searched recursively until match is found."]
    #[doc = ""]
    #[doc = " @returns the Property if found, otherwise NULL."]
    pub fn rofi_theme_find_property(
        widget: *mut ThemeWidget,
        type_: PropertyType,
        property: *const cty::c_char,
        exact: gboolean,
    ) -> *mut Property;
}
extern "C" {
    #[doc = " @param widget   The widget to query"]
    #[doc = " @param property The property to query."]
    #[doc = " @param defaults The default value."]
    #[doc = ""]
    #[doc = " Obtain list of elements (strings) of the widget."]
    #[doc = ""]
    #[doc = " @returns a GList holding the names in the list of this property for this widget."]
    pub fn rofi_theme_get_list(
        widget: *const widget,
        property: *const cty::c_char,
        defaults: *const cty::c_char,
    ) -> *mut GList;
}
extern "C" {
    #[doc = " Checks if a theme is set, or is empty."]
    #[doc = " @returns TRUE when empty."]
    pub fn rofi_theme_is_empty() -> gboolean;
}
extern "C" {
    #[doc = " Reset the current theme."]
    pub fn rofi_theme_reset();
}
extern "C" {
    #[doc = " @param file File name passed to option."]
    #[doc = ""]
    #[doc = " @returns path to theme or copy of filename if not found."]
    pub fn helper_get_theme_path(file: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    #[doc = " @param file File name to prepare."]
    #[doc = " @param parent_file Filename of parent file."]
    #[doc = ""]
    #[doc = " Tries to find full path relative to parent file."]
    #[doc = ""]
    #[doc = " @returns full path to file."]
    pub fn rofi_theme_parse_prepare_file(
        file: *const cty::c_char,
        parent_file: *const cty::c_char,
    ) -> *mut cty::c_char;
}
extern "C" {
    #[doc = " Process conditionals."]
    pub fn rofi_theme_parse_process_conditionals();
}
extern "C" {
    #[doc = " @param parent target theme tree"]
    #[doc = " @param child source theme three"]
    #[doc = ""]
    #[doc = " Merge all the settings from child into parent."]
    pub fn rofi_theme_parse_merge_widgets(parent: *mut ThemeWidget, child: *mut ThemeWidget);
}
extern "C" {
    #[doc = " @param type the media type to parse."]
    #[doc = ""]
    #[doc = " Returns the media type described by type."]
    pub fn rofi_theme_parse_media_type(type_: *const cty::c_char) -> ThemeMediaType;
}
extern "C" {
    pub fn rofi_theme_property_copy_distance(distance: RofiDistance) -> RofiDistance;
}
#[doc = " Data structure holding the internal state of the Widget"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _widget {
    #[doc = " The type of the widget"]
    pub type_: WidgetType,
    #[doc = " X position relative to parent"]
    pub x: cty::c_short,
    #[doc = " Y position relative to parent"]
    pub y: cty::c_short,
    #[doc = " Width of the widget"]
    pub w: cty::c_short,
    #[doc = " Height of the widget"]
    pub h: cty::c_short,
    #[doc = " RofiPadding"]
    pub def_margin: RofiPadding,
    pub def_padding: RofiPadding,
    pub def_border: RofiPadding,
    pub def_border_radius: RofiPadding,
    pub margin: RofiPadding,
    pub padding: RofiPadding,
    pub border: RofiPadding,
    pub border_radius: RofiPadding,
    #[doc = " enabled or not"]
    pub enabled: gboolean,
    #[doc = " Expand the widget when packed"]
    pub expand: gboolean,
    #[doc = " Place widget at end of parent"]
    pub end: gboolean,
    #[doc = " Parent widget"]
    pub parent: *mut _widget,
    #[doc = " Internal"]
    pub need_redraw: gboolean,
    #[doc = " get width of widget implementation function"]
    pub get_width: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _widget) -> cty::c_int>,
    #[doc = " get height of widget implementation function"]
    pub get_height: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _widget) -> cty::c_int>,
    #[doc = " draw widget implementation function"]
    pub draw:
        ::core::option::Option<unsafe extern "C" fn(widget: *mut _widget, draw: *mut cairo_t)>,
    #[doc = " resize widget implementation function"]
    pub resize: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut _widget, arg2: cty::c_short, arg3: cty::c_short),
    >,
    #[doc = " update widget implementation function"]
    pub update: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _widget)>,
    #[doc = " Handle mouse motion, used for dragging"]
    pub motion_notify: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut _widget, x: gint, y: gint) -> gboolean,
    >,
    pub get_desired_height:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut _widget) -> cty::c_int>,
    pub get_desired_width:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut _widget) -> cty::c_int>,
    pub set_state:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut _widget, arg2: *const cty::c_char)>,
    #[doc = " widget find_mouse_target callback"]
    pub find_mouse_target: widget_find_mouse_target_cb,
    #[doc = " widget trigger_action callback"]
    pub trigger_action: widget_trigger_action_cb,
    #[doc = " user data for find_mouse_target and trigger_action callback"]
    pub trigger_action_cb_data: *mut cty::c_void,
    #[doc = " Free widget callback"]
    pub free: ::core::option::Option<unsafe extern "C" fn(widget: *mut _widget)>,
    #[doc = " Name of widget (used for theming)"]
    pub name: *mut cty::c_char,
    pub state: *const cty::c_char,
}
#[test]
fn bindgen_test_layout__widget() {
    assert_eq!(
        ::core::mem::size_of::<_widget>(),
        1448usize,
        concat!("Size of: ", stringify!(_widget))
    );
    assert_eq!(
        ::core::mem::align_of::<_widget>(),
        8usize,
        concat!("Alignment of ", stringify!(_widget))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_widget>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_widget),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_widget>())).x as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_widget),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_widget>())).y as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_widget),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_widget>())).w as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_widget),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_widget>())).h as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_widget),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_widget>())).def_margin as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_widget),
            "::",
            stringify!(def_margin)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_widget>())).def_padding as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_widget),
            "::",
            stringify!(def_padding)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_widget>())).def_border as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_widget),
            "::",
            stringify!(def_border)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_widget>())).def_border_radius as *const _ as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(_widget),
            "::",
            stringify!(def_border_radius)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_widget>())).margin as *const _ as usize },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(_widget),
            "::",
            stringify!(margin)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_widget>())).padding as *const _ as usize },
        816usize,
        concat!(
            "Offset of field: ",
            stringify!(_widget),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_widget>())).border as *const _ as usize },
        976usize,
        concat!(
            "Offset of field: ",
            stringify!(_widget),
            "::",
            stringify!(border)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_widget>())).border_radius as *const _ as usize },
        1136usize,
        concat!(
            "Offset of field: ",
            stringify!(_widget),
            "::",
            stringify!(border_radius)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_widget>())).enabled as *const _ as usize },
        1296usize,
        concat!(
            "Offset of field: ",
            stringify!(_widget),
            "::",
            stringify!(enabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_widget>())).expand as *const _ as usize },
        1300usize,
        concat!(
            "Offset of field: ",
            stringify!(_widget),
            "::",
            stringify!(expand)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_widget>())).end as *const _ as usize },
        1304usize,
        concat!(
            "Offset of field: ",
            stringify!(_widget),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_widget>())).parent as *const _ as usize },
        1312usize,
        concat!(
            "Offset of field: ",
            stringify!(_widget),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_widget>())).need_redraw as *const _ as usize },
        1320usize,
        concat!(
            "Offset of field: ",
            stringify!(_widget),
            "::",
            stringify!(need_redraw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_widget>())).get_width as *const _ as usize },
        1328usize,
        concat!(
            "Offset of field: ",
            stringify!(_widget),
            "::",
            stringify!(get_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_widget>())).get_height as *const _ as usize },
        1336usize,
        concat!(
            "Offset of field: ",
            stringify!(_widget),
            "::",
            stringify!(get_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_widget>())).draw as *const _ as usize },
        1344usize,
        concat!(
            "Offset of field: ",
            stringify!(_widget),
            "::",
            stringify!(draw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_widget>())).resize as *const _ as usize },
        1352usize,
        concat!(
            "Offset of field: ",
            stringify!(_widget),
            "::",
            stringify!(resize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_widget>())).update as *const _ as usize },
        1360usize,
        concat!(
            "Offset of field: ",
            stringify!(_widget),
            "::",
            stringify!(update)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_widget>())).motion_notify as *const _ as usize },
        1368usize,
        concat!(
            "Offset of field: ",
            stringify!(_widget),
            "::",
            stringify!(motion_notify)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_widget>())).get_desired_height as *const _ as usize },
        1376usize,
        concat!(
            "Offset of field: ",
            stringify!(_widget),
            "::",
            stringify!(get_desired_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_widget>())).get_desired_width as *const _ as usize },
        1384usize,
        concat!(
            "Offset of field: ",
            stringify!(_widget),
            "::",
            stringify!(get_desired_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_widget>())).set_state as *const _ as usize },
        1392usize,
        concat!(
            "Offset of field: ",
            stringify!(_widget),
            "::",
            stringify!(set_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_widget>())).find_mouse_target as *const _ as usize },
        1400usize,
        concat!(
            "Offset of field: ",
            stringify!(_widget),
            "::",
            stringify!(find_mouse_target)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_widget>())).trigger_action as *const _ as usize },
        1408usize,
        concat!(
            "Offset of field: ",
            stringify!(_widget),
            "::",
            stringify!(trigger_action)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_widget>())).trigger_action_cb_data as *const _ as usize },
        1416usize,
        concat!(
            "Offset of field: ",
            stringify!(_widget),
            "::",
            stringify!(trigger_action_cb_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_widget>())).free as *const _ as usize },
        1424usize,
        concat!(
            "Offset of field: ",
            stringify!(_widget),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_widget>())).name as *const _ as usize },
        1432usize,
        concat!(
            "Offset of field: ",
            stringify!(_widget),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_widget>())).state as *const _ as usize },
        1440usize,
        concat!(
            "Offset of field: ",
            stringify!(_widget),
            "::",
            stringify!(state)
        )
    );
}
extern "C" {
    #[doc = " @param wid    The widget to initialize."]
    #[doc = " @param parent The widget's parent."]
    #[doc = " @param type The type of the widget."]
    #[doc = " @param name The name of the widget."]
    #[doc = ""]
    #[doc = " Initializes the widget structure."]
    #[doc = ""]
    pub fn widget_init(
        wid: *mut widget,
        parent: *mut widget,
        type_: WidgetType,
        name: *const cty::c_char,
    );
}
extern "C" {
    #[doc = " @param widget The widget handle."]
    #[doc = " @param state  The state of the widget."]
    #[doc = ""]
    #[doc = " Set the state of the widget."]
    pub fn widget_set_state(widget: *mut widget, state: *const cty::c_char);
}
extern "C" {
    #[doc = " @param wid The widget handle."]
    #[doc = ""]
    #[doc = " Get the left padding of the widget."]
    #[doc = ""]
    #[doc = " @returns the left padding in pixels."]
    pub fn widget_padding_get_left(wid: *const widget) -> cty::c_int;
}
extern "C" {
    #[doc = " @param wid The widget handle."]
    #[doc = ""]
    #[doc = " Get the right padding of the widget."]
    #[doc = ""]
    #[doc = " @returns the right padding in pixels."]
    pub fn widget_padding_get_right(wid: *const widget) -> cty::c_int;
}
extern "C" {
    #[doc = " @param wid The widget handle."]
    #[doc = ""]
    #[doc = " Get the top padding of the widget."]
    #[doc = ""]
    #[doc = " @returns the top padding in pixels."]
    pub fn widget_padding_get_top(wid: *const widget) -> cty::c_int;
}
extern "C" {
    #[doc = " @param wid The widget handle."]
    #[doc = ""]
    #[doc = " Get the bottom padding of the widget."]
    #[doc = ""]
    #[doc = " @returns the bottom padding in pixels."]
    pub fn widget_padding_get_bottom(wid: *const widget) -> cty::c_int;
}
extern "C" {
    #[doc = " @param wid The widget handle."]
    #[doc = ""]
    #[doc = " Get width of the content of the widget"]
    #[doc = ""]
    #[doc = " @returns the widget width, excluding padding."]
    pub fn widget_padding_get_remaining_width(wid: *const widget) -> cty::c_int;
}
extern "C" {
    #[doc = " @param wid The widget handle."]
    #[doc = ""]
    #[doc = " Get height of the content of the widget"]
    #[doc = ""]
    #[doc = " @returns the widget height, excluding padding."]
    pub fn widget_padding_get_remaining_height(wid: *const widget) -> cty::c_int;
}
extern "C" {
    #[doc = " @param wid The widget handle."]
    #[doc = ""]
    #[doc = " Get the combined top and bottom padding."]
    #[doc = ""]
    #[doc = " @returns the top and bottom padding of the widget in pixels."]
    pub fn widget_padding_get_padding_height(wid: *const widget) -> cty::c_int;
}
extern "C" {
    #[doc = " @param wid The widget handle."]
    #[doc = ""]
    #[doc = " Get the combined left and right padding."]
    #[doc = ""]
    #[doc = " @returns the left and right padding of the widget in pixels."]
    pub fn widget_padding_get_padding_width(wid: *const widget) -> cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: cty::c_uint,
    pub fp_offset: cty::c_uint,
    pub overflow_arg_area: *mut cty::c_void,
    pub reg_save_area: *mut cty::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::core::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::core::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
